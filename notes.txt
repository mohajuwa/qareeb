"I am facing several issues with a Flutter project. The app is currently using CircularProgressIndicator for loading, but it gets stuck in an infinite loading state. The application is also generally slow. I want to address all these issues and improve the project's overall quality.

Here is a detailed list of what I need:

Loading Indicator and Logic:

The current CircularProgressIndicator gets stuck and never disappears.

I want to replace it with a more modern and visually appealing loading widget, such as ModernLoadingWidget or a similar alternative.

The underlying logic that controls the loading state must be fixed so that the indicator correctly appears and disappears based on the data fetching process.

Performance and Debugging:

The app's performance is slow, both during startup and while loading data.

I need a thorough debug of the project to identify and resolve the root causes of this slowness. This could include issues with API calls, UI rendering, or other performance bottlenecks.

API Integration and Debugging:

I suspect there are issues with the API calls.

Please review and fix all API-related code.

The API endpoint is: [[
                    /* jshint esversion: 6 */
                /* jshint esversion: 8 */
                /* jshint node: true */



                const express = require("express");
                const router = express.Router();
                const multer = require('multer');
                const mysql = require("mysql2");
                const bcrypt = require('bcrypt');
                const axios = require('axios');
                const AllFunction = require("../route_function/function");
                const sendOneNotification = require("../middleware/send");
                const { checkedit } = require("../public/js/editor/ckeditor/adapters/check");
                const { DataFind, DataInsert, DataUpdate, DataDelete } = require("../middleware/databse_query");

                const storage = multer.diskStorage({
                    destination: (req, file, cb) => {
                        cb(null, "./public/uploads/payment_proof");
                    },
                    filename: (req, file, cb) => {
                        cb(null, Date.now() + file.originalname);

                    }
                });

                const upload = multer({ storage: storage });

                const storage1 = multer.diskStorage({
                    destination: (req, file, cb) => {
                        cb(null, "./public/uploads/customer_profile");
                    },
                    filename: (req, file, cb) => {
                        cb(null, Date.now() + file.originalname);

                    }
                });

                const customer_profile = multer({ storage: storage1 });



                router.post("/signup", async (req, res) => {
                    try {
                        const { name, email, ccode, phone, password, referral_code } = req.body;

                        const missingField = ["name", "email", "ccode", "phone", 'password'].find(field => !req.body[field]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' })

                        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);
                        const general = await DataFind(`SELECT refer_credit, one_app_id, one_api_key FROM tbl_general_settings`);
                        let generald = { one_app_id: general[0].one_app_id, one_api_key: general[0].one_api_key }
                        if (cus_data != "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'PhoneNo Already Exists!', general: generald })

                        let esname = mysql.escape(name);
                        const hash = await bcrypt.hash(password, 10);
                        let otp_result = await AllFunction.otpGenerate(6);

                        if (referral_code != "") {
                            const referal_customer = await DataFind(`SELECT id, wallet FROM tbl_customer WHERE referral_code = '${referral_code}'`);
                            if (referal_customer != "") {
                                let amount = parseFloat(referal_customer[0].wallet) + parseFloat(general[0].refer_credit);

                                if (await DataUpdate(`tbl_customer`, `wallet = '${amount}'`, `id = '${referal_customer[0].id}'`, req.hostname, req.protocol) == -1) {
                                    return res.status(200).json({ message: process.env.dataerror, status: false });
                                }

                                let fulldate = await AllFunction.TodatDate();
                                if (await DataInsert(`tbl_transaction_customer`, `c_id, payment_id, amount, date, status, type`,
                                    `${referal_customer[0].id}, '0', '${general[0].refer_credit}', '${fulldate.date}T${fulldate.time}', '1', ''`, req.hostname, req.protocol) == -1) {
                                    return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                                }
                            }
                        }

                        const date = new Date().toISOString().split('T');
                        if (await DataInsert(`tbl_customer`, `profile_image, name, email, country_code, phone, password, status, referral_code, wallet, date`,
                            `'', ${esname}, '${email}', '${ccode}', '${phone}', '${hash}', '1', '${otp_result}', '0', '${date}'`, req.hostname, req.protocol) == -1) {

                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }
                        const new_cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Signup successful', general: generald, customer_data: new_cus_data[0] });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/edit_customer", customer_profile.single("profile_img"), async (req, res) => {
                    try {
                        const { id, name, email, password } = req.body;

                        const missingField = ["id", "name", "email"].find(field => !req.body[field]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let esname = mysql.escape(name), pass, imageUrl = "";
                        const passw = await DataFind(`SELECT profile_image, password FROM tbl_customer WHERE id = '${id}'`);
                        if (!password) pass = passw[0].password
                        else pass = await bcrypt.hash(password, 10);

                        imageUrl = req.file ? "uploads/customer_profile/" + req.file.filename : passw[0].profile_image;

                        if (await DataUpdate(`tbl_customer`, `profile_image = '${imageUrl}', name = ${esname}, email = '${email}', password = '${pass}'`, `id = '${id}'`, req.hostname, req.protocol) == -1) {
                            req.flash('errors', process.env.dataerror);
                            return res.redirect("/valid_license");
                        }
                        const customer_data = await DataFind(`SELECT * FROM tbl_customer WHERE id = '${id}'`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Profile Update Successful', customer_data: customer_data[0] });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/login", async (req, res) => {
                    try {
                        const { ccode, phone, password } = req.body;

                        const missingField = ["ccode", "phone", 'password'].find(field => !req.body[field]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' })

                        const general = await DataFind(`SELECT one_app_id, one_api_key FROM tbl_general_settings`);
                        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

                        if (cus_data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Not Exists!", general: general[0] });

                        if (cus_data[0].status != "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: "Account Deactivated", general: general[0] });

                        const hash_pass = await bcrypt.compare(password, cus_data[0].password);

                        if (!hash_pass) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: "Password Not match", general: general[0] });
                        } else {
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: "Login Sccessful", general: general[0], customer_data: cus_data[0] });
                        }
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/mobile_check", async (req, res) => {
                    try {
                        const { ccode, phone } = req.body;

                        if (ccode == "" || phone == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

                        if (cus_data == "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "New Number" });
                        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Already Exist" });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/forgot_password", async (req, res) => {
                    try {
                        const { ccode, phone, password } = req.body;

                        if (ccode == "" || phone == "" || password == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

                        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

                        if (cus_data == "") {
                            res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Not Exist" });
                        } else {
                            const hash = await bcrypt.hash(password, 10);

                            if (await DataUpdate(`tbl_customer`, `password = '${hash}'`, `id = '${cus_data[0].id}'`, req.hostname, req.protocol) == -1) {

                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }
                            res.status(200).json({ ResponseCode: 200, Result: true, message: 'Password Change successful' });
                        }
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.get("/otp_detail", async (req, res) => {
                    try {
                        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

                        let sms_type = ""
                        if (general_setting[0].sms_type == "1") {
                            sms_type = "MSG91"
                        } else if (general_setting[0].sms_type == "2") {
                            sms_type = "Twilio"
                        } else {
                            sms_type = "No Auth"
                        }

                        if (sms_type != "") res.status(200).json({ ResponseCode: 200, Result: true, message: sms_type });
                        else res.status(200).json({ ResponseCode: 401, Result: false, message: 'Data Not Found' });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/msg91", async (req, res) => {
                    try {
                        const { phoneno } = req.body;

                        if (phoneno == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

                        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

                        let otp_result = await AllFunction.otpGenerate(6)

                        let auth_key = general_setting[0].msg_key;
                        let template_id = general_setting[0].msg_token;

                        let pho_no = phoneno;
                        const options = {
                            method: 'POST',
                            url: 'https://control.msg91.com/api/v5/otp?template_id=' + template_id + '&mobile=' + pho_no + '&otp=' + otp_result,
                            headers: {
                                accept: 'application/json',
                                'content-type': 'application/json',
                                authkey: auth_key
                            },
                            data: { Param1: 'value1' }
                        };

                        axios.request(options)
                            .then(function (response) {
                                console.log(response.data);
                                res.status(200).json({ ResponseCode: 200, Result: true, message: "Otp Send successful", otp: otp_result });
                            })
                            .catch(function (error) {
                                console.error(error);
                                res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
                            });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/twilio", async (req, res) => {
                    try {
                        const { phoneno } = req.body;

                        if (phoneno == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

                        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

                        let otp_result = await AllFunction.otpGenerate(6)

                        let accountSid = general_setting[0].twilio_sid;
                        let authToken = general_setting[0].twilio_token;

                        const client = require('twilio')(accountSid, authToken);

                        client.messages.create({
                            body: 'Your ' + general_setting[0].title + ' otp is ' + otp_result + '',
                            from: general_setting[0].twilio_phoneno,
                            to: phoneno
                        })
                            .then(message => {
                                console.log(message.sid);
                                res.status(200).json({ ResponseCode: 200, Result: true, message: "Otp Send successful", otp: otp_result });
                            })
                            .catch((error) => {
                                console.log(error);
                                res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
                            });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/home", async (req, res) => {
                    try {
                        const { uid, lat, lon } = req.body;

                        if (uid == "" || lat == "" || lon == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const general = await DataFind(`SELECT site_currency, offer_expire_time FROM tbl_general_settings`);
                        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1'`);
                        vehicle_list.map(vvel => { vvel.role = "1" });

                        let module_setting = await DataFind(`SELECT * FROM tbl_module_setting`);
                        module_setting.map(ovel => {
                            ovel.bidding = "0"
                            ovel.role = (parseFloat(ovel.id) + parseFloat(1)).toString()
                        });

                        let package_list = await DataFind(`SELECT id, image, name, description FROM tbl_package`);
                        package_list.map(rvel => {
                            rvel.bidding = "0"
                            rvel.role = "4"
                        });

                        const category_list = [...vehicle_list];

                        let dr = await AllFunction.CustomerReview("cus");
                        const cus_rating = await DataFind(`SELECT cus.id ${dr.tot_review} ${dr.avgstar}
                                                        FROM tbl_customer AS cus
                                                        ${dr.outtable}
                                                        WHERE cus.id = '${uid}' GROUP BY cus.id ORDER BY id DESC`);

                        let rdata = await DataFind(`SELECT veh.*, COALESCE(vec.minimum_fare, '') as minimum_fare, COALESCE(vec.maximum_fare, '') as maximum_fare
                                                    FROM tbl_request_vehicle AS veh
                                                    JOIN tbl_vehicle AS vec ON veh.vehicleid = vec.id
                                                    WHERE c_id = '${uid}' ORDER BY id DESC LIMIT 1`);

                        if (rdata != '') {
                            let rd = await AllFunction.VehicleAllRide(rdata[0], 2);

                            let pickapp = { title: rd.piclatlon.title, subtitle: rd.piclatlon.subtitle }, picklat = { latitude: rd.piclatlon.latitude, longitude: rd.piclatlon.longitude };
                            let drop_add = { title: '', subtitle: '' }, drop_latlon = { latitude: '', longitude: '' }, daddlist = [], dlatlist = [];
                            for (let i = 0; i < rd.dropdata.length;) {
                                if (i == 0) {
                                    drop_add = { title: rd.dropdata[i].title, subtitle: rd.dropdata[i].subtitle };
                                    drop_latlon = { latitude: rd.dropdata[i].latitude, longitude: rd.dropdata[i].longitude };
                                } else {
                                    daddlist.push({ title: rd.dropdata[i].title, subtitle: rd.dropdata[i].subtitle });
                                    dlatlist.push({ latitude: rd.dropdata[i].latitude, longitude: rd.dropdata[i].longitude });
                                }
                                i++;
                            }

                            if (typeof rdata[0].d_id == "string") rdata[0].d_id = JSON.parse(rdata[0].d_id);
                            let runtime = await AllFunction.CurrentDatetoOldDateS(rdata[0].start_time, general[0].offer_expire_time);

                            rdata[0].pick_add = pickapp; rdata[0].pick_latlon = picklat; rdata[0].drop_add = drop_add; rdata[0].drop_latlon = drop_latlon; rdata[0].drop_add_list = daddlist; rdata[0].drop_latlon_list = dlatlist;
                            rdata[0].bidding_run_status = rdata[0].bidding_d_price != '' ? 1 : 0; rdata[0].increased_time = runtime > 0 ? runtime : 0;
                            rdata[0].price = Number(rdata[0].price); rdata[0].tot_km = Number(rdata[0].tot_km);

                            delete rdata[0].pic_lat_long; delete rdata[0].drop_lat_long; delete rdata[0].pic_address; delete rdata[0].drop_address; delete rdata[0].status_time_location;
                            delete rdata[0].bidding_d_price;
                        }

                        return res.status(200).json({
                            ResponseCode: 200, Result: true, message: "Data Load successful", general: { site_currency: general[0].site_currency }, cus_rating: cus_rating[0],
                            category_list, runnig_ride: rdata
                        });

                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })




                router.post("/vehicle_information", async (req, res) => {
                    try {
                        const { vehicle_id } = req.body;

                        if (vehicle_id == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const vehicle_list = await DataFind(`SELECT id, image, name, description, passenger_capacity FROM tbl_vehicle WHERE id = '${vehicle_id}' AND status = '1'`);

                        if (vehicle_list != "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", vehicle: vehicle_list[0] });
                        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "Vehicle Not Found!" });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })




                router.post("/home_wallet", async (req, res) => {
                    try {
                        const { uid } = req.body;
                        if (uid == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const driver = await DataFind(`SELECT wallet FROM tbl_customer WHERE id = '${uid}'`);
                        if (driver == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Driver Not Found!' });

                        let walletp = "0";
                        if (typeof parseFloat(driver[0].wallet) == "Number" || driver[0].wallet) {
                            walletp = driver[0].wallet
                        } else walletp = "0"

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", wallet_amount: driver[0].wallet });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/home_mape", async (req, res) => {
                    try {
                        const { mid, lat, lon } = req.body;

                        // Validate required parameters
                        if (!lat || !lon) {
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: 'Latitude and longitude are required'
                            });
                        }

                        console.log('Request params:', { mid, lat, lon });

                        // Get general settings
                        const general = await DataFind(`SELECT site_currency, vehicle_radius FROM tbl_general_settings`);
                        if (!general || general.length === 0) {
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: 'General settings not found'
                            });
                        }

                        // Check zone
                        let convertzone = [{ latitude: Number(lat), longitude: Number(lon) }];
                        let dzone = await AllFunction.ZoneData();
                        let zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

                        console.log('Zone check result:', {
                            zoneResult: zonecheck[1]?.zc,
                            zoneIds: zonecheck[2]?.zid
                        });

                        if (zonecheck[1].zc != "0") {
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: 'Location is not in the zone!'
                            });
                        }

                        // Determine vehicle ID
                        let v_id;
                        if (!mid || mid === "" || mid === "0") {
                            let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1' ORDER BY id LIMIT 1`);
                            if (!vehicle_list || vehicle_list.length === 0) {
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'No active vehicles found'
                                });
                            }
                            v_id = vehicle_list[0].id;
                        } else {
                            v_id = mid;
                        }

                        console.log('Using vehicle ID:', v_id);

                        // First, check if the vehicle exists and is active
                        const vehicleCheck = await DataFind(`SELECT id, name FROM tbl_vehicle WHERE id = '${v_id}' AND status = '1'`);
                        if (!vehicleCheck || vehicleCheck.length === 0) {
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: 'Vehicle not found or inactive'
                            });
                        }

                        // Build zone condition - handle both single values and comma-separated values
                        const zoneIds = zonecheck[2].zid;
                        let zoneCondition = '';
                        if (Array.isArray(zoneIds)) {
                            // Handle multiple zones - check if zone contains any of these IDs
                            const zoneChecks = zoneIds.map(zid =>
                                `(zone = '${zid}' OR zone LIKE '%,${zid},%' OR zone LIKE '${zid},%' OR zone LIKE '%,${zid}')`
                            ).join(' OR ');
                            zoneCondition = `(${zoneChecks})`;
                        } else {
                            // Handle single zone
                            zoneCondition = `(zone = '${zoneIds}' OR zone LIKE '%,${zoneIds},%' OR zone LIKE '${zoneIds},%' OR zone LIKE '%,${zoneIds}')`;
                        }

                        // Build vehicle condition - handle both direct ID match and comma-separated values
                        const vehicleCondition = `(vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')`;

                        // Updated driver query - simpler approach without complex aliases
                        const driverQuery = `SELECT d.id,
                                            COALESCE(v.map_img, '') AS image,
                                            COALESCE(v.name, '') AS name,
                                            COALESCE(v.description, '') AS description,
                                            COALESCE(d.latitude, '') AS latitude,
                                            COALESCE(d.longitude, '') AS longitude,
                                            d.zone, d.vehicle, d.fstatus, d.status, d.approval_status
                                            FROM tbl_driver d
                                            LEFT JOIN tbl_vehicle v ON v.id = '${v_id}'
                                            WHERE ${zoneCondition}
                                            AND ${vehicleCondition}
                                            AND d.fstatus = '1'
                                            AND d.status = '1'
                                            AND d.approval_status = '1'
                                            AND d.latitude IS NOT NULL
                                            AND d.latitude != ''
                                            AND d.longitude IS NOT NULL
                                            AND d.longitude != ''
                                            AND v.status = '1'`;

                        console.log('Driver query:', driverQuery);

                        const driver = await DataFind(driverQuery);
                        console.log('Total drivers found:', driver ? driver.length : 0);

                        if (!driver || driver.length === 0) {
                            // Enhanced debug info
                            const debugInfo = {};

                            // Check drivers with matching vehicle (regardless of zone)
                            const vehicleDrivers = await DataFind(`SELECT id, zone, vehicle, latitude, longitude, status, fstatus, approval_status
                                                                FROM tbl_driver
                                                                WHERE (vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')
                                                                AND status = '1'`);
                            debugInfo.driversWithMatchingVehicle = vehicleDrivers;

                            // Check drivers in requested zone (regardless of vehicle)
                            const zoneDrivers = await DataFind(`SELECT id, zone, vehicle, latitude, longitude
                                                            FROM tbl_driver
                                                            WHERE ${zoneCondition}
                                                            AND status = '1'
                                                            AND fstatus = '1'
                                                            AND approval_status = '1'`);
                            debugInfo.driversInRequestedZone = zoneDrivers;

                            console.log('Enhanced debug info:', debugInfo);

                            return res.status(200).json({
                                ResponseCode: 200,
                                Result: true,
                                message: 'No drivers found in your zone for this vehicle type',
                                driverid: [],
                                list: [],
                                debug: {
                                    vehicleId: v_id,
                                    requestedZoneIds: zonecheck[2].zid,
                                    searchLocation: { lat, lon },
                                    ...debugInfo,
                                    suggestion: "Check if driver zones match your location's zone assignment"
                                }
                            });
                        }

                        // Filter drivers by radius
                        let list = [], point = { latitude: Number(lat), longitude: Number(lon) }, driverid = [];
                        const radiusMeters = Number(parseFloat(general[0].vehicle_radius) * parseFloat(1000));

                        console.log('Checking radius:', radiusMeters, 'meters');
                        console.log('Search point:', point);

                        for (let i = 0; i < driver.length; i++) {
                            // Validate driver coordinates
                            const driverLat = parseFloat(driver[i].latitude);
                            const driverLon = parseFloat(driver[i].longitude);

                            if (isNaN(driverLat) || isNaN(driverLon)) {
                                console.log(`Driver ${driver[i].id}: Invalid coordinates - lat: ${driver[i].latitude}, lon: ${driver[i].longitude}`);
                                continue;
                            }

                            let dlotlon = {
                                latitude: driverLat,
                                longitude: driverLon
                            };

                            console.log(`Driver ${driver[i].id}: Coordinates - lat: ${driverLat}, lon: ${driverLon}`);

                            let distance = await AllFunction.RadiusCheck(point, dlotlon, radiusMeters);
                            console.log(`Driver ${driver[i].id}: distance check result = ${distance}`);

                            if (distance == 1) {
                                driverid.push(driver[i].id);
                                list.push({
                                    id: driver[i].id,
                                    image: driver[i].image,
                                    name: driver[i].name,
                                    description: driver[i].description,
                                    latitude: driver[i].latitude,
                                    longitude: driver[i].longitude
                                });
                            }
                        }

                        console.log('Final results:', { driverCount: list.length, driverIds: driverid });

                        if (list.length === 0) {
                            return res.status(200).json({
                                ResponseCode: 200,
                                Result: true,
                                message: 'No drivers found within radius',
                                driverid: [],
                                list: [],
                                debug: {
                                    totalDriversInZone: driver.length,
                                    radiusMeters: radiusMeters,
                                    searchPoint: point,
                                    driverCoordinates: driver.map(d => ({
                                        id: d.id,
                                        lat: d.latitude,
                                        lon: d.longitude
                                    }))
                                }
                            });
                        }

                        return res.status(200).json({
                            ResponseCode: 200,
                            Result: true,
                            message: "Data loaded successfully",
                            zone_id: zonecheck[2].zid[0],
                            driverid,
                            list
                        });

                    } catch (error) {
                        console.error('Error in home_mape:', error);
                        res.status(500).json({
                            error: 'Internal server error',
                            message: error.message
                        });
                    }
                });

                router.post("/calculate", async (req, res) => {
                    try {
                        const { uid, mid, mrole, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

                        // Validate required fields
                        const missingField = ["uid", 'mid', 'mrole', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
                        if (missingField) {
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: 'Something went wrong missing fields',
                                missing_field: missingField
                            });
                        }

                        console.log(`üöó Calculate API called for mrole: ${mrole}`);
                        console.log(`üìç Pickup: ${pickup_lat_lon}`);
                        console.log(`üìç Drop: ${drop_lat_lon}`);
                        console.log(`üìç Additional drops: ${JSON.stringify(drop_lat_lon_list)}`);

                        if (mrole == "1") {
                            // Get vehicle details with validation
                            let vehicle = await DataFind(`SELECT * FROM tbl_vehicle WHERE status = '1' AND id = '${mid}'`);
                            if (vehicle == "" || vehicle.length === 0) {
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Vehicle Not Found!'
                                });
                            }

                            console.log(`üöô Vehicle found: ${vehicle[0].name} (ID: ${vehicle[0].id})`);

                            // Convert coordinates to zone format with validation
                            let convertzone;
                            try {
                                convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);
                                console.log("üìç Converted zones:", JSON.stringify(convertzone, null, 2));
                            } catch (zoneError) {
                                console.log("‚ùå Zone conversion error:", zoneError.message);
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Invalid coordinates format'
                                });
                            }

                            // Validate converted zones
                            if (!convertzone || convertzone.length < 2) {
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Invalid coordinate conversion'
                                });
                            }

                            // Get zone data and check if coordinates are in service zones
                            let dzone, zonecheck;
                            try {
                                dzone = await AllFunction.ZoneData();
                                zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);
                                console.log("üîç Zone check result:", JSON.stringify(zonecheck, null, 2));
                            } catch (zoneCheckError) {
                                console.log("‚ùå Zone check error:", zoneCheckError.message);
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Zone validation failed'
                                });
                            }

                            // Get general settings
                            const general = await DataFind(`SELECT * FROM tbl_general_settings`);
                            if (general == "" || general.length === 0) {
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Something went wrong general settings'
                                });
                            }

                            console.log(`üîë Google Maps API Key available: ${!!general[0].google_map_key}`);

                            // Check if all points are within service zones
                            if (zonecheck[1].zc != "0") {
                                console.log(`‚ùå Zone check failed: ${zonecheck[1].zc} points outside service zone`);
                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Address is not in the zone! calculate',
                                    offer_expire_time: general[0].offer_expire_time,
                                    zoneresult: zonecheck[0].zr,
                                    tot_km: 0,
                                    drop_price: 0,
                                    tot_hour: 0,
                                    tot_minute: 0,
                                    tot_second: 0,
                                    driver_id: [],
                                    vehicle: []
                                });
                            }

                            let zoneresult = zonecheck[0].zr;
                            console.log("üó∫Ô∏è Zone results for calculation:", JSON.stringify(zoneresult, null, 2));

                            // Initialize calculation variables
                            let cal = 0, totmin = 0;

                            console.log(`üîß ENHANCED FIX: Processing ${convertzone.length - 1} segments`);

                            // ‚úÖ ENHANCED LOOP: Calculate distance for each segment with better error handling
                            for (let c = 0; c < convertzone.length - 1; c++) {
                                console.log(`\nüîÑ Processing segment ${c + 1}: from point ${c} to point ${c + 1}`);

                                // Validate zone result indices
                                if (c >= zoneresult.length || (c + 1) >= zoneresult.length) {
                                    console.log(`‚ùå Zone result index out of bounds: segment ${c + 1}`);
                                    continue;
                                }

                                // Get zone status for both points in this segment
                                let startZoneStatus = zoneresult[c] ? zoneresult[c].status : 0;
                                let endZoneStatus = zoneresult[c + 1] ? zoneresult[c + 1].status : 0;

                                console.log(`   Point ${c} zone status: ${startZoneStatus} (type: ${typeof startZoneStatus})`);
                                console.log(`   Point ${c + 1} zone status: ${endZoneStatus} (type: ${typeof endZoneStatus})`);

                                // Both points must be in active zones
                                if ((startZoneStatus == 1 || startZoneStatus == "1") &&
                                    (endZoneStatus == 1 || endZoneStatus == "1")) {

                                    // Validate coordinates before API call
                                    if (!convertzone[c] || !convertzone[c + 1] ||
                                        !convertzone[c].latitude || !convertzone[c].longitude ||
                                        !convertzone[c + 1].latitude || !convertzone[c + 1].longitude) {
                                        console.log("‚ùå Invalid coordinates detected in segment");
                                        continue;
                                    }

                                    let pickup = `${convertzone[c].latitude},${convertzone[c].longitude}`;
                                    let drop = `${convertzone[c + 1].latitude},${convertzone[c + 1].longitude}`;

                                    console.log(`üìè Calculating distance from ${pickup} to ${drop}`);

                                    try {
                                        // Add timeout and retry logic for Google Maps API
                                        let distance = await Promise.race([
                                            AllFunction.GetDistance(pickup, drop, general[0].google_map_key),
                                            new Promise((_, reject) =>
                                                setTimeout(() => reject(new Error('Distance API timeout')), 10000)
                                            )
                                        ]);

                                        console.log(`üìä Distance API result:`, JSON.stringify(distance, null, 2));

                                        if (distance && distance.status === 1 && distance.dis && parseFloat(distance.dis) > 0) {
                                            cal += parseFloat(distance.dis);
                                            console.log(`üìà Distance added: ${distance.dis}km, Total: ${cal}km`);

                                            // Enhanced duration parsing
                                            if (distance.dur && typeof distance.dur === 'string') {
                                                let durParts = distance.dur.toLowerCase().split(" ");
                                                console.log(`‚è±Ô∏è Duration: "${distance.dur}", Split: [${durParts.join(', ')}]`);

                                                let minutes = 0;
                                                for (let i = 0; i < durParts.length; i++) {
                                                    if (durParts[i].includes('hour') || durParts[i].includes('hr')) {
                                                        let hours = parseFloat(durParts[i - 1]) || 0;
                                                        minutes += hours * 60;
                                                    } else if (durParts[i].includes('min') || durParts[i].includes('minute')) {
                                                        let mins = parseFloat(durParts[i - 1]) || 0;
                                                        minutes += mins;
                                                    } else if (!isNaN(parseFloat(durParts[i]))) {
                                                        // If it's just a number, assume it's minutes
                                                        if (i === 0 && durParts.length === 2) {
                                                            minutes += parseFloat(durParts[i]);
                                                        }
                                                    }
                                                }

                                                totmin += minutes;
                                                console.log(`‚è±Ô∏è Added ${minutes} minutes, Total: ${totmin} minutes`);
                                            }
                                        } else {
                                            console.log("‚ö†Ô∏è Invalid distance result:");
                                            console.log(`   - distance exists: ${!!distance}`);
                                            console.log(`   - distance.status: ${distance?.status}`);
                                            console.log(`   - distance.dis: ${distance?.dis}`);
                                            console.log(`   - distance.dur: ${distance?.dur}`);
                                        }
                                    } catch (distanceError) {
                                        console.log("üí• Distance API error:", distanceError.message);

                                        // Handle specific Google Maps API errors
                                        if (distanceError.message.includes('timeout')) {
                                            console.log("‚è∞ Google Maps API timeout - using fallback calculation");

                                            // Fallback: Calculate approximate distance using haversine formula
                                            try {
                                                let lat1 = parseFloat(convertzone[c].latitude);
                                                let lon1 = parseFloat(convertzone[c].longitude);
                                                let lat2 = parseFloat(convertzone[c + 1].latitude);
                                                let lon2 = parseFloat(convertzone[c + 1].longitude);

                                                let fallbackDistance = calculateHaversineDistance(lat1, lon1, lat2, lon2);
                                                cal += fallbackDistance;
                                                totmin += Math.round(fallbackDistance * 2); // Rough estimate: 2 minutes per km

                                                console.log(`üìê Fallback distance: ${fallbackDistance}km`);
                                            } catch (fallbackError) {
                                                console.log("üí• Fallback calculation failed:", fallbackError.message);
                                            }
                                        }
                                    }
                                } else {
                                    console.log(`‚ùå Segment ${c + 1} not active - start: ${startZoneStatus}, end: ${endZoneStatus}`);
                                }
                            }

                            console.log(`\nüéØ Final calculation results:`);
                            console.log(`   Total distance: ${cal} km`);
                            console.log(`   Total time: ${totmin} minutes`);
                            console.log(`   Segments processed: ${convertzone.length - 1}`);

                            // Check if distance calculation succeeded
                            if (cal == 0) {
                                console.log("\nüí• Distance calculation failed");
                                console.log("Possible issues:");
                                console.log("1. Google Maps API key invalid or expired");
                                console.log("2. API quota exceeded");
                                console.log("3. Network connectivity issues");
                                console.log("4. All segments outside service zone");

                                return res.status(200).json({
                                    ResponseCode: 401,
                                    Result: false,
                                    message: 'Distance calculation failed - check Google Maps API configuration',
                                    debug: {
                                        zone_results: zoneresult,
                                        converted_zones: convertzone,
                                        active_segments: zoneresult.filter(z => z.status == 1 || z.status == "1").length,
                                        segments_calculated: convertzone.length - 1,
                                        has_google_key: !!general[0].google_map_key,
                                        google_key_length: general[0].google_map_key ? general[0].google_map_key.length : 0,
                                        fix_applied: true,
                                        backend_status: "ENHANCED_LOOP_WITH_FALLBACK"
                                    }
                                });
                            }

                            // Calculate pricing based on distance
                            let roundkm = cal;
                            let drop_price;

                            console.log(`\nüí∞ Calculating price for ${roundkm}km:`);
                            console.log(`   Vehicle: ${vehicle[0].name}`);
                            console.log(`   Min distance: ${vehicle[0].min_km_distance}km`);
                            console.log(`   Min price: ${vehicle[0].min_km_price} per km`);
                            console.log(`   After min price: ${vehicle[0].after_km_price} per km`);

                            if (roundkm <= parseFloat(vehicle[0].min_km_distance)) {
                                drop_price = parseFloat(roundkm) * parseFloat(vehicle[0].min_km_price);
                                console.log(`üí∞ Using base rate: ${roundkm} * ${vehicle[0].min_km_price} = ${drop_price}`);
                            } else {
                                let add_distance = parseFloat(roundkm) - parseFloat(vehicle[0].min_km_distance);
                                drop_price = (parseFloat(vehicle[0].min_km_distance) * parseFloat(vehicle[0].min_km_price)) +
                                    (parseFloat(add_distance) * parseFloat(vehicle[0].after_km_price));
                                console.log(`üí∞ Using tiered rate:`);
                                console.log(`   Base: ${vehicle[0].min_km_distance} * ${vehicle[0].min_km_price} = ${parseFloat(vehicle[0].min_km_distance) * parseFloat(vehicle[0].min_km_price)}`);
                                console.log(`   Additional: ${add_distance} * ${vehicle[0].after_km_price} = ${parseFloat(add_distance) * parseFloat(vehicle[0].after_km_price)}`);
                                console.log(`   Total: ${drop_price}`);
                            }

                            // Convert minutes to hours and minutes
                            let hou_min = await AllFunction.MinuteToHour(totmin);
                            let driver_id = [];
                            let dr_price = parseFloat(parseFloat(drop_price).toFixed(2));

                            console.log(`\n‚úÖ Final calculation results:`);
                            console.log(`   Distance: ${roundkm} km`);
                            console.log(`   Time: ${hou_min.hour}h ${hou_min.minute}m`);
                            console.log(`   Price: ${dr_price}`);
                            console.log(`   Min fare: ${vehicle[0].minimum_fare}`);
                            console.log(`   Max fare: ${vehicle[0].maximum_fare}`);

                            // Check fare limits
                            if (parseFloat(vehicle[0].minimum_fare) > parseFloat(drop_price)) {
                                console.log(`‚ùå Price ${drop_price} below minimum fare ${vehicle[0].minimum_fare}`);
                                return res.status(200).json({
                                    ResponseCode: 200,
                                    Result: true,
                                    message: `The fare is below our minimum limit of ${general[0].site_currency}${vehicle[0].minimum_fare}.`,
                                    offer_expire_time: general[0].offer_expire_time,
                                    zoneresult,
                                    tot_km: 0,
                                    drop_price: 0,
                                    tot_hour: 0,
                                    tot_minute: 0,
                                    tot_second: 0,
                                    driver_id: [],
                                    vehicle: vehicle[0]
                                });
                            } else if (parseFloat(vehicle[0].maximum_fare) < parseFloat(drop_price)) {
                                console.log(`‚ùå Price ${drop_price} exceeds maximum fare ${vehicle[0].maximum_fare}`);
                                return res.status(200).json({
                                    ResponseCode: 200,
                                    Result: true,
                                    message: `The fare exceeds our maximum limit of ${general[0].site_currency}${vehicle[0].maximum_fare}.`,
                                    offer_expire_time: general[0].offer_expire_time,
                                    zoneresult,
                                    tot_km: 0,
                                    drop_price: 0,
                                    tot_hour: 0,
                                    tot_minute: 0,
                                    tot_second: 0,
                                    driver_id: [],
                                    vehicle: vehicle[0]
                                });
                            } else {
                                // Price is within acceptable range
                                console.log(`‚úÖ Price ${drop_price} is within fare limits`);

                                // Handle bidding if enabled
                                if (vehicle[0].bidding == "1") {
                                    console.log(`üéØ Bidding enabled for vehicle ${vehicle[0].id}`);
                                    try {
                                        driver_id = await Vehicle_calculate(0, 0, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 2, convertzone, zonecheck, vehicle[0].id);
                                        console.log(`üë• Found ${driver_id?.driver_id?.length || 0} available drivers for bidding`);
                                    } catch (biddingError) {
                                        console.log(`‚ö†Ô∏è Bidding calculation failed: ${biddingError.message}`);
                                        driver_id = { driver_id: [] };
                                    }
                                }

                                // Return successful calculation
                                console.log(`üéâ Calculation successful - returning results`);
                                return res.status(200).json({
                                    ResponseCode: 200,
                                    Result: true,
                                    message: 'Address calculate successful',
                                    offer_expire_time: general[0].offer_expire_time,
                                    zoneresult,
                                    tot_km: Number(parseFloat(roundkm).toFixed(2)),
                                    drop_price: dr_price,
                                    tot_hour: hou_min.hour,
                                    tot_minute: hou_min.minute,
                                    tot_second: 0,
                                    driver_id: driver_id && driver_id.driver_id ? driver_id.driver_id : [],
                                    vehicle: vehicle[0]
                                });
                            }
                        }

                        // Handle other mrole cases (2 = Outstation, 3 = Rental, 4 = Package)
                        else if (mrole == "2") {
                            console.log(`üöå Outstation ride calculation not implemented yet`);
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: "Outstation calculation not implemented"
                            });
                        }
                        else if (mrole == "3") {
                            console.log(`üïê Rental ride calculation not implemented yet`);
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: "Rental calculation not implemented"
                            });
                        }
                        else if (mrole == "4") {
                            console.log(`üì¶ Package delivery calculation not implemented yet`);
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: "Package calculation not implemented"
                            });
                        }
                        else {
                            console.log(`‚ùì Unknown mrole: ${mrole}`);
                            return res.status(200).json({
                                ResponseCode: 401,
                                Result: false,
                                message: "Invalid service type"
                            });
                        }

                    } catch (error) {
                        console.error("üí• Calculate API Critical Error:", error);
                        console.error("Stack trace:", error.stack);

                        return res.status(500).json({
                            ResponseCode: 500,
                            Result: false,
                            error: error.message,
                            message: "Internal server error during calculation",
                            stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
                        });
                    }
                });

                // Helper function to calculate distance using Haversine formula (fallback)
                function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
                    const R = 6371; // Radius of the Earth in kilometers
                    const dLat = toRadians(lat2 - lat1);
                    const dLon = toRadians(lon2 - lon1);

                    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                        Math.sin(dLon / 2) * Math.sin(dLon / 2);

                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    const distance = R * c; // Distance in kilometers

                    return distance;
                }

                // Helper function to convert degrees to radians
                function toRadians(degrees) {
                    return degrees * (Math.PI / 180);
                }

                // Enhanced Vehicle_calculate function with better error handling
                async function Vehicle_calculate(uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, status, czone, zcheck, vid) {
                    let convertzone, zonecheck, v_id;

                    try {
                        if (status == 1) {
                            convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);

                            let dzone = await AllFunction.ZoneData();
                            zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

                            if (zonecheck[1].zc != "0") return 1;

                            if (mid == "") {
                                let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1' ORDER BY id LIMIT 1`);
                                if (vehicle_list == "" || vehicle_list.length === 0) return 4;
                                v_id = vehicle_list[0].id;
                            } else v_id = mid;

                        } else {
                            convertzone = czone;
                            zonecheck = zcheck;
                            v_id = vid;
                        }

                        const general = await DataFind(`SELECT * FROM tbl_general_settings`);
                        if (general == "" || general.length === 0) return 2;

                        console.log(`üîç Looking for drivers for vehicle ${v_id} in zones ${JSON.stringify(zonecheck[2]?.zid)}`);

                        // Build zone condition - handle both single values and comma-separated values
                        const zoneIds = zonecheck[2].zid;
                        let zoneCondition = '';

                        if (Array.isArray(zoneIds)) {
                            // Handle multiple zones
                            const zoneChecks = zoneIds.map(zid =>
                                `(zone = '${zid}' OR zone LIKE '%,${zid},%' OR zone LIKE '${zid},%' OR zone LIKE '%,${zid}')`
                            ).join(' OR ');
                            zoneCondition = `(${zoneChecks})`;
                        } else {
                            // Handle single zone
                            zoneCondition = `(zone = '${zoneIds}' OR zone LIKE '%,${zoneIds},%' OR zone LIKE '${zoneIds},%' OR zone LIKE '%,${zoneIds}')`;
                        }

                        // Build vehicle condition
                        const vehicleCondition = `(vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')`;

                        // Enhanced driver query with better error handling
                        const driverQuery = `SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                            COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                            FROM tbl_driver AS dr
                                            LEFT JOIN tbl_vehicle AS ve ON ve.id = '${v_id}'
                                            WHERE ${zoneCondition}
                                            AND ${vehicleCondition}
                                            AND dr.fstatus = '1'
                                            AND dr.status = '1'
                                            AND dr.approval_status = '1'
                                            AND dr.rid_status = '0'
                                            AND dr.latitude IS NOT NULL
                                            AND dr.latitude != ''
                                            AND dr.longitude IS NOT NULL
                                            AND dr.longitude != ''
                                            AND ve.status = '1'`;

                        console.log(`üîç Driver query: ${driverQuery}`);

                        const driver = await DataFind(driverQuery);
                        console.log(`üë• Found ${driver ? driver.length : 0} potential drivers`);

                        if (driver == "" || driver.length === 0) {
                            console.log('‚ùå No drivers found matching criteria');
                            return 3;
                        }

                        let dkm = 0, dtime = 0;
                        let cpickup = `${convertzone[0].latitude},${convertzone[0].longitude}`;
                        let caldriver = [], driver_id = [], minkm = 0;
                        let point = {
                            latitude: Number(convertzone[0].latitude),
                            longitude: Number(convertzone[0].longitude)
                        };

                        const radiusMeters = Number(parseFloat(general[0].vehicle_radius) * parseFloat(1000));
                        console.log(`üìè Checking drivers within ${radiusMeters}m radius`);

                        for (let i = 0; i < driver.length; i++) {
                            try {
                                // Validate driver coordinates
                                const driverLat = parseFloat(driver[i].latitude);
                                const driverLon = parseFloat(driver[i].longitude);

                                if (isNaN(driverLat) || isNaN(driverLon)) {
                                    console.log(`‚ùå Driver ${driver[i].id}: Invalid coordinates`);
                                    continue;
                                }

                                let dlotlon = {
                                    latitude: driverLat,
                                    longitude: driverLon
                                };

                                // Check if driver is within radius
                                let distance = await AllFunction.RadiusCheck(point, dlotlon, radiusMeters);
                                console.log(`üöó Driver ${driver[i].id}: radius check = ${distance}`);

                                if (distance == 1) {
                                    if (status == "2") {
                                        // Calculate driver pickup time
                                        let driverLocation = `${driver[i].latitude},${driver[i].longitude}`;

                                        try {
                                            let dstance = await Promise.race([
                                                AllFunction.GetDistance(driverLocation, cpickup, general[0].google_map_key),
                                                new Promise((_, reject) =>
                                                    setTimeout(() => reject(new Error('Driver distance timeout')), 5000)
                                                )
                                            ]);

                                            if (dstance && dstance.dis) {
                                                dkm = Math.round(parseFloat(dstance.dis));

                                                let spltime = dstance.dur ? dstance.dur.split(" ") : [];
                                                if (spltime.length == 2) {
                                                    dtime = parseFloat(spltime[0]) || 0;
                                                } else if (spltime.length == 4) {
                                                    dtime = (parseFloat(spltime[0]) * 60) + parseFloat(spltime[2]) || 0;
                                                }

                                                if (minkm == 0) minkm = dtime;
                                                if (parseFloat(minkm) > parseFloat(dtime)) minkm = dtime;
                                            }
                                        } catch (distanceError) {
                                            console.log(`‚ö†Ô∏è Driver ${driver[i].id} distance calculation failed:`, distanceError.message);
                                            // Use fallback calculation
                                            let fallbackDistance = calculateHaversineDistance(
                                                point.latitude, point.longitude,
                                                driverLat, driverLon
                                            );
                                            dtime = Math.round(fallbackDistance * 2); // Rough estimate: 2 minutes per km
                                            if (minkm == 0 || dtime < minkm) minkm = dtime;
                                        }
                                    }

                                    driver_id.push(driver[i].id);
                                    caldriver.push({
                                        id: driver[i].id,
                                        image: driver[i].image,
                                        name: driver[i].name,
                                        description: driver[i].description,
                                        latitude: driver[i].latitude,
                                        longitude: driver[i].longitude
                                    });
                                }
                            } catch (driverError) {
                                console.log(`‚ùå Error processing driver ${driver[i].id}:`, driverError.message);
                                continue;
                            }
                        }

                        console.log(`‚úÖ Final driver results: ${driver_id.length} drivers found`);

                        if (status == "1") return { driver_id, caldriver };
                        else return { minkm: minkm, driver_id: driver_id };

                    } catch (error) {
                        console.error('üí• Vehicle_calculate error:', error);
                        return status == "1" ? { driver_id: [], caldriver: [] } : { minkm: 0, driver_id: [] };
                    }
                }



                router.post("/module_calculate", async (req, res) => {
                    try {
                        const { uid, mid, mrole, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

                        const missingField = ["uid", 'mid', 'mrole', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);

                        let dzone = await AllFunction.ZoneData();
                        let zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

                        if (zonecheck[1].zc != "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! module_calculate' });

                        const vehicle = await DataFind(`SELECT * FROM tbl_vehicle WHERE status = '1' AND bidding = '0'`);
                        if (vehicle == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });

                        let zoneresult = zonecheck[0].zr, dhour = 0, dtime = 0;

                        const general = await DataFind(`SELECT * FROM tbl_general_settings`);
                        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let cal = 0, hour = 0, time = 0, totmin = 0;
                        for (let a = 1; a < zoneresult.length;) {

                            let pickup = `${convertzone[a - 1].latitude},${convertzone[a - 1].longitude}`;
                            let drop = `${convertzone[a].latitude},${convertzone[a].longitude}`;

                            let distance = await AllFunction.GetDistance(pickup, drop, general[0].google_map_key);

                            cal += parseFloat(distance.dis)

                            let spltime = distance.dur.split(" ");
                            if (spltime.length == "2") {
                                dhour = 0; dtime = parseFloat(spltime[0]);
                            } else if (spltime.length == "4") {
                                dhour = parseFloat(spltime[0]); dtime = parseFloat(spltime[2]);
                            }

                            totmin += parseFloat(dhour) * 60 + parseFloat(dtime);
                            hour += parseFloat(dhour); time += dtime;
                            a++;
                        }
                        if (cal == "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let hou_min = await AllFunction.MinuteToHour(totmin);

                        let caldriver = [];
                        for (let c = 0; c < vehicle.length;) {
                            let drop_price, add_distance, veh = "", addtime = "";

                            let vehcal = await Vehicle_calculate(0, 0, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 2, convertzone, zonecheck, vehicle[c].id);

                            if (vehcal != 3) {
                                addtime = await AllFunction.AddDateMinute(parseFloat(vehcal.minkm) + parseFloat(totmin)); veh = vehcal.minkm;
                            }

                            if (cal <= vehicle[c].min_km_distance) {
                                drop_price = parseFloat(cal) * parseFloat(vehicle[c].min_km_price);
                            } else {
                                add_distance = parseFloat(cal) - parseFloat(Number(vehicle[c].min_km_distance));
                                drop_price = (parseFloat(vehicle[c].min_km_distance) * parseFloat(vehicle[c].min_km_price) + (parseFloat(add_distance) * parseFloat(vehicle[c].after_km_price)));
                            }

                            caldriver.push({
                                ...vehicle[c], dri_pic_time: veh, dri_pic_drop: addtime, drop_price: parseFloat(parseFloat(drop_price).toFixed(2)), drop_hour: hou_min.hour, drop_time: hou_min.minute,
                                drop_km: parseFloat(parseFloat(cal).toFixed(2))
                            });
                            c++;
                        }

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Address calculate successful', caldriver });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })








                router.post("/vehicle_calculate", async (req, res) => {
                    try {
                        const { uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

                        const missingField = ["uid", 'mid', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong vehicle_calculate' });

                        let caldata = await Vehicle_calculate(uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 1)
                        if (caldata == "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! vehicle_calculate' });
                        if (caldata == "2") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
                        if (caldata == "3") return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver not found! vehicle_calculate', driver_id: [], caldriver: [] });
                        if (caldata == "4") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });
                        if (caldata == "5") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong vehicle_calculate' });

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Address calculate successful', driver_id: caldata.driver_id, caldriver: caldata.caldriver });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                });



                router.post("/add_vehicle_request", async (req, res) => {
                    try {
                        const { uid, driverid, vehicle_id, price, tot_km, tot_hour, tot_minute, payment_id, m_role, coupon_id, bidd_auto_status, pickup, drop, droplist, pickupadd, dropadd, droplistadd } = req.body;

                        const missingField = await AllFunction.CheckBodyData(req, ["uid", "driverid", "vehicle_id", "price", "tot_km", "tot_hour", "tot_minute", "payment_id", "m_role",
                            "pickup", "drop", "pickupadd", "dropadd"]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let convertz = await AllFunction.ZoneLatlon(pickup, drop, droplist), bid_d = [];

                        let pic = "", dropdata = "", picadd = "", dropad = "", id = 0, alcount = 0, drocount = 2, senddataJson = JSON.stringify(driverid),
                            tkm = parseFloat(parseFloat(tot_km).toFixed(2));

                        for (let i = 0; i < convertz.length;) {
                            if (i == "0") pic = convertz[i].latitude + "&!" + convertz[i].longitude
                            else dropdata += dropdata == "" ? convertz[i].latitude + "&!" + convertz[i].longitude : "&!!" + convertz[i].latitude + "&!" + convertz[i].longitude;
                            alcount++;
                            i++;
                        }

                        picadd = pickupadd.title + "&!" + pickupadd.subt; dropad = dropadd.title + "&!" + dropadd.subt;
                        if (droplistadd && droplistadd != "") {
                            for (let a = 0; a < droplistadd.length;) {
                                dropad += dropad == "" ? droplistadd[a].title + "&!" + droplistadd[a].subt : "&!!" + droplistadd[a].title + "&!" + droplistadd[a].subt;
                                drocount++;
                                a++;
                            }
                        }
                        if (alcount != drocount) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const general = await DataFind(`SELECT default_payment FROM tbl_general_settings`);
                        let payment = payment_id == "0" ? general[0].default_payment : payment_id;

                        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);

                        const vehicle_list = await DataFind(`SELECT * FROM tbl_vehicle WHERE id = '${vehicle_id}' AND status = '1'`);

                        for (let i = 0; i < driverid.length;) {
                            sendOneNotification("New ride request received! Ready to go!", 'driver', driverid[i]);
                            i++;
                        }

                        let date = new Date().toISOString(), bidd_auto_st = bidd_auto_status == "true" ? '1' : '0';

                        id = await DataInsert(`tbl_request_vehicle`, `c_id, d_id, bidding_d_price, bidding_status, bidd_auto_status, pic_lat_long, drop_lat_long, pic_address, drop_address, price,
                            tot_km, tot_hour, tot_minute, vehicleid, payment_id, status, status_time_location, m_role, coupon_id, start_time`,
                            `'${uid}', '${senddataJson}', '', '${vehicle_list[0].bidding}', '${bidd_auto_st}', '${pic}', '${dropdata}', '${picadd}', '${dropad}', '${price}',
                            '${tkm}', '${tot_hour}', '${tot_minute}', '${vehicle_id}', '${payment}', '0', '', '${m_role}', '${coupon_id}', '${date}'`, req.hostname, req.protocol);

                        if (id == -1) return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        return res.status(200).json({ ResponseCode: 200, Result: true, message: `We‚Äôve sent ${driverid.length} captain requests; they‚Äôll confirm shortly.`, id: id.insertId });


                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.get("/vehicle_cancel_reason", async (req, res) => {
                    try {
                        const ride_cancel_list = await DataFind(`SELECT id, title FROM tbl_ride_cancel_reason WHERE status = '1'`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', ride_cancel_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.get("/review_data", async (req, res) => {
                    try {
                        const review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', review_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/vehicle_live_location", async (req, res) => {
                    try {
                        const { uid, d_id } = req.body;

                        if (!uid || !d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const data = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${uid}' AND d_id = '${d_id}'`);
                        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        const driver = await DataFind(`SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                                        COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                                        FROM tbl_driver AS dr
                                                        JOIN tbl_vehicle AS ve ON dr.vehicle = ve.id AND ve.id = dr.vehicle
                                                        WHERE dr.id = '${data[0].d_id}' AND dr.fstatus = '1' AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', driver_location: driver[0] });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/timeout_vehicle_request", async (req, res) => {
                    try {
                        const { request_id, uid } = req.body;

                        if (!request_id || !uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
                        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        if (await DataUpdate(`tbl_request_vehicle`, `d_id = '[]', status = '0'`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        let array = data[0].d_id
                        if (typeof array == "string") array = JSON.parse(array);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Out successful', id: data[0].id, driverid: array });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/resend_vehicle_request", async (req, res) => {
                    try {
                        const { uid, driverid } = req.body;

                        if (!uid || !driverid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
                        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        let pl = data[0].pic_lat_long.split("&!"), dl = data[0].drop_lat_long.split("&!!"), drop_lat_lon = "", drop_lat_lon_list = []
                        for (let i = 0; i < dl.length;) {
                            let dspl = dl[i].split("&!");
                            if (i == "0") drop_lat_lon = `${dspl[0]},${dspl[1]}`;
                            else {
                                drop_lat_lon_list.push({ "lat": dspl[0], "long": dspl[1] });
                            }
                            i++;
                        }

                        let caldata = await Vehicle_calculate(uid, data[0].vehicleid, `${pl[0]},${pl[1]}`, drop_lat_lon, drop_lat_lon_list, 1);
                        if (caldata == "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! resend_vehicle_request' });
                        if (caldata == "2") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
                        if (caldata == "3") return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver not found! resend_vehicle_request', driver_id: [], caldriver: [] });
                        if (caldata == "4") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });
                        if (caldata == "5") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let d_id = caldata.driver_id, senddataJson;
                        if (typeof d_id == "string") {
                            d_id = JSON.parse(d_id);
                            senddataJson = JSON.stringify(d_id);
                        } else senddataJson = JSON.stringify(d_id);

                        if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${senddataJson}', bidding_d_price = '', status = '0'`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }
                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Resend successful', id: data[0].id, driver_list: JSON.parse(senddataJson) });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/remove_vehicle_request", async (req, res) => {
                    try {
                        const { uid } = req.body;

                        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
                        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        if (await DataDelete(`tbl_request_vehicle`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        let array = data[0].d_id;
                        if (typeof array == "string") array = JSON.parse(array);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Cancel successful', id: data[0].id, driver_list: array });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/vehicle_ride_cancel", async (req, res) => {
                    try {
                        const { uid, request_id, cancel_id, lat, lon } = req.body;
                        if (!uid || !request_id || !cancel_id || !lat || !lon) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let rd, indata, fulldate = await AllFunction.TodatDate(), status = "3", driver_list = [];
                        rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                        if (rd == "") {

                            rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);
                            if (rd == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                            let updatet = rd[0].status_time_location != "" ? `${rd[0].status_time_location}&!!${status}&${fulldate.date}T${fulldate.time}&${lat}&${lon}` :
                                `${status}&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;

                            let espiadd = mysql.escape(rd[0].pic_address), esdroadd = mysql.escape(rd[0].drop_address);
                            driver_list = [parseFloat(rd[0].d_id)];

                            let setime = rd[0].status_time_location.split("&!!"), starttime = "";

                            let stime = setime[0].split("&"), etime = new Date().toISOString();
                            if (stime[0] == "1") starttime = await AllFunction.TodatDate(stime[1]);

                            indata = await DataInsert(`tbl_order_vehicle`, `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, paid_status, price, final_price, paid_amount, coupon_amount, addi_time_price, platform_fee,
                                weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, coupon_id, additional_time, ride_status, start_time, end_time, drop_tot,
                                drop_complete, current_run_time, status_time, status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, payment_img,
                                cancel_reason, req_id`,
                                `'${rd[0].c_id}', '${rd[0].d_id}', '${rd[0].vehicleid}', '${rd[0].bidding_status}', '${rd[0].bidd_auto_status}', '0', '${rd[0].price}', '${rd[0].final_price}', '0', '${rd[0].coupon_amount}', '${rd[0].addi_time_price}',
                                '${rd[0].platform_fee}', '${rd[0].weather_price}', '0', '${rd[0].tot_km}', '${rd[0].tot_hour}', '${rd[0].tot_minute}', '4', '', '${rd[0].m_role}',
                                '${rd[0].coupon_id}', '${rd[0].additional_time}', '${rd[0].ride_status}', '${stime[1]}', '${etime}', '${rd[0].drop_tot}', '${rd[0].drop_complete}', '${rd[0].current_run_time}',
                                '${rd[0].status_time}', '${updatet}', '', '${rd[0].pic_lat_long}', '${rd[0].drop_lat_long}', ${espiadd}, ${esdroadd}, '', '${cancel_id}', '${rd[0].id}'`,
                                req.hostname, req.protocol);

                            if (indata == -1) return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });

                            if (await DataDelete(`tbl_cart_vehicle`, `id = '${rd[0].id}'`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }

                            if (await DataUpdate(`tbl_driver`, `rid_status = '0' AND check_status = '0'`, `id = '${rd[0].d_id}'`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }

                        } else {

                            let updatet = rd[0].status_time_location != "" ? `${rd[0].status_time_location}&!!${status}&${fulldate.date}T${fulldate.time}&${lat}&${lon}` :
                                `${status}&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;

                            let dropcount = rd[0].drop_lat_long.split("&!!").length, espiadd = mysql.escape(rd[0].pic_address), esdroadd = mysql.escape(rd[0].drop_address)
                            driver_list = rd[0].d_id;
                            if (typeof rd[0].d_id == "string") driver_list = JSON.parse(rd[0].d_id);

                            indata = await DataInsert(`tbl_order_vehicle`, `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, paid_status, price, final_price, paid_amount, coupon_amount,
                                addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, coupon_id, additional_time, ride_status,
                                start_time, end_time, drop_tot, drop_complete, current_run_time, status_time, status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address,
                                drop_address, payment_img, cancel_reason, req_id`,
                                `'${rd[0].c_id}', '${rd[0].d_id}', '${rd[0].vehicleid}', '${rd[0].bidding_status}', '${rd[0].bidd_auto_status}', '0', '${rd[0].price}', '0', '0', '0', '0', '0', '0',
                                '0', '${rd[0].tot_km}', '${rd[0].tot_hour}', '${rd[0].tot_minute}', '4', '${rd[0].payment_id}', '${rd[0].m_role}', '', '${rd[0].additional_time}', '0', '', '',
                                '${dropcount}', '' , '', '', '${updatet}', '', '${rd[0].pic_lat_long}', '${rd[0].drop_lat_long}', ${espiadd}, ${esdroadd}, '', '${cancel_id}', '${rd[0].id}'`,
                                req.hostname, req.protocol);

                            if (indata == -1) return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });

                            if (await DataDelete(`tbl_request_vehicle`, `id = '${rd[0].id}'`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }
                        }

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Cancel successful', driverid: driver_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })


                router.post("/vehicle_ride_addstatus", async (req, res) => {
                    try {
                        const { uid, d_id, request_id } = req.body;
                        if (!uid || !d_id || !request_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${uid}' AND d_id = '${d_id}'`);
                        if (rd == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        if (rd[0].status == "3") {
                            if (rd[0].ride_status != "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
                        } else if (rd[0].status == "6") {
                            if (rd[0].ride_status != "6") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
                        }
                        if (rd[0].status == "0" || rd[0].status == "1" || rd[0].status == "2" || rd[0].status == "4" || rd[0].status == "5" || rd[0].status == "7" || rd[0].status == "8") {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
                        }

                        let dlatlon = rd[0].drop_lat_long.split("&!!"), daddress = rd[0].drop_address.split("&!!"), pending_ride = "", drop_list = [];

                        if (rd[0].drop_complete == "") pending_ride = 0;
                        else pending_ride = parseFloat(rd[0].drop_complete) + 1;

                        let ccheck = await AllFunction.CheckCurrentLocation(pending_ride, dlatlon, daddress);

                        for (let i = 0; i < dlatlon.length;) {
                            let checkadd = daddress[i].split("&!"), checkl = dlatlon[i].split("&!"), status = "";

                            if (pending_ride == i) status = "2";
                            if (pending_ride > i) status = "3";
                            if (pending_ride < i) status = "1";

                            drop_list.push({ status: status, title: checkadd[0], subtitle: checkadd[1], latitude: checkl[0], longitude: checkl[1] });
                            i++;
                        }

                        return res.status(200).json({
                            ResponseCode: 200, Result: true, message: "Service Start Successful", current_address: ccheck.current_address,
                            next_address: ccheck.next_address, drop_list
                        });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })





                router.post("/vehicle_driver_detail", async (req, res) => {
                    try {
                        const { uid, d_id, request_id } = req.body;

                        if (!uid || !d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let dr = await AllFunction.DriverReview("cve");
                        let rd = await DataFind(`SELECT cve.id, cve.c_id, cve.d_id, cve.price, cve.tot_km, cve.status, cve.otp, cve.tot_hour, cve.tot_minute,
                                                COALESCE(dr.profile_image, "") AS profile_image, COALESCE(dr.vehicle_image, "") AS vehicle_image, COALESCE(dr.first_name, "") AS first_name,
                                                COALESCE(dr.last_name, "") AS last_name, COALESCE(dr.primary_ccode, "") AS primary_ccode, COALESCE(dr.primary_phoneNo, "") AS primary_phoneNo,
                                                COALESCE(dr.language, "") AS language, COALESCE(dr.vehicle_number, "") AS vehicle_number, COALESCE(dr.car_color, "") AS car_color,
                                                COALESCE(dr.passenger_capacity, "") AS passenger_capacity, COALESCE(GROUP_CONCAT(DISTINCT vr.name SEPARATOR ','), '') AS prefrence_name,
                                                COALESCE(dr.date, "") AS join_date, COALESCE(dr.latitude, "") AS latitude, COALESCE(dr.longitude, "") AS longitude, COALESCE(vec.map_img, "") AS map_img,
                                                COALESCE(vec.name, "") AS car_name
                                                ${dr.tot_review} ${dr.avgstar}, COALESCE(COUNT(DISTINCT ov.id), 0) AS tot_complete_order
                                                FROM tbl_cart_vehicle AS cve
                                                JOIN tbl_driver AS dr ON cve.d_id = dr.id
                                                JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                                LEFT JOIN tbl_vehicle_preference AS vr ON FIND_IN_SET(vr.id, dr.vehicle_prefrence) > 0
                                                LEFT JOIN tbl_order_vehicle AS ov ON cve.d_id = ov.d_id
                                                ${dr.table}
                                                WHERE ${request_id != "" ? `cve.id = '${request_id}' AND` : ``}  cve.c_id = '${uid}' AND cve.d_id = '${d_id}' GROUP BY cve.id`);

                        if (rd != "") {
                            rd[0].rating = parseFloat(rd[0].avg_star); rd[0].tot_review = parseFloat(rd[0].tot_review); rd[0].tot_hour = parseFloat(rd[0].tot_hour); rd[0].tot_minute = parseFloat(rd[0].tot_minute)
                            delete rd[0].avg_star
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver Data Load Successful', accepted_d_detail: rd[0] });
                        } else {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Data Not Found!', accepted_d_detail: [] });
                        }
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/driver_profile_detail", async (req, res) => {
                    try {
                        const { d_id } = req.body;
                        if (!d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let dr = await AllFunction.DriverReview("dr");
                        let rd = await DataFind(`SELECT dr.profile_image, dr.vehicle_image, dr.first_name, dr.last_name, dr.primary_ccode, dr.primary_phoneNo, dr.language, dr.vehicle_number, dr.car_color,
                                                dr.passenger_capacity, dr.date AS join_date,
                                                COALESCE(GROUP_CONCAT(DISTINCT vr.name SEPARATOR ','), '') AS prefrence_name, COALESCE(vec.name, "") AS car_name
                                                ${dr.tot_review} ${dr.avgstar}, COALESCE(COUNT(DISTINCT ov.id), 0) AS tot_complete_order
                                                FROM tbl_driver AS dr
                                                JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                                LEFT JOIN tbl_vehicle_preference AS vr ON FIND_IN_SET(vr.id, dr.vehicle_prefrence) > 0
                                                LEFT JOIN tbl_order_vehicle AS ov ON dr.id = dr.id
                                                ${dr.outtable}
                                                WHERE dr.id = '${d_id}' GROUP BY dr.id`);

                        if (rd != "") {
                            rd[0].rating = parseFloat(rd[0].avg_star); rd[0].tot_review = parseFloat(rd[0].tot_review);
                            delete rd[0].avg_star
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver Data Load Successful', d_detail: rd[0] });
                        } else {
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Not Found!', d_detail: [] });
                        }
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })





                router.post("/vehicle_ride_complete", upload.single('payment_img'), async (req, res) => {
                    try {
                        const { uid, d_id, request_id, wallet, payment_id } = req.body;
                        if (!uid || !d_id || !request_id || !wallet) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${uid}' AND d_id = '${d_id}'`);

                        const dr = await DataFind(`SELECT * FROM tbl_driver WHERE id = '${rd[0].d_id}'`);
                        if (rd == "" || dr == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });
                        if (parseFloat(rd[0].status) < 7) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Step!' });

                        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
                        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer not found!' });

                        let espiadd = mysql.escape(rd[0].pic_address), esdroadd = mysql.escape(rd[0].drop_address);

                        let setime = rd[0].status_time_location.split("&!!"), starttime = "", end_time = "", imageUrl = "", paid_amount = 0, paid_status = 0
                        let stime = setime[0].split("&"), etime = setime[setime.length - 1].split("&");

                        if (rd[0].payment_id == "10" || rd[0].payment_id == "11") {

                            if (!req.file) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Upload Image!' });
                            imageUrl = req.file ? "uploads/payment_proof/" + req.file.filename : null;
                        }

                        paid_amount = 0; paid_status = 1, fullwallet = parseFloat(dr[0].wallet), cash = 0, tot_cash = 0, payout_wallet = 0, fulldate = await AllFunction.TodatDate();

                        const nwallet_amount = parseFloat((parseFloat(rd[0].price) + parseFloat(rd[0].addi_time_price) + parseFloat(rd[0].weather_price)).toFixed(2));

                        if (parseFloat(wallet) != 0) {
                            if (parseFloat(rd[0].final_price) > parseFloat(wallet)) {
                                paid_amount = parseFloat((parseFloat(rd[0].final_price) - parseFloat(wallet)).toFixed(2));

                                if (parseFloat(rd[0].platform_fee) > parseFloat(paid_amount) && payment_id == "9") {
                                    cash = parseFloat((parseFloat(rd[0].platform_fee) - parseFloat(paid_amount)).toFixed(2));
                                }
                            }

                            let cdata = customer[0].wallet, wamount = 0;
                            if (cdata || cdata != "0" || cdata != "NaN") wamount = cdata;
                            let wallet_amount = parseFloat((parseFloat(wamount) - parseFloat(wallet)).toFixed(2));

                            if (await DataUpdate(`tbl_customer`, `wallet = '${wallet_amount}'`, `id = '${uid}'`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }

                            if (payment_id == "9") {
                                fullwallet = parseFloat((parseFloat(dr[0].wallet) + parseFloat(nwallet_amount)).toFixed(2));
                                payout_wallet = parseFloat((parseFloat(dr[0].payout_wallet) + parseFloat(wallet)).toFixed(2));
                            }

                        } else {
                            paid_amount = parseFloat(rd[0].final_price);
                            if (payment_id != "9") fullwallet = parseFloat((parseFloat(dr[0].wallet) + parseFloat(nwallet_amount)).toFixed(2));
                        }

                        if (payment_id == "9") {
                            if (wallet == 0) payout_wallet = parseFloat(dr[0].payout_wallet);
                            if (cash == 0) tot_cash = parseFloat((parseFloat(dr[0].tot_cash) + parseFloat(rd[0].platform_fee)).toFixed(2));
                            else tot_cash = parseFloat((parseFloat(dr[0].tot_cash) + parseFloat(cash)).toFixed(2));
                        } else {
                            payout_wallet = parseFloat((parseFloat(dr[0].payout_wallet) + parseFloat(nwallet_amount)).toFixed(2));
                            tot_cash = parseFloat(dr[0].tot_cash);
                        }

                        if (await DataUpdate(`tbl_driver`, `wallet = '${fullwallet}', payout_wallet = '${payout_wallet}', tot_cash = '${tot_cash}', rid_status = '0' AND check_status = '0'`,
                            `id = '${rd[0].d_id}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        let updatet = rd[0].status_time_location != "" ? `${rd[0].status_time_location}&!!8&${fulldate.date}T${fulldate.time}&0&0` :
                            `8&${fulldate.date}T${fulldate.time}&0&0`;

                        let insertid = await DataInsert(`tbl_order_vehicle`, `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, paid_status, price, final_price, paid_amount, coupon_amount,
                            addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, coupon_id, additional_time, ride_status, start_time,
                            end_time, drop_tot, drop_complete, current_run_time, status_time, status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address,
                            payment_img, cancel_reason, req_id`,
                            `'${rd[0].c_id}', '${rd[0].d_id}', '${rd[0].vehicleid}', '${rd[0].bidding_status}', '${rd[0].bidd_auto_status}', '${paid_status}', '${rd[0].price}', '${rd[0].final_price}',
                            '${paid_amount}', '${rd[0].coupon_amount}', '${rd[0].addi_time_price}', '${rd[0].platform_fee}', '${rd[0].weather_price}', '${wallet}', '${rd[0].tot_km}', '${rd[0].tot_hour}',
                            '${rd[0].tot_minute}', '8', '${payment_id}', '${rd[0].m_role}', '${rd[0].coupon_id}', '${rd[0].additional_time}', '${rd[0].ride_status}', '${stime[1]}', '${etime[1]}',
                            '${rd[0].drop_tot}', '${rd[0].drop_complete}', '${rd[0].current_run_time}', '${rd[0].status_time}', '${updatet}', '${rd[0].status_calculation}',
                            '${rd[0].pic_lat_long}', '${rd[0].drop_lat_long}', ${espiadd}, ${esdroadd}, '${imageUrl}', '', '${rd[0].id}'`, req.hostname, req.protocol);

                        if (insertid == -1) return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });

                        if (await DataDelete(`tbl_cart_vehicle`, `id = '${rd[0].id}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        if (parseFloat(wallet) != 0) {
                            if (await DataInsert(`tbl_transaction_customer`, `c_id, payment_id, amount, date, status, type`,
                                `${uid}, '${rd[0].payment_id}', '${wallet}', '${fulldate.date}T${fulldate.time}', '2', '${insertid.insertId}'`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }
                        }

                        if (await DataInsert(`tbl_transaction_driver`, `d_id, payment_id, amount, date, status, type`,
                            `${rd[0].d_id}, '${insertid.insertId}', '${nwallet_amount}', '${fulldate.date}T${fulldate.time}', '1', ''`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        const chat = await DataFind(`SELECT * FROM tbl_chat
                                                WHERE (sender_id = '${rd[0].c_id}' AND resiver_id = '${rd[0].d_id}') OR (sender_id = '${rd[0].d_id}' AND resiver_id = '${rd[0].c_id}')`);

                        for (let i = 0; i < chat.length;) {
                            const emessage = mysql.escape(chat[i].message);
                            if (await DataInsert(`tbl_chat_save`, `sender_id, resiver_id, date, message`, `'${chat[i].sender_id}', '${chat[i].resiver_id}', '${chat[i].date}', ${emessage}`, req.hostname, req.protocol) == -1) {
                                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                            }
                            i++
                        }

                        if (await DataDelete(`tbl_chat`, `(sender_id = '${rd[0].c_id}' AND resiver_id = '${rd[0].d_id}') OR (sender_id = '${rd[0].d_id}' AND resiver_id = '${rd[0].c_id}')`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        const review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Ride Complete Successful', request_id: insertid.insertId, review_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })

                router.post("/tbl_review", async (req, res) => {
                    try {
                        const { uid, d_id, request_id, def_review, review, tot_star } = req.body;
                        if (!uid || !d_id || !request_id || !tot_star) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const rd = await DataFind(`SELECT * FROM tbl_order_vehicle WHERE id = '${request_id}' AND c_id = '${uid}' AND d_id = '${d_id}'`);
                        if (rd == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

                        const revi = await DataFind(`SELECT * FROM tbl_review_driver WHERE request_id = '${rd[0].id}' AND customer_id = '${uid}' AND driver_id = '${d_id}'`);
                        if (revi != "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Review Found!' });

                        let esreview = mysql.escape(review), fulldate = new Date().toISOString();
                        if (await DataInsert(`tbl_review_driver`, `driver_id, customer_id, request_id, def_review, review, tot_star, date`,
                            `'${d_id}', '${uid}', '${rd[0].id}', '${def_review}', ${esreview}, '${tot_star}', '${fulldate}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }
                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Review Add Successful" });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                });





                async function JsonConvert(idlist) {
                    let d_id_list = []
                    if (idlist) {
                        if (typeof idlist == "string") {
                            d_id_list = JSON.parse(idlist);
                        } else d_id_list = idlist
                    }
                    return { d_id_list }
                }

                async function AllServiceData(status, where, tblname, field, otp) {
                    let data = [];
                    if (status == "1") {
                        data = await DataFind(`SELECT cv.id, cv.d_id, cv.price, cv.status, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long, cv.pic_address,
                                                cv.drop_address, cv.m_role, COALESCE(vd.name, '') AS vehicle_name, COALESCE(pd.name, '') AS p_name
                                                FROM ${tblname} AS cv
                                                JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                                JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                                ${where} ORDER BY id DESC`);
                    } else {
                        let dr = await AllFunction.DriverReview("cv");

                        data = await DataFind(`SELECT cv.id, cv.d_id, cv.price, cv.status, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee,
                                                cv.weather_price, cv.wallet_price, cv.additional_time, cv.tot_hour, cv.tot_minute, cv.coupon_id, cv.status_time_location, cv.pic_lat_long,
                                                cv.drop_lat_long, cv.pic_address, cv.drop_address, cv.m_role, cv.current_run_time, COALESCE(vd.name, '') AS vehicle_name, COALESCE(pd.name, '') AS p_name,
                                                COALESCE(dr.profile_image, "") AS profile_image, COALESCE(dr.vehicle_image, "") AS vehicle_image, COALESCE(dr.first_name, "") AS first_name,
                                                COALESCE(dr.last_name, "") AS last_name, COALESCE(dr.primary_ccode, "") AS primary_ccode, COALESCE(dr.primary_phoneNo, "") AS primary_phoneNo,
                                                COALESCE(dr.language, "") AS language, COALESCE(dr.vehicle_number, "") AS vehicle_number, COALESCE(dr.car_color, "") AS car_color
                                                ${dr.tot_review}, COALESCE(vd.comission_rate, '') AS comission_rate,
                                                COALESCE(vd.comission_type, '') AS comission_type
                                                ${dr.avgstar} ${field} ${otp}, COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude, COALESCE(vd.map_img, '') AS map_img
                                                FROM ${tblname} AS cv
                                                LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                                LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                                LEFT JOIN tbl_driver AS dr ON cv.d_id = dr.id
                                                ${dr.table}
                                                ${where} GROUP BY cv.id, vd.name, pd.name, dr.id ORDER BY id DESC`);
                    }
                    return data
                }

                router.post("/all_service_request", async (req, res) => {
                    try {
                        const { uid, status } = req.body;
                        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE id = '${uid}'`);
                        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer Not Found!' });

                        const general = await DataFind(`SELECT driver_wait_time FROM tbl_general_settings`);
                        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let Reuqest_list = [], totrequest = [];

                        if (status == "upcoming") {
                            let pen_req_request = await AllServiceData(1, `WHERE cv.c_id = '${uid}'`, `tbl_request_vehicle`, 0);

                            let first_list = pen_req_request.map(async (val) => {
                                let idlist = await JsonConvert(val.d_id);
                                val.driver_id_list = idlist ? idlist.d_id_list : []; val.d_id = "0";

                                let otherdata = {
                                    "final_price": 0, "paid_amount": 0, "coupon_amount": 0, "addi_time_price": 0, "platform_fee": 0, "weather_price": 0, "wallet_price": 0,
                                    "additional_time": 0, "coupon_id": "", "current_run_time": "", "profile_image": "", "vehicle_image": "", "first_name": "", "last_name": "", "primary_ccode": "",
                                    "primary_phoneNo": "", "language": "", "vehicle_number": "", "car_color": "", "tot_review": 0, "comission_rate": "", "comission_type": "", "avg_star": 0.0, "otp": "",
                                    "latitude": "", "longitude": "", "map_img": ""
                                }
                                val = { ...val, ...otherdata };
                                return val;
                            });
                            let flist = await Promise.all(first_list);

                            let pen_card_request = await AllServiceData(2, `WHERE cv.c_id = '${uid}'`, `tbl_cart_vehicle`, ', cv.driver_id_list', ', cv.otp');

                            let secound_list = pen_card_request.map(async (val) => {
                                let idlist = await JsonConvert(val.driver_id_list);
                                val.driver_id_list = idlist ? idlist.d_id_list : [];
                                return val;
                            })
                            let slist = await Promise.all(secound_list);

                            totrequest = flist.concat(slist);

                        } else if (status == "completed") totrequest = await AllServiceData(2, `WHERE cv.c_id = '${uid}' AND cv.status = '8'`, `tbl_order_vehicle`, '', '');
                        else if (status == "cancelled") totrequest = await AllServiceData(2, `WHERE cv.c_id = '${uid}' AND cv.status = '4'`, `tbl_order_vehicle`, '', '');

                        if (status == "completed" || status == "cancelled") {
                            let com_list = totrequest.map(async (val) => {
                                val.driver_id_list = []; val.otp = "";
                                return val
                            })
                            let slist = await Promise.all(com_list);
                            totrequest = slist
                        }

                        if (totrequest != "") {
                            Reuqest_list = await AllFunction.AllVehicleFormate(totrequest, 1);

                            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', driver_wait_time: parseFloat(general[0].driver_wait_time), Reuqest_list: Reuqest_list });
                        } else {
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', driver_wait_time: parseFloat(general[0].driver_wait_time), Reuqest_list: [] });
                        }
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                });





                router.post("/all_ride_detail", async (req, res) => {
                    try {
                        const { uid, request_id, status } = req.body;
                        if (!uid || !request_id || !status) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
                        let Reuqest_list = [], review_check = 0;

                        if (status == "complete") {

                            let mapdata = await DataFind(`SELECT cv.id, cv.c_id, cv.d_id, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee, cv.weather_price,
                                                        cv.wallet_price, cv.additional_time, cv.status, cv.tot_km, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long,
                                                        cv.pic_address, cv.drop_address, cv.m_role, cv.coupon_id, COALESCE(vd.name, '') AS vehicle_name, COALESCE(vd.comission_rate, '') AS comission_rate,
                                                        COALESCE(vd.comission_type, '') AS comission_type, COALESCE(dr.profile_image, '') AS profile_image,
                                                        COALESCE(pd.image, '') AS p_image, COALESCE(pd.name, '') AS p_name,
                                                        CASE WHEN COUNT(revi.id) > 0 THEN '1' ELSE '0' END AS review_check
                                                        FROM tbl_order_vehicle AS cv
                                                        LEFT JOIN tbl_driver AS dr ON cv.d_id = dr.id
                                                        LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                                        LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                                        LEFT JOIN tbl_review_driver AS revi ON cv.d_id = revi.driver_id AND cv.c_id = revi.customer_id AND cv.id = revi.request_id
                                                        WHERE cv.id = '${request_id}' AND cv.c_id = '${uid}' AND cv.status NOT IN ('4')
                                                        GROUP BY cv.id ORDER BY cv.id DESC;`);

                            if (mapdata != "") {
                                const review = await DataFind(`SELECT * FROM tbl_review_driver WHERE request_id = '${mapdata[0].id}' AND driver_id = '${mapdata[0].d_id}' AND
                                                                customer_id = '${mapdata[0].c_id}'`);
                                if (review != "") review_check = 1;
                                mapdata[0].c_title = ""; mapdata[0].addi_time = parseFloat(mapdata[0].additional_time);

                                mapdata[0].price = parseFloat(mapdata[0].price); mapdata[0].tot_km = parseFloat(mapdata[0].tot_km); mapdata[0].review_check = review_check; mapdata[0].review_check = review_check;
                                Reuqest_list = await AllFunction.AllVehicleFormate(mapdata, 2);

                                delete Reuqest_list[0].tot_drop; delete Reuqest_list[0].comission_rate; delete Reuqest_list[0].comission_type; delete Reuqest_list[0].additional_time;
                                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', Reuqest_list: Reuqest_list[0] });
                            } else {
                                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
                            }
                        }

                        if (status == "cancel") {
                            let mapdata = await DataFind(`SELECT cv.id, cv.c_id, cv.d_id, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee, cv.weather_price,
                                                cv.wallet_price, cv.additional_time, cv.status, cv.tot_km, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long, cv.pic_address,
                                                cv.drop_address, cv.m_role, cv.coupon_id, COALESCE(vd.name, '') AS vehicle_name, COALESCE(vd.comission_rate, '') AS comission_rate,
                                                COALESCE(vd.comission_type, '') AS comission_type, COALESCE(pd.image, '') AS p_image, COALESCE(pd.name, '') AS p_name,
                                                COALESCE(rcr.title, '') AS c_title, CASE WHEN COUNT(revi.id) > 0 THEN '1' ELSE '0' END AS review_check
                                                FROM tbl_order_vehicle AS cv
                                                LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                                LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                                LEFT JOIN tbl_ride_cancel_reason AS rcr ON cv.cancel_reason = rcr.id
                                                LEFT JOIN tbl_review_driver AS revi ON cv.d_id = revi.driver_id AND cv.c_id = revi.customer_id AND cv.id = revi.request_id
                                                WHERE cv.id = '${request_id}' AND cv.c_id = '${uid}' AND cv.status IN ('4') GROUP BY cv.id ORDER BY id DESC`);

                            if (mapdata != "") {
                                mapdata[0].price = parseFloat(mapdata[0].price); mapdata[0].tot_km = parseFloat(mapdata[0].tot_km); mapdata[0].addi_time = parseFloat(mapdata[0].additional_time);

                                mapdata[0].review_check = review_check;
                                Reuqest_list = await AllFunction.AllVehicleFormate(mapdata, 2);

                                delete Reuqest_list[0].tot_drop; delete Reuqest_list[0].comission_rate; delete Reuqest_list[0].comission_type; delete Reuqest_list[0].additional_time;
                                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', Reuqest_list: Reuqest_list[0] });
                            } else {
                                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
                            }
                        }
                        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                });








                router.get("/coupon_payment", async (req, res) => {
                    try {
                        let fulldate = await AllFunction.TodatDate();
                        let coupon_list = await DataFind(`SELECT * FROM tbl_coupon WHERE start_date <= '${fulldate.date}' AND end_date >= '${fulldate.date}'`);
                        coupon_list.map(cval => {
                            let st = new Date(cval.start_date).toISOString().split("T")
                            cval.start_date = `${st[0]} ${st[1]}`

                            let en = new Date(cval.end_date).toISOString().split("T")
                            cval.end_date = `${en[0]} ${en[1]}`
                        })

                        let payment_list = await DataFind(`SELECT * FROM tbl_payment_detail`);

                        let spldata = payment_list[10].attribute.split(",")
                        let bank_data = [{ bank_name: spldata[0] }, { holder_name: spldata[1] }, { account_no: spldata[2] }, { iafc_code: spldata[3] }, { swift_code: spldata[4] }]

                        const general = await DataFind(`SELECT default_payment FROM tbl_general_settings`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", default_payment: general[0].default_payment, coupon_list, payment_list, bank_data });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/all_data", async (req, res) => {
                    try {
                        const { mrole } = req.body;

                        if (mrole == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let module_data = []
                        if (mrole == "2") module_data = await DataFind(`SELECT * FROM tbl_outstation WHERE status = 1`);

                        if (mrole == "3") module_data = await DataFind(`SELECT * FROM tbl_rental WHERE status = 1`);

                        if (mrole == "4") module_data = await DataFind(`SELECT * FROM tbl_package`);

                        if (module_data != "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", module_data });
                        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "Data not find", module_data });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/module_data", async (req, res) => {
                    try {
                        const { mid, mrole } = req.body;

                        if (mid == "" || mrole == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let module_data = []
                        if (mrole == "2") module_data = await DataFind(`SELECT * FROM tbl_outstation WHERE status = 1 AND id = '${mid}'`);

                        if (mrole == "3") module_data = await DataFind(`SELECT * FROM tbl_rental WHERE status = 1 AND id = '${mid}'`);

                        if (mrole == "4") module_data = await DataFind(`SELECT * FROM tbl_package`);

                        if (module_data != "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", module_data });
                        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "Data not find", module_data });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/add_wallet", async (req, res) => {
                    try {
                        const { uid, payment_id, amount } = req.body;

                        const missingField = await AllFunction.CheckBodyData(req, ["uid", "payment_id", "amount"]);
                        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        let customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
                        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer not found!' });

                        let fulldate = await AllFunction.TodatDate();

                        if (await DataInsert(`tbl_transaction_customer`, `c_id, payment_id, amount, date, status, type`,
                            `${uid}, '${payment_id}', '${amount}', '${fulldate.date}T${fulldate.time}', '1', ''`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        let cdata = customer[0].wallet, wamount = 0
                        if (cdata || cdata != "0" || cdata != "NaN") wamount = cdata;

                        let wallet_amount = parseFloat(wamount) + parseFloat(amount)

                        if (await DataUpdate(`tbl_customer`, ` wallet = '${wallet_amount}'`, `id = '${uid}'`, req.hostname, req.protocol) == -1) {
                            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                        }

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful" });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/wallet", async (req, res) => {
                    try {
                        const { uid } = req.body;
                        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
                        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer not found!' });

                        let wallet_data = await DataFind(`SELECT dt.*, COALESCE(pd.name, '') AS pname
                                                        FROM tbl_transaction_customer AS dt
                                                        LEFT JOIN tbl_payment_detail AS pd ON dt.payment_id = pd.id
                                                        WHERE dt.c_id = '${uid}' AND wallet_status = '1'`);

                        let wdata = wallet_data.map(async (wval) => {
                            const date = new Date(wval.date);
                            const formattedDate = date.toLocaleString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone });
                            wval.date = formattedDate;
                            if (wval.payment_id == "0") wval.pname = "Referred"
                            return wval;
                        });
                        let fulldata = await Promise.all(wdata);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", wallet_amount: customer[0].wallet, wallet_data: fulldata });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.get("/faq_data", async (req, res) => {
                    try {
                        const faq_list = await DataFind(`SELECT * FROM tbl_list_faq`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", faq_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.get("/pages_data", async (req, res) => {
                    try {
                        const pages_list = await DataFind(`SELECT * FROM tbl_list_pages`);

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", pages_list });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/refer_and_earn", async (req, res) => {
                    try {
                        const { uid } = req.body;
                        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const customer = await DataFind(`SELECT id, referral_code FROM tbl_customer WHERE id = '${uid}'`);
                        const general = await DataFind(`SELECT refer_credit, signup_credit FROM tbl_general_settings`);

                        if (customer != "" || general != "") {
                            let refer_data = { referral_code: customer[0].referral_code, refer_credit: general[0].refer_credit, signup_credit: general[0].signup_credit }
                            return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", refer_data });
                        } else return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Not Found!", refer_data: { referral_code: "", refer_credit: "", signup_credit: "" } });

                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/notification", async (req, res) => {
                    try {
                        const { uid } = req.body;
                        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

                        const ndata = await DataFind(`SELECT noti.id, noti.image, noti.title, noti.description, noti.date
                                                        FROM tbl_send_notification AS noti
                                                        LEFT JOIN tbl_customer AS cus ON noti.customer = cus.id
                                                        WHERE noti.customer = 'All' OR cus.id = '${uid}' ORDER BY noti.id DESC`);

                        ndata.map(val => {
                            const date = new Date(val.date);
                            const formattedDate = date.toLocaleString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone });
                            val.date = formattedDate;
                            return val;
                        });

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Not Found!", ndata });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })



                router.post("/account_deactive", async (req, res) => {
                    try {
                        const { id } = req.body;

                        const driver_list = await DataFind(`SELECT id FROM tbl_customer WHERE id = '${id}'`);
                        if (driver_list == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'ID Not Found!' });

                        if (await DataUpdate(`tbl_customer`, `status = '0'`, `id = '${id}'`, req.hostname, req.protocol) == -1) {

                            req.flash('errors', process.env.dataerror);
                            return res.redirect("/valid_license");
                        }

                        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Account Deactivate Successful" });
                    } catch (error) {
                        console.error(error);
                        res.status(500).json({ error: 'Internal server error' });
                    }
                })






                module.exports = router;
]
[
            /* jshint esversion: 6 */
        /* jshint esversion: 8 */
        /* jshint node: true */



        const geolib = require('geolib');
        const axios = require('axios');
        const sendOneNotification = require("../middleware/send");
        const AllChat = require("../route_function/chat_function");
        const { DataFind, DataInsert, DataUpdate, DataDelete } = require("../middleware/databse_query");




        async function otpGenerate(len) {
            let otp_result = '';
            let char = '0123456789';
            let charlen = char.length;
            for (let i = 0; i < len; i++) {
                otp_result += char.charAt(Math.floor(Math.random() * charlen));
            }
            return otp_result;
        }




        async function DriverUpdate(documant_list, driverdata, id, hostname, protocol) {
            let fcount = 0, scount = 0
            for (let d = 0; d < documant_list.length;) {
                fcount++
                for (let e = 0; e < driverdata.length;) {

                    if (documant_list[d].id == driverdata[e].document_id) {
                        if (driverdata[e].status == "1") scount++
                    }
                    e++
                }
                d++
            }

            const gsetting = await DataFind(`SELECT def_driver FROM tbl_general_settings`);
            if (gsetting[0].def_driver == "1") {

                const driverdoc = await DataFind(`SELECT * FROM tbl_document_setting`);
                if (driverdoc.length == driverdata.length) {

                    if (await DataUpdate(`tbl_driver`, ` approval_status = '1'`, `id = '${id}'`, hostname, protocol) == -1) {
                        return -1
                    }

                    for (let i = 0; i < driverdata.length;) {
                        if (await DataUpdate(`tbl_driver_document`, `status = '1'`, `id = '${driverdata[i].id}'`, hostname, protocol) == -1) {
                            return -1
                        }
                        i++
                    }
                }
            } else {
                if (fcount == scount) {
                    if (await DataUpdate(`tbl_driver`, ` approval_status = '1'`, `id = '${id}'`, hostname, protocol) == -1) {
                        return -1
                    }
                } else {
                    if (await DataUpdate(`tbl_driver`, ` approval_status = '0'`, `id = '${id}'`, hostname, protocol) == -1) {
                        return -1
                    }
                }
            }

            return 1
        }

        async function ZoneLatlon(pickup_lat_lon, drop_lat_lon, lat_lon_list) {
            let totalzone = []
            let splpi = pickup_lat_lon.split(",")
            totalzone.push({ latitude: Number(splpi[0]), longitude: Number(splpi[1]) });

            let spldrop = drop_lat_lon.split(",")
            totalzone.push({ latitude: Number(spldrop[0]), longitude: Number(spldrop[1]) });

            if (lat_lon_list && lat_lon_list.length > 0) {
                for (let i = 0; i < lat_lon_list.length; i++) {
                    // Handle both string format "lat,lon" and object format {lat: x, long: y}
                    if (typeof lat_lon_list[i] === 'string') {
                        let coords = lat_lon_list[i].split(",");
                        totalzone.push({
                            latitude: Number(coords[0]),
                            longitude: Number(coords[1])
                        });
                    } else if (lat_lon_list[i].lat !== undefined && lat_lon_list[i].long !== undefined) {
                        totalzone.push({
                            latitude: Number(lat_lon_list[i].lat),
                            longitude: Number(lat_lon_list[i].long)
                        });
                    }
                }
            }
            return totalzone
        }




        // Replace the existing ZoneData function
        async function ZoneData() {
            const zone_data = await DataFind(`SELECT * FROM tbl_zone`);
            let all_zone = []

            for (let i = 0; i < zone_data.length; i++) {
                // Check if lat_lon exists and is not empty
                if (!zone_data[i].lat_lon || zone_data[i].lat_lon.trim() === '') {
                    console.log(`Warning: Zone ${zone_data[i].id} has empty lat_lon data`);
                    continue;
                }

                let aplz = zone_data[i].lat_lon.split(',');
                let all_lat = [];

                for (let a = 0; a < aplz.length; a++) {
                    // Check if the coordinate pair exists and contains ':'
                    if (!aplz[a] || !aplz[a].includes(':')) {
                        console.log(`Warning: Invalid coordinate format in zone ${zone_data[i].id}: ${aplz[a]}`);
                        continue;
                    }

                    let coords = aplz[a].split(':');
                    if (coords.length !== 2) {
                        console.log(`Warning: Invalid coordinate pair in zone ${zone_data[i].id}: ${aplz[a]}`);
                        continue;
                    }

                    let latitude = parseFloat(coords[0]);
                    let longitude = parseFloat(coords[1]);

                    // Validate coordinates
                    if (isNaN(latitude) || isNaN(longitude)) {
                        console.log(`Warning: Invalid coordinates in zone ${zone_data[i].id}: ${coords[0]}, ${coords[1]}`);
                        continue;
                    }

                    all_lat.push({ latitude, longitude });
                }

                // Only add zones with at least 3 points (minimum for polygon)
                if (all_lat.length >= 3) {
                    all_zone.push(all_lat);
                } else {
                    console.log(`Warning: Zone ${zone_data[i].id} has insufficient points for polygon (${all_lat.length} points)`);
                }
            }

            return { all_zone, zone_data }
        }

        // Replace the existing CheckZone function
        async function CheckZone(convertzone, zone, zalldata) {
            const zone_data = zalldata;
            let all_zone = zone, zoneresult = [], zid = [], uzone = 0;

            // Validate input data
            if (!convertzone || !Array.isArray(convertzone) || convertzone.length === 0) {
                console.log('Error: Invalid convertzone data');
                return [{ zr: [] }, { zc: convertzone ? convertzone.length : 0 }, { zid: [] }];
            }

            if (!all_zone || !Array.isArray(all_zone) || all_zone.length === 0) {
                console.log('Warning: No zones available for checking');
                // Return all points as outside zones
                for (let a = 0; a < convertzone.length; a++) {
                    zoneresult.push({ zone: a + 1, status: 0 });
                }
                return [{ zr: zoneresult }, { zc: convertzone.length }, { zid: [] }];
            }

            for (let a = 0; a < convertzone.length; a++) {
                let tcount = 0, ucheck = 0;

                // Validate coordinate point
                if (!convertzone[a] ||
                    typeof convertzone[a].latitude !== 'number' ||
                    typeof convertzone[a].longitude !== 'number' ||
                    isNaN(convertzone[a].latitude) ||
                    isNaN(convertzone[a].longitude)) {
                    console.log(`Warning: Invalid coordinate at index ${a}:`, convertzone[a]);
                    zoneresult.push({ zone: a + 1, status: 0 });
                    uzone++;
                    continue;
                }

                for (let b = 0; b < all_zone.length; b++) {
                    // Validate zone polygon
                    if (!all_zone[b] || !Array.isArray(all_zone[b]) || all_zone[b].length < 3) {
                        console.log(`Warning: Invalid zone polygon at index ${b}:`, all_zone[b]);
                        ucheck++;
                        continue;
                    }

                    // Validate all points in the polygon
                    let validPolygon = true;
                    for (let point of all_zone[b]) {
                        if (!point ||
                            typeof point.latitude !== 'number' ||
                            typeof point.longitude !== 'number' ||
                            isNaN(point.latitude) ||
                            isNaN(point.longitude)) {
                            validPolygon = false;
                            break;
                        }
                    }

                    if (!validPolygon) {
                        console.log(`Warning: Invalid polygon points in zone ${b}`);
                        ucheck++;
                        continue;
                    }

                    try {
                        let count = geolib.isPointInPolygon(convertzone[a], all_zone[b]);

                        if (count === true) {
                            tcount++;
                            if (zone_data[b] && zone_data[b].id && !zid.includes(zone_data[b].id)) {
                                zid.push(zone_data[b].id);
                            }
                        } else {
                            ucheck++;
                        }
                    } catch (error) {
                        console.log(`Error checking point in polygon: ${error.message}`);
                        console.log('Point:', convertzone[a]);
                        console.log('Polygon:', all_zone[b]);
                        ucheck++;
                    }
                }

                if (tcount == 0) uzone++;
                zoneresult.push({ zone: a + 1, status: tcount > 0 ? 1 : 0 });
            }

            let zdata = [{ zr: zoneresult }, { zc: uzone }, { zid: zid }];
            return zdata;
        }



        async function RadiusCheck(point, otherlatlon, radius) {
            let isWithinRadius = geolib.isPointWithinRadius(
                otherlatlon, point, radius
            );
            if (isWithinRadius === true) return 1
            else return 0
        }



        // üáæüá™ Enhanced GetDistance function for Yemen with fallback calculation
        async function GetDistance(pickup, drop, google_map_key) {
            console.log(`üó∫Ô∏è GetDistance called for Yemen coordinates:`);
            console.log(`   Pickup: ${pickup}`);
            console.log(`   Drop: ${drop}`);
            console.log(`   API Key exists: ${!!google_map_key}`);

            const apiKey = google_map_key;
            const origin = pickup;
            const destination = drop;

            // Try Google Maps API first
            if (apiKey && apiKey.length > 10) {
                try {
                    const url = `https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins=${origin}&destinations=${destination}&key=${apiKey}&region=ye&language=ar`;

                    console.log(`üåê Trying Google Maps API for Yemen...`);

                    const response = await axios.get(url, { timeout: 10000 }); // 10 second timeout
                    const data = response.data;

                    console.log(`üì° Google Maps Response Status: ${data.status}`);

                    if (data.status === 'OK' && data.rows && data.rows.length > 0) {
                        const element = data.rows[0].elements[0];

                        if (element.status === 'OK') {
                            const distance = element.distance.text;
                            const duration = element.duration.text;

                            console.log(`‚úÖ Google Maps Success: ${distance}, ${duration}`);

                            let dspl = distance.split(" ");
                            let kmcal = 0;

                            if (dspl[1] && dspl[1].match(/km/i)) {
                                kmcal = parseFloat(dspl[0]);
                            } else {
                                kmcal = (parseFloat(dspl[0]) / 1000);
                            }

                            return { status: 1, dis: parseFloat(kmcal.toFixed(2)), dur: duration };
                        } else {
                            console.log(`‚ö†Ô∏è Google Maps element error: ${element.status}`);
                        }
                    } else {
                        console.log(`‚ö†Ô∏è Google Maps API error: ${data.status}`);
                        if (data.error_message) {
                            console.log(`   Error: ${data.error_message}`);
                        }
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Google Maps API failed: ${error.message}`);
                }
            }

            // üáæüá™ FALLBACK: Yemen-specific distance calculation
            console.log(`üîÑ Using Yemen fallback calculation...`);

            const [pickup_coords, drop_coords] = [pickup.split(','), drop.split(',')];
            const lat1 = parseFloat(pickup_coords[0]);
            const lon1 = parseFloat(pickup_coords[1]);
            const lat2 = parseFloat(drop_coords[0]);
            const lon2 = parseFloat(drop_coords[1]);

            // Validate coordinates are in Yemen range
            if (lat1 < 12 || lat1 > 19 || lon1 < 42 || lon1 > 54 ||
                lat2 < 12 || lat2 > 19 || lon2 < 42 || lon2 > 54) {
                console.log(`‚ùå Coordinates outside Yemen range`);
                return { status: 0, dis: 0, dur: "0 min" };
            }

            // Haversine formula for accurate distance
            function calculateYemenDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth's radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Calculate straight-line distance
            const straightDistance = calculateYemenDistance(lat1, lon1, lat2, lon2);

            // üáæüá™ Yemen road network factor (roads are not always direct)
            // Urban areas: 1.3x, Rural/mountainous: 1.8x
            let roadFactor = 1.3; // Default for urban

            // Adjust for different Yemen regions
            if (isInSanaaRegion(lat1, lon1) && isInSanaaRegion(lat2, lon2)) {
                roadFactor = 1.25; // Better roads in Sanaa
            } else if (isInAdenRegion(lat1, lon1) && isInAdenRegion(lat2, lon2)) {
                roadFactor = 1.3; // Coastal roads
            } else if (isInIbbRegion(lat1, lon1) && isInIbbRegion(lat2, lon2)) {
                roadFactor = 1.4; // Mountainous terrain
            } else if (isInTaizRegion(lat1, lon1) && isInTaizRegion(lat2, lon2)) {
                roadFactor = 1.5; // Mountain city
            } else {
                roadFactor = 1.8; // Inter-city or rural
            }

            const roadDistance = straightDistance * roadFactor;

            // Calculate estimated time based on Yemen road conditions
            // Urban: 25 km/h, Rural: 40 km/h, Highway: 60 km/h
            let avgSpeed = 30; // km/h default

            if (roadDistance < 5) {
                avgSpeed = 25; // Urban traffic
            } else if (roadDistance < 20) {
                avgSpeed = 35; // City to suburb
            } else {
                avgSpeed = 45; // Inter-city
            }

            const timeInHours = roadDistance / avgSpeed;
            const timeInMinutes = Math.round(timeInHours * 60);

            // Format duration
            let duration;
            if (timeInMinutes < 60) {
                duration = `${timeInMinutes} mins`;
            } else {
                const hours = Math.floor(timeInMinutes / 60);
                const mins = timeInMinutes % 60;
                duration = `${hours} hour${hours > 1 ? 's' : ''} ${mins} mins`;
            }

            console.log(`üáæüá™ Yemen Calculation Results:`);
            console.log(`   Straight distance: ${straightDistance.toFixed(2)} km`);
            console.log(`   Road factor: ${roadFactor}x`);
            console.log(`   Road distance: ${roadDistance.toFixed(2)} km`);
            console.log(`   Estimated time: ${duration}`);

            return {
                status: 1,
                dis: parseFloat(roadDistance.toFixed(2)),
                dur: duration
            };
        }

        // üáæüá™ Yemen region detection functions
        function isInSanaaRegion(lat, lon) {
            // Sanaa region: 15.2¬∞ - 15.5¬∞N, 44.1¬∞ - 44.3¬∞E
            return lat >= 15.2 && lat <= 15.5 && lon >= 44.1 && lon <= 44.3;
        }

        function isInAdenRegion(lat, lon) {
            // Aden region: 12.7¬∞ - 13.0¬∞N, 44.9¬∞ - 45.1¬∞E
            return lat >= 12.7 && lat <= 13.0 && lon >= 44.9 && lon <= 45.1;
        }

        function isInIbbRegion(lat, lon) {
            // Ibb region: 13.9¬∞ - 14.0¬∞N, 44.1¬∞ - 44.2¬∞E
            return lat >= 13.9 && lat <= 14.0 && lon >= 44.1 && lon <= 44.2;
        }

        function isInTaizRegion(lat, lon) {
            // Taiz region: 13.5¬∞ - 13.7¬∞N, 43.9¬∞ - 44.1¬∞E
            return lat >= 13.5 && lat <= 13.7 && lon >= 43.9 && lon <= 44.1;
        }




        async function AddDateMinute(minute) {
            let currentTime = new Date();
            currentTime.setMinutes(currentTime.getMinutes() + minute);

            let hours = currentTime.getHours(), minutes = currentTime.getMinutes();
            let ampm = hours >= 12 ? 'PM' : 'AM';

            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;

            let formattedTime = hours + ':' + minutes + ' ' + ampm;
            return formattedTime
        }


        async function ConvertDateFormat(time) {
            const date = new Date(time);
            const options = { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };
            const formattedDate = date.toLocaleString('en-US', options);

            const dateParts = formattedDate.split(", ");
            const timePart = dateParts[1].trim();
            const [monthDay, ndate] = dateParts[0].split(" ");

            const finalOutput = `${ndate} ${monthDay}, ${timePart}`;
            return finalOutput
        }



        async function ConvertFullDateFormat(time) {
            const date = new Date(time);
            const options = { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };
            const formattedDate = date.toLocaleString('en-US', options);
            const d = formattedDate.split(", ");
            let fd = d[0].split(" ");
            const finalOutput = `${fd[1]} ${fd[0]} ${d[1]}, ${d[2]}`;
            return finalOutput
        }




        async function TodatDate(ndate) {
            let date
            if (ndate) date = new Date(ndate).toISOString().split("T");
            else date = new Date().toISOString().split("T");
            return { date: date[0], time: date[1] }
        }




        async function convertSeconds(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;

            return { hours: hours, minutes: minutes, seconds: remainingSeconds };
        }

        async function FirstTime(hour, minute, secound, nhour, nminute, nsecond) {
            let totalSeconds = hour * 3600 + minute * 60 + secound;
            let nTotalSeconds = nhour * 3600 + nminute * 60 + nsecond;
            let newTotalSeconds = totalSeconds - nTotalSeconds;

            let newHour = Math.floor(newTotalSeconds / 3600);
            newTotalSeconds %= 3600;
            let newMinute = Math.floor(newTotalSeconds / 60);
            let newSecond = newTotalSeconds % 60;

            return { newHour, newMinute, newSecond }
        }

        async function SecoundTime(ntime, oldtime) {
            let currentTime = new Date(ntime);
            let OldTime = new Date(oldtime);

            let timeDifference = currentTime - OldTime;

            let differenceInSeconds = Math.floor(timeDifference / 1000);
            let differenceInMinutes = Math.floor(differenceInSeconds / 60);

            let hour = Math.floor(differenceInMinutes / 60);
            let minute = differenceInMinutes % 60;
            let second = differenceInSeconds % 60;

            return { hour, minute, second }
        }

        async function TwoTimeDifference(data, status) {
            let OldTime = new Date(data);
            if (status == "1") OldTime.setHours(OldTime.getHours() + 1);

            let currentTime = new Date();

            let timeDifference = currentTime - OldTime;
            let differenceInSeconds = Math.floor(timeDifference / 1000);
            let differenceInMinutes = Math.floor(differenceInSeconds / 60);

            let hour = Math.floor(differenceInMinutes / 60);
            let minute = differenceInMinutes % 60;
            let second = differenceInSeconds % 60;

            return { hour, minute, second }
        }

        async function CurrentDatetoOldDateS(ndate, deff_sec) {

            let currunt = new Date(ndate), old = new Date();
            old.setSeconds(old.getSeconds() - parseFloat(deff_sec));

            let newtime = await AllFunction.SecoundTime(currunt, old);

            let toth = parseFloat(newtime.hour) * 60 * 60;
            let totm = parseFloat(newtime.minute) * 60;
            let tots = parseFloat(toth) + parseFloat(totm) + parseFloat(newtime.second);
            return tots
        }

        async function TimeDistance(rdata) {
            let spltime = "", run_time = { hour: 0, minute: 0, second: 0, status: 0 }
            const general = await DataFind(`SELECT driver_wait_time FROM tbl_general_settings`);

            if (rdata.current_run_time && rdata.current_run_time != "") {
                spltime = rdata.current_run_time.split("&")

                let ctime = await TwoTimeDifference(spltime[0], 2);

                if (ctime.hour != "NaN" && ctime.minute != "NaN" && ctime.second != "NaN") {

                    if (rdata.status == "1" || rdata.status == "5") {

                        let newtime = await FirstTime(rdata.tot_hour, rdata.tot_minute, 0, ctime.hour, ctime.minute, ctime.second);

                        if (newtime.newHour > -1 && newtime.newMinute > -1 && newtime.newSecond > -1) {
                            run_time.hour = newtime.newHour; run_time.minute = newtime.newMinute; run_time.second = newtime.newSecond; run_time.status = 1;
                        }

                    } else if (rdata.status == "2") {

                        if (general[0].driver_wait_time != "0" || general[0].driver_wait_time) {
                            let ntime = new Date();
                            ntime.setMinutes(ntime.getMinutes() - parseFloat(general[0].driver_wait_time));

                            let sectime = await SecoundTime(spltime[0], ntime);

                            if (sectime.hour > -1 && sectime.minute > -1 && sectime.second > -1) {

                                run_time.hour = sectime.hour; run_time.minute = sectime.minute; run_time.second = sectime.second; run_time.status = 1;
                            } else {
                                let newtime = await FirstTime(ctime.hour, ctime.minute, ctime.second, 0, parseFloat(general[0].driver_wait_time), 0);

                                if (newtime.newHour > -1 && newtime.newMinute > -1 && newtime.newSecond > -1) {
                                    run_time.hour = newtime.newHour; run_time.minute = newtime.newMinute; run_time.second = newtime.newSecond;
                                }
                            }
                        }

                    } else {
                        run_time.hour = ctime.hour; run_time.minute = ctime.minute; run_time.second = ctime.second; run_time.status = 0;
                    }
                }

            } else if (rdata.status == "3") {

                let sta = rdata.status_time_location.split("&!!");
                let f = sta[1].split("&"), s = sta[2].split("&");
                let sectime = await SecoundTime(s[1], f[1]);

                let a = parseFloat(sectime.hour);
                let hourm = a * 60 * 60;
                let = await CalculateMinuteToHour(sectime.second);

                let totm = parseFloat(hourm) + parseFloat(sectime.minute) * parseFloat(60) + parseFloat(sectime.second);

                let nextmin = 0, st = 0, driwait = parseFloat(general[0].driver_wait_time) * parseFloat(60);
                if (driwait >= totm) {
                    nextmin = parseFloat(driwait) - parseFloat(totm); st = 2;
                } else {
                    nextmin = parseFloat(totm) - parseFloat(driwait); st = 3;
                }
                const result = await convertSeconds(nextmin);
                run_time.hour = result.hours; run_time.minute = result.minutes; run_time.second = result.seconds; run_time.status = st;
            }
            return run_time;
        }




        async function DriverRequestData(rdata) {
            let request_data = []
            const general = await DataFind(`SELECT dri_offer_increment, offer_expire_time, offer_time FROM tbl_general_settings`);
            for (let i = 0; i < rdata.length;) {
                let piclatlon, drolatlon = [], picadd, dropadd = [], run_time = { hour: 0, minute: 0, second: 0, status: 0 }, timecal = 0, status = 0

                let plos = rdata[i].pic_lat_long.split("&!"), pads = rdata[i].pic_address.split("&!")
                piclatlon = { latitude: plos[0], longitude: plos[1] }; picadd = { title: pads[0], subtitle: pads[1] }

                let platlon = rdata[i].drop_lat_long.split("&!!"), dradd = rdata[i].drop_address.split("&!!")
                for (let a = 0; a < platlon.length;) {

                    let lspl = platlon[a].split("&!"), addspl = dradd[a].split("&!")

                    if (parseFloat(rdata[i].status) > 4) {
                        if (parseFloat(rdata[i].drop_complete) <= a) drolatlon.push({ latitude: lspl[0], longitude: lspl[1] });
                    } else {
                        drolatlon.push({ latitude: lspl[0], longitude: lspl[1] });
                    }
                    dropadd.push({ title: addspl[0], subtitle: addspl[1] });
                    a++;
                }

                let per_km_price = "0";
                if (parseFloat(rdata[i].price) != 0 && parseFloat(rdata[i].tot_km) != 0) per_km_price = (parseFloat(rdata[i].price) / parseFloat(rdata[i].tot_km)).toFixed(2);

                if (rdata[i].current_run_time && rdata[i].current_run_time != "") run_time = await TimeDistance(rdata[i]);

                status = run_time.status;
                if (run_time.hour != 0 && run_time.minute != 0 && run_time.second != 0) {

                    timecal = (parseFloat(run_time.hour) * 3600) + (parseFloat(run_time.minute) * 60) + parseFloat(run_time.second);

                } else if (run_time.hour == 0 && run_time.minute != 0 && run_time.second != 0) {

                    timecal = (run_time.minute * 60) + run_time.second;

                } else if (run_time.hour == 0 && run_time.minute == 0 && run_time.second != 0) {

                    timecal = run_time.second;

                } else if (run_time.hour == 0 && run_time.minute == 0 && run_time.second == 0) {

                    timecal = 0;

                } else timecal = 0;

                let timed = { run_time: timecal ? timecal : 0, status: status };

                let df = parseFloat(general[0].dri_offer_increment), dprice = [];
                if (rdata[i].bidding_status == "1") {
                    for (let b = 1; b < df + 1;) {
                        let dp = parseFloat(rdata[i].price) + b
                        dprice.push(dp);
                        b++;
                    }
                }

                request_data.push({
                    id: rdata[i].id, c_id: rdata[i].c_id, name: rdata[i].name, country_code: rdata[i].country_code, phone: rdata[i].phone, rating: parseFloat(rdata[i].avg_star),
                    review: rdata[i].tot_review, price: parseFloat(rdata[i].price), per_km_price, tot_km: rdata[i].tot_km, tot_hour: rdata[i].tot_hour, tot_minute: rdata[i].tot_minute, status: rdata[i].status,
                    bidding_status: rdata[i].bidding_status, bidd_auto_status: rdata[i].bidd_auto_status, ride_expire_time: parseFloat(general[0].offer_expire_time), bidd_ex_time: parseFloat(general[0].offer_time),
                    dri_offer_limite: dprice, running_time: timed, pick_latlon: piclatlon, drop_latlon: drolatlon, pick_add: picadd, drop_add: dropadd
                });

                i++
            }
            return request_data
        }

        async function CheckBodyData(req, Data) {
            const missingField = Data.find(field => !req.body[field] || req.body[field] === null || req.body[field] === "null" || req.body[field] === undefined || req.body[field] === "undefined");
            return missingField
        }


        async function CheckSocketData(data, Data) {
            const missingField = Data.find(field => !data[field] || data[field] === null || data[field] === "null" || data[field] === undefined || data[field] === "undefined");
            return missingField
        }




        async function SendDriverLatLong(uid) {
            let data = await DataFind(`SELECT c_id FROM tbl_cart_vehicle WHERE d_id = '${uid}'`), driver = [];

            if (data != "") {
                driver = await DataFind(`SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                        COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                        FROM tbl_driver AS dr
                                        JOIN tbl_vehicle AS ve ON dr.vehicle = ve.id AND ve.id = dr.vehicle
                                        WHERE dr.id = '${uid}' AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')`);

                if (driver != "") return { driver, data };
            } else return { driver: [], data: [] }
        }




        async function CheckCurrentLocation(pending_ride, dlatlon, daddress) {
            let current_address = { title: "", subtitle: "", latitude: "", longitude: "" }, next_address = { title: "", subtitle: "", latitude: "", longitude: "" }, custatus = 0, nstatus = 0;

            if (dlatlon[pending_ride]) {
                let add = daddress[pending_ride].split("&!"), latlon = dlatlon[pending_ride].split("&!");
                current_address = { title: add[0], subtitle: add[1], latitude: latlon[0], longitude: latlon[1] };

                custatus = 1;
            }

            if (dlatlon[pending_ride + 1]) {
                let nadd = daddress[pending_ride + 1].split("&!"), nlatlon = dlatlon[pending_ride + 1].split("&!");
                next_address = { title: nadd[0], subtitle: nadd[1], latitude: nlatlon[0], longitude: nlatlon[1] };

                nstatus = 1;
            }
            return { current_address, next_address, custatus, nstatus };
        }




        async function VehicleRideStartEndData(uid, c_id, request_id) {
            const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${c_id}' AND d_id = '${uid}'`);
            if (rd == "") return { ResponseCode: 401, Result: false, message: 'Request Not Found!' };

            let dlatlon = rd[0].drop_lat_long.split("&!!"), daddress = rd[0].drop_address.split("&!!"), pending_ride = "", drop_list = [], splh = rd[0].current_run_time.split("&")
            pending_ride = parseFloat(rd[0].drop_complete);

            let ccheck = await CheckCurrentLocation(pending_ride, dlatlon, daddress), pickup, drop, drop_latlon, tot_hour = rd[0].tot_hour, tot_min = rd[0].tot_minute, tot_km = splh[3];

            for (let i = 0; i < dlatlon.length;) {
                let checkadd = daddress[i].split("&!"), checkl = dlatlon[i].split("&!"), status = "";

                if (pending_ride == i) status = "2";
                if (pending_ride > i) status = "3";
                if (pending_ride < i) status = "1";

                if (parseFloat(rd[0].drop_complete) <= i) drop_list.push({ status: status, title: checkadd[0], subtitle: checkadd[1], latitude: checkl[0], longitude: checkl[1] })
                i++
            }

            return { uid, c_id, request_id, status: rd[0].status, tot_hour, tot_min, tot_second: 0, tot_km: tot_km, current_address: ccheck.current_address, next_address: ccheck.next_address, drop_list }
        }



        async function VehicleAllRide(rdata, number) {
            let piclatlon, firstdrop = [], dropdata = [], drop_tot = 0;

            let plos = rdata.pic_lat_long.split("&!"), pads = rdata.pic_address.split("&!")
            piclatlon = { title: pads[0], subtitle: pads[1], latitude: plos[0], longitude: plos[1] }

            let platlon = rdata.drop_lat_long.split("&!!"), dradd = rdata.drop_address.split("&!!")
            drop_tot = dradd.length

            for (let a = 0; a < platlon.length;) {
                let lspl = platlon[a].split("&!"), addspl = dradd[a].split("&!")
                if (a == 0) firstdrop.push({ title: addspl[0], subtitle: addspl[1], latitude: lspl[0], longitude: lspl[1] })
                else dropdata.push({ title: addspl[0], subtitle: addspl[1], latitude: lspl[0], longitude: lspl[1] })
                a++
            }
            if (number == "1") {
                return { piclatlon, dropdata: firstdrop[0], droplist: dropdata, drop_tot }
            } else if (number == "2") {
                let data = firstdrop.concat(dropdata)
                return { piclatlon, dropdata: data, drop_tot }
            }
        }



        async function RideAddress(rdata, number) {
            let piclatlon, pads = rdata.pic_address.split("&!"), dradd = rdata.drop_address.split("&!!"), dropdata = [], drop_tot = 0;
            drop_tot = dradd.length;

            piclatlon = { title: pads[0], subtitle: pads[1] }

            if (number == "1") {
                let addspl = dradd[0].split("&!");
                return { piclatlon, dropdata: { title: addspl[0], subtitle: addspl[1] }, drop_tot };
            }
            else if (number == "2") {
                for (let a = 0; a < dradd.length;) {
                    let addspl = dradd[a].split("&!");
                    dropdata.push({ title: addspl[0], subtitle: addspl[1] });
                    a++
                }
                return { piclatlon, dropdata, drop_tot };
            }
        }



        async function DateFormate(fulldate) {
            const date = new Date(fulldate);
            const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };

            const formattedDate = date.toLocaleString('en-US', options);
            return formattedDate
        }



        async function VehicleBidding(uid, request_id, price, status, hostname, protocol) {

            let rd = []
            if (typeof uid == 'object') {
                rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE bidding_status = "1" AND id = '${request_id}'`);
            } else {
                rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE bidding_status = "1" AND id = '${request_id}' AND JSON_CONTAINS(d_id, '${uid}')`);
            }

            if (rd != "") {

                let idlist = rd[0].d_id, bprice = rd[0].bidding_d_price, eidlist = [], driindex = 0;
                if (typeof idlist == "string") eidlist = JSON.parse(idlist);
                else eidlist = idlist;

                driindex = eidlist.indexOf(parseFloat(uid));

                let old = "", nid = ``, nprice = [], ndate = new Date().toISOString();

                if (bprice != "") {

                    let pspl = bprice.split("&&!");
                    for (let a = 0; a < pspl.length;) {
                        let sd = pspl[a].split("&");

                        if (status == "1" || status == "3" || status == "4") {

                            if (parseFloat(sd[1]) != parseFloat(uid)) {
                                old += old == "" ? `${sd[0]}&${sd[1]}&${sd[2]}` : `&&!${sd[0]}&${sd[1]}&${sd[2]}`;
                                nid += nid == "" ? `${sd[1]}` : `,${sd[1]}`;
                                nprice.push({ date: sd[0], id: parseFloat(sd[1]), price: parseFloat(sd[2]) });
                            }
                        } else if (status == "2") {
                            old += old == "" ? `${sd[0]}&${sd[1]}&${sd[2]}` : `&&!${sd[0]}&${sd[1]}&${sd[2]}`;
                            nid += nid == "" ? `${sd[1]}` : `,${sd[1]}`;
                            nprice.push({ date: sd[0], id: parseFloat(sd[1]), price: parseFloat(sd[2]) });
                        }
                        a++;
                    }
                }

                let data, ids, prices;
                if (status == "1") {
                    data = old == "" ? `${ndate}&${uid}&${price}` : `${ndate}&${uid}&${price}&&!${old}`;
                    ids = nid == "" ? `${uid}` : `${uid},${nid}`;
                    prices = nprice != "" ? [{ date: ndate, id: parseFloat(uid), price: parseFloat(price) }].concat(nprice) : [{ date: ndate, id: parseFloat(uid), price: parseFloat(price) }];
                } else {
                    data = old; ids = nid; prices = nprice;
                }

                const general = await DataFind(`SELECT google_map_key, offer_time FROM tbl_general_settings`);
                let dtime = 0, dri_list = [], nid_list = [];
                if (ids != "") {

                    let dr = await DriverReview("dr");
                    let dri = await DataFind(`SELECT dr.id, dr.profile_image, dr.first_name, dr.last_name, dr.latitude, dr.longitude,
                                                COALESCE(vec.name, "") AS car_name  ${dr.tot_review} ${dr.avgstar}
                                                FROM tbl_driver AS dr
                                                LEFT JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                                ${dr.outtable}
                                                WHERE dr.id IN (${ids}) AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')
                                                GROUP BY dr.id, dr.profile_image, dr.first_name, dr.last_name, vec.name ORDER BY dr.id DESC`);

                    let firlat = rd[0].pic_lat_long, drop = "", droadd = "", def = (parseFloat(rd[0].tot_hour) * 60) + parseFloat(rd[0].tot_minute)

                    if (firlat) {
                        let spl = firlat.split("&!"), das = rd[0].pic_address.split("&!")
                        drop = `${spl[0]},${spl[1]}`, droadd = das[0]

                        for (let i = 0; i < dri.length;) {
                            let dpri = [];
                            for (let b = 0; b < prices.length;) {
                                if (dri[i].id == prices[b].id) dpri.push(prices[b]);
                                b++;
                            }

                            if (status == "1") {
                                const general = await DataFind(`SELECT site_currency, currency_placement FROM tbl_general_settings`);
                                let pricespl = general[0].currency_placement == "1" ? `${price}${general[0].site_currency}` : `${general[0].site_currency}${price}`
                                let notification = `${dri[i].first_name} ${dri[i].last_name} is offering a ride to ${droadd} ${pricespl}`

                                sendOneNotification(notification, 'customer', rd[0].c_id);
                            }

                            if (dpri != "") {

                                let diff_second = await CurrentDatetoOldDateS(dpri[0].date, general[0].offer_time);
                                if (parseFloat(diff_second) >= 0) {
                                    if (parseFloat(diff_second) <= parseFloat(general[0].offer_time)) {

                                        let pickup = `${dri[i].latitude},${dri[i].longitude}`;
                                        let distance = await GetDistance(pickup, drop, general[0].google_map_key);

                                        let tot_km = parseFloat((parseFloat(rd[0].tot_km) + parseFloat(distance.dis)).toFixed(2));

                                        let spltime = distance.dur.split(" ");
                                        if (spltime.length == "2") dtime = parseFloat(spltime[0]);
                                        else dtime = (parseFloat(spltime[0]) * 60) + parseFloat(spltime[2]);

                                        let min = parseFloat(def) + parseFloat(dtime);
                                        let tot_min = await CalculateMinuteToHour(min);

                                        dri[i].tot_review = parseFloat((dri[i].tot_review).toFixed(2)); dri[i].avg_star = parseFloat((dri[i].avg_star).toFixed(2));
                                        dri_list.push({ ...dri[i], request_id, price: dpri[0].price, tot_min, tot_km, diff_second });

                                    } else nid_list.push(dri[i].id);
                                } else nid_list.push(dri[i].id);
                            }
                            i++;
                        }
                    }
                }

                if (status == "1" || status == "2" || status == "4") {
                    if (await DataUpdate(`tbl_request_vehicle`, `bidding_d_price = '${data}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) {
                        return false;
                    }
                } else {
                    let d_id = rd[0].d_id, eidlist, reqmoveid;

                    if (typeof d_id == "string") {
                        d_id = JSON.parse(d_id);
                        eidlist = d_id.filter(item => item != uid);
                        reqmoveid = JSON.stringify(eidlist);
                    } else {
                        eidlist = d_id.filter(item => item != uid);
                        reqmoveid = JSON.stringify(eidlist);
                    }

                    if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${reqmoveid}', bidding_d_price = '${data}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) {
                        return false;
                    }
                }

                if (status == "1" || status == "4") return { bidding_list: dri_list, off_ex_time: general[0].offer_time };
                else return { bidding_list: dri_list, off_ex_time: general[0].offer_time, request_id: rd[0].id, c_id: rd[0].c_id, nid_list };

            } return false;
        }



        async function AcceptVehicleRide(uid, request_id, lat, lon, hostname, protocol, price, ndata) {
            if (!uid || !request_id || !lat || !lon) return 1;

            let rd
            if (ndata != "") rd = ndata;
            else rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND JSON_CONTAINS(d_id, '${uid}')`);
            if (rd == "") return 2;

            const driver = await DataFind(`SELECT * FROM tbl_driver WHERE id = '${uid}'`);
            if (driver == "") 3;

            let otp = await otpGenerate(4), jsonuid = JSON.stringify([parseFloat(uid)]), requestid = 0;

            if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${jsonuid}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) return "databaseerror";
            if (await DataUpdate(`tbl_driver`, `rid_status = '1'`, `id = '${driver[0].id}'`, hostname, protocol) == -1) return "databaseerror";

            const check = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${rd[0].c_id}' AND d_id = '${uid}'`);

            let dropcount = rd[0].drop_lat_long.split("&!!").length;
            let fulldate = await TodatDate(), updatet = "", nprice = 0

            if (rd[0].bidding_status == "1") {
                updatet = `0&${rd[0].start_time}&$0&$0&!!1&${fulldate.date}T${fulldate.time}&${driver[0].latitude}&${driver[0].latitude}`;
                if (rd[0].bidd_auto_status == "0") {
                    if (price == "0") nprice = rd[0].price;
                    else nprice = price;
                } else nprice = rd[0].price;
            } else {
                updatet = `0&${rd[0].start_time}&$0&$0&!!1&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;
                nprice = rd[0].price;
            }

            let ntime = `1&${rd[0].tot_hour}&${rd[0].tot_minute}`; // status_time
            let current_time = `${fulldate.date}T${fulldate.time}&${rd[0].tot_hour}&${rd[0].tot_minute}`; // current_run_time

            let idlist = rd[0].d_id, d_id, eidlist, reqmoveid;
            if (typeof idlist == "string") {
                d_id = JSON.parse(idlist);
                eidlist = d_id.filter(item => item != uid);
                reqmoveid = JSON.stringify(eidlist);
            } else {
                eidlist = idlist.filter(item => item != uid);
                reqmoveid = JSON.stringify(eidlist);
            }

            let indata = await DataInsert(`tbl_cart_vehicle`, `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, price, final_price, paid_amount, coupon_amount, addi_time_price,
                    platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, coupon_id, start_time, otp, additional_time, ride_status, drop_tot,
                    drop_complete, current_run_time, status_time, status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, driver_id_list, req_id`,
                `'${rd[0].c_id}', '${uid}', '${rd[0].vehicleid}', '${rd[0].bidding_status}', '${rd[0].bidd_auto_status}', '${nprice}', '0', '0', '0', '0', '0', '0', '0', '${rd[0].tot_km}',
                    '${rd[0].tot_hour}', '${rd[0].tot_minute}', '1', '${rd[0].payment_id}', '${rd[0].m_role}', '${rd[0].coupon_id}', '${fulldate.date}T${fulldate.time}', '${otp}', '0', '0',
                    '${dropcount}', '', '${current_time}', '${ntime}', '${updatet}', '', '${rd[0].pic_lat_long}', '${rd[0].drop_lat_long}', '${rd[0].pic_address}', '${rd[0].drop_address}',
                    '${reqmoveid}', '${rd[0].id}'`, hostname, protocol);

            if (indata == -1) return "databaseerror";

            requestid = indata.insertId;

            if (await DataDelete(`tbl_request_vehicle`, `id = '${rd[0].id}'`, hostname, protocol) == -1) return "databaseerror";

            await AllChat.Chat_Save(uid, uid, rd[0].c_id, "üöó Your Trip Has Started!", "driver", hostname, protocol);

            let message = "üìç Your Captain is on the way!\n" +
                "Captain " + driver[0].first_name + " " + driver[0].last_name + " will arrive shortly."
            await AllChat.Chat_Save(uid, uid, rd[0].c_id, message, "driver", hostname, protocol);

            return { requestid: requestid, reqmoveid };
        }



        async function AllVehicleFormate(com_request, number) {
            let comreq = com_request.map(async (rdata) => {

                let data = await VehicleAllRide(rdata, number);
                rdata.price = parseFloat(rdata.price);
                rdata.addi_time = parseFloat(rdata.additional_time);

                let spldate = rdata.status_time_location.split("&!!"), starttime = "", run_time = { hour: 0, minute: 0, second: 0, status: 0 };

                if (rdata.status != '0') starttime = await DateFormate(spldate[0].split("&")[1]);

                run_time = await TimeDistance(rdata);

                if (rdata.m_role == "1") rdata.m_role = "Vehicle";
                if (rdata.m_role == "2") rdata.m_role = "Outstation";
                if (rdata.m_role == "3") rdata.m_role = "Rental";
                if (rdata.m_role == "4") rdata.m_role = "Package";

                rdata.start_time = starttime; rdata.tot_drop = data.drop_tot; rdata.run_time = run_time; rdata.pickup = data.piclatlon; rdata.drop = data.dropdata; rdata.drop_list = data.droplist;
                delete rdata.current_run_time; delete rdata.pic_lat_long; delete rdata.drop_lat_long; delete rdata.drop_lat_long; delete rdata.pic_address; delete rdata.drop_address;
                delete rdata.status_time_location; delete rdata.coupon_id; delete rdata.additional_time; delete rdata.comission_rate; delete rdata.comission_type
                return rdata
            })
            let complete_request = await Promise.all(comreq);
            return complete_request;
        }



        async function SetNewTimeFormate(nDate) {
            let currentTime = new Date(nDate);

            let hours = currentTime.getHours(), minutes = currentTime.getMinutes();
            let ampm = hours >= 12 ? 'PM' : 'AM';

            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;

            let formattedTime = hours + ':' + minutes + ' ' + ampm;
            return formattedTime
        }



        async function PaymentCalculation(mapdata, status) {
            const general = await DataFind(`SELECT * FROM tbl_general_settings`);
            let mapd = status == "1" ? mapdata[0] : mapdata
            let price = parseFloat(mapd.price), coupon_amount = 0, final_price = parseFloat(mapd.price), platform_fee = 0, addi_time_price = 0, addi_time = 0, weather_price = 0;

            if (parseFloat(general[0].driver_wait_price) != "NaN" && typeof parseFloat(general[0].driver_wait_price) == "number") {
                if (mapd.additional_time || mapd.additional_time != "0") {
                    let totmin = parseFloat(mapd.additional_time);

                    addi_time_price = parseFloat(totmin) * parseFloat(general[0].driver_wait_price);
                    addi_time = totmin;
                    final_price += addi_time_price;
                }
            }

            if (mapd.coupon_id || mapd.coupon_id != "") {
                const coupon = await DataFind(`SELECT * FROM tbl_coupon WHERE id = '${mapd.coupon_id}' `);
                if (coupon != "") {
                    if (parseFloat(coupon[0].min_amount) <= parseFloat(mapd.price)) {
                        coupon_amount = parseFloat(coupon[0].discount_amount);
                        final_price -= parseFloat(coupon[0].discount_amount);
                    }
                }
            }

            if (mapd.comission_rate && mapd.comission_type) {
                if (mapd.comission_type == "FIX") {
                    platform_fee = parseFloat(mapd.comission_rate); final_price += parseFloat(mapd.comission_rate);
                } else {
                    let amount = final_price / parseFloat(mapd.comission_rate);
                    platform_fee = amount;
                    final_price += amount;
                }
            }

            let veh_list = await DataFind(`SELECT * FROM tbl_vehicle WHERE id = '${mapd.vehicleid}' AND status = '1'`);

            if (veh_list != "") {
                if (veh_list[0].whether_charge == "1") {
                    if (parseFloat(general[0].weather_price) != "NaN" && typeof parseFloat(general[0].weather_price) == "number" && parseFloat(general[0].weather_price) != 0) {
                        if (general[0].weather_type == "FIX") {
                            weather_price = parseFloat(general[0].weather_price);
                            final_price += parseFloat(general[0].weather_price);
                        } else {
                            let wamount = final_price / parseFloat(general[0].weather_price);
                            weather_price = parseFloat((wamount).toFixed(2));
                            final_price += wamount;
                        }
                    }
                }
            }
            let fprice = parseFloat((parseFloat(final_price)).toFixed(2));

            if (status == "1") mapd.coupon_amount = coupon_amount; mapd.platform_fee = platform_fee; mapd.final_price = fprice; mapd.price = parseFloat(mapd.price);
            mapd.weather_price = parseFloat(weather_price);

            return { mapdata: mapd, coupon_amount, final_price: fprice, platform_fee, addi_time_price, addi_time, weather_price }
        }



        async function PriceCalculation(rd, hostname, protocol) {
            const general = await DataFind(`SELECT driver_wait_price, google_map_key FROM tbl_general_settings`);

            let price = parseFloat(rd[0].price), final_price = parseFloat(rd[0].price), coupon_amount = 0, addi_time_price = 0, addi_time = 0, platform_fee = 0, weather_price = 0;

            let cprice = await PaymentCalculation(rd, 1)
            final_price = cprice.final_price; coupon_amount = cprice.coupon_amount; addi_time_price = cprice.addi_time_price; addi_time = cprice.addi_time; platform_fee = cprice.platform_fee;
            weather_price = cprice.weather_price

            let picadd = [], pads = rd[0].pic_address.split("&!"), splsta = rd[0].status_time_location.split("&!!"), firsttime = "", pickkm = 0, picktime = 0, status_cal = [], cal = 0,
                savedata = "";
            let dradd = rd[0].drop_address.split("&!!"), totkm = 0, totmin = 0

            picadd.push({ title: pads[0], subtitle: pads[1] });

            for (let b = 0; b < dradd.length;) {
                let addspl = dradd[b].split("&!");
                picadd.push({ title: addspl[0], subtitle: addspl[1] });
                b++
            }

            for (let a = 0; a < splsta.length;) {
                let check = splsta[a].split("&");

                if (parseFloat(check[0]) < 4) {

                    if (parseFloat(check[0]) == 1) {

                        let checkn = splsta[a + 1].split("&");

                        let pickup = `${parseFloat(check[2])},${parseFloat(check[3])}`, drop = `${parseFloat(checkn[2])},${parseFloat(checkn[3])}`;
                        let ftime = await GetDistance(pickup, drop, general[0].google_map_key);

                        if (parseFloat(check[0]) == 1) firsttime = await SetNewTimeFormate(check[1]);
                        pickkm += parseFloat(ftime.dis);

                        let spltime = ftime.dur.split(" ");
                        if (spltime.length == "2") picktime += parseFloat(spltime[0]);
                        else picktime += (parseFloat(spltime[0]) * parseFloat(60)) + parseFloat(spltime[2]);

                        status_cal.push({ title: 'Order Accepted', subtitle: "", date: firsttime, tot_km: pickkm, tot_time: picktime });
                        savedata += `Order Accepted&&${firsttime}&${pickkm}&${picktime}`;
                        totmin += picktime;
                        totkm += pickkm
                    }


                } else if (parseFloat(check[0]) > 4 && parseFloat(check[0]) < 7) {
                    let scheckn = splsta[a + 1].split("&");

                    if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 6 || parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 7) {

                        let spickup = `${parseFloat(check[2])},${parseFloat(check[3])}`, sdrop = `${parseFloat(scheckn[2])},${parseFloat(scheckn[3])}`;
                        let time = await GetDistance(spickup, sdrop, general[0].google_map_key);
                        let dtime = await SetNewTimeFormate(check[1]), droptime = 0;

                        let spltime = time.dur.split(" ");
                        if (spltime.length == "2") droptime += parseFloat(spltime[0]);
                        else droptime += (parseFloat(spltime[0]) * parseFloat(60)) + parseFloat(spltime[2]);
                        totmin += droptime;
                        totkm += time.dis

                        if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 6) {

                            status_cal.push({ title: picadd[cal].title, subtitle: picadd[cal].subtitle, date: dtime, tot_km: time.dis, tot_time: droptime })
                            savedata += `&!!${picadd[cal].title}&${picadd[cal].subtitle}&${dtime}&${time.dis}&${droptime}`
                        }
                        if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 7) {

                            status_cal.push({ title: picadd[cal].title, subtitle: picadd[cal].subtitle, date: dtime, tot_km: time.dis, tot_time: droptime },
                                { title: picadd[cal + 1].title, subtitle: picadd[cal + 1].subtitle, date: 0, tot_km: 0, tot_time: 0 });

                            savedata += `&!!${picadd[cal].title}&${picadd[cal].subtitle}&${dtime}&${time.dis}&${droptime}`
                            savedata += `&!!${picadd[cal + 1].title}&${picadd[cal + 1].subtitle}&0&0&0`
                        }
                        cal++;
                    }
                }
                a++;
            }

            if (await DataUpdate(`tbl_cart_vehicle`, `final_price = '${final_price}', coupon_amount = '${coupon_amount}', addi_time_price = '${addi_time_price}',
                platform_fee = '${platform_fee}', weather_price = '${weather_price}', tot_km = '${totkm}', tot_hour = '0', tot_minute = '${totmin}' ,status_calculation = '${savedata}'`,
                `id = '${rd[0].id}'`, hostname, protocol) == -1) return 4;

            return { price, final_price, coupon_amount, addi_time, addi_time_price, platform_fee, status_cal, weather_price }
        }



        async function VehiclePaymentCal(uid, c_id, request_id, role, hostname, protocol) {
            let price_list, pa, add_calcu = [];
            const review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);

            if (role == "1") {
                const rd = await DataFind(`SELECT veh.*, COALESCE(cus.name, '') AS cname, COALESCE(vdata.comission_rate, '') AS comission_rate, COALESCE(vdata.comission_type, '') AS comission_type
                                    FROM tbl_cart_vehicle AS veh
                                    JOIN tbl_customer AS cus ON veh.c_id = cus.id
                                    JOIN tbl_vehicle AS vdata ON veh.vehicleid = vdata.id
                                    WHERE veh.id = '${request_id}' AND veh.c_id = '${c_id}' AND veh.d_id = '${uid}'`);

                if (rd == "") return 1;
                if (parseFloat(rd[0].status) > 7) return 2;
                if (rd[0].final_price == "0" && rd[0].status_calculation == "") {
                    pa = await PriceCalculation(rd, hostname, protocol);
                    add_calcu = pa.status_cal;
                } else {
                    pa = rd[0];
                    let timespl = rd[0].status_calculation.split("&!!");

                    for (let a = 0; a < timespl.length;) {
                        let spl = timespl[a].split("&");
                        add_calcu.push({ title: spl[0], subtitle: spl[1], date: spl[2], tot_km: spl[3], tot_time: spl[4] });
                        a++;
                    }
                }

                add_calcu.map(aval => {
                    aval.date = (aval.date).toString(); aval.tot_km = (aval.tot_km).toString(); aval.tot_time = (aval.tot_time).toString();
                    return aval;
                })

                if (pa == 3) return 3;
                if (pa == 4) return 4;

                const payment = await DataFind(`SELECT id, image, name FROM tbl_payment_detail WHERE id = '${rd[0].payment_id}' AND status = '1'`);

                price_list = {
                    cus_name: rd[0].cname, tot_price: parseFloat(pa.price), final_price: pa.final_price, coupon_amount: pa.coupon_amount, addi_time_price: pa.addi_time_price,
                    platform_fee: pa.platform_fee, weather_price: pa.weather_price, addi_time: pa.addi_time
                };
                return { price_list, payment, add_calcu, review_list };
            }

            if (role == "2") {
                const rd = await DataFind(`SELECT veh.*, COALESCE(dri.first_name, '') AS first_name, COALESCE(dri.last_name, '') AS last_name, COALESCE(vdata.comission_rate, '') AS comission_rate,
                                    COALESCE(vdata.comission_type, '') AS comission_type
                                    FROM tbl_cart_vehicle AS veh
                                    JOIN tbl_driver AS dri ON veh.d_id = dri.id
                                    JOIN tbl_vehicle AS vdata ON veh.vehicleid = vdata.id
                                    WHERE veh.id = '${request_id}' AND veh.c_id = '${c_id}' AND veh.d_id = '${uid}'`);

                if (rd == "") return 1;
                if (parseFloat(rd[0].status) > 7) return 2;
                if (rd[0].final_price == "0") pa = await PriceCalculation(rd, hostname, protocol);
                else pa = rd[0];

                if (pa == 3) return 3;
                if (pa == 4) return 4;

                const payment = await DataFind(`SELECT id, image, name FROM tbl_payment_detail WHERE id = '${rd[0].payment_id}' AND status = '1'`);

                // Customer
                price_list = {
                    first_name: rd[0].first_name, last_name: rd[0].last_name, tot_price: pa.price, final_price: pa.final_price, coupon_amount: pa.coupon_amount, addi_time_price: pa.addi_time_price,
                    platform_fee: pa.platform_fee, weather_price: pa.weather_price, addi_time: pa.addi_time
                };
                return { price_list, payment, review_list };
            }

        }



        // ============= Convert Day  ================ //

        async function DateConvertDay(walletd) {
            const all_data = [];
            walletd.forEach(item => {
                const dateString = new Date(item.date).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

                let existingDateEntry = all_data.find(entry => entry.date === dateString);

                if (!existingDateEntry) {
                    existingDateEntry = {
                        date: dateString,
                        detail: []
                    };
                    all_data.push(existingDateEntry);
                }
                item.date = new Date(item.date).toISOString().split("T")[0];
                existingDateEntry.detail.push(item);
            });
            return all_data
        }



        async function CustomerReview(tname) {
            let tot_review = `, COALESCE(COUNT(DISTINCT cr.id), 0) AS tot_review`
            let avgstar = `, CASE
                            WHEN COUNT(cr.customer_id) > 0 THEN
                                CASE
                                    WHEN (SUM(cr.tot_star) / COUNT(cr.customer_id)) % 1 >= 0.25
                                        AND (SUM(cr.tot_star) / COUNT(cr.customer_id)) % 1 < 0.75
                                    THEN ROUND((SUM(cr.tot_star) / COUNT(cr.customer_id)) * 2) / 2
                                    ELSE ROUND(SUM(cr.tot_star) / COUNT(cr.customer_id))
                                END
                            ELSE 0
                        END AS avg_star`

            let table = `LEFT JOIN tbl_review_customer AS cr ON cr.customer_id = ${tname}.c_id`
            let outtable = `LEFT JOIN tbl_review_customer AS cr ON cr.customer_id = ${tname}.id`
            return { tot_review, avgstar, table, outtable }
        }



        async function DriverReview(tname) {
            let tot_review = `, COALESCE(COUNT(DISTINCT cr.id), 0) AS tot_review`
            let avgstar = `, CASE
                            WHEN COUNT(cr.driver_id) > 0 THEN
                                CASE
                                    WHEN (SUM(cr.tot_star) / COUNT(cr.driver_id)) % 1 >= 0.25
                                        AND (SUM(cr.tot_star) / COUNT(cr.driver_id)) % 1 < 0.75
                                    THEN ROUND((SUM(cr.tot_star) / COUNT(cr.driver_id)) * 2) / 2
                                    ELSE ROUND(SUM(cr.tot_star) / COUNT(cr.driver_id))
                                END
                            ELSE 0
                        END AS avg_star`

            let table = `LEFT JOIN tbl_review_driver AS cr ON cr.driver_id = ${tname}.d_id`;
            let outtable = `LEFT JOIN tbl_review_driver AS cr ON cr.driver_id = ${tname}.id`;
            return { tot_review, avgstar, table, outtable };
        }



        async function CalculateMinuteToHour(minute) {
            let a = parseFloat(minute);
            let hour = Math.floor(a / 60);
            let min = a % 60;
            let totm = `${hour}.${min.toString().padStart(2, '0')}`;
            return parseFloat(totm);
        }

        async function MinuteToHour(minute) {
            let a = parseFloat(minute);
            let hour = Math.floor(a / 60);
            let min = a % 60;
            let totm = `${hour}.${min.toString().padStart(2, '0')}`;
            return { hour: parseFloat(hour), minute: parseFloat(min) };
        }




        async function TimeUpdate(homemessage, hostname, protocol) {
            const { uid, c_id, request_id, time } = homemessage;
            if (!uid || !c_id || !request_id || !time) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

            const check = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${c_id}' AND d_id = '${uid}'`);
            if (check == "") return { ResponseCode: 401, Result: false, message: 'Request Not Found!' };

            let fulldate = await AllFunction.TodatDate();

            let ntime = check[0].status_time != "" ? `${check[0].status_time}&!!${check[0].status}&0&${time}` : `${check[0].status}&0&${time}`; // status_time
            let current_time = `${fulldate.date}T${fulldate.time}&0&${time}`; // current_run_time

            if (await DataUpdate(`tbl_cart_vehicle`, `tot_hour = '0', tot_minute = '${time}', status_time = '${ntime}', current_run_time = '${current_time}'`,
                `id = '${check[0].id}'`, hostname, protocol) == -1) {
                return { ResponseCode: 401, Result: false, message: process.env.dataerror };
            }
            return true;
        }



        async function DriverNewRequestData(uid, request_id, sttaus) {
            if (!uid || !request_id) 1

            let dr = await AllFunction.CustomerReview("rvd");
            let rdata = await DataFind(`SELECT rvd.*, COALESCE(cus.id, "") AS cus_id, COALESCE(cus.name, "") AS name, COALESCE(cus.country_code, "") AS country_code,
                                        COALESCE(cus.phone, "") AS phone ${dr.tot_review} ${dr.avgstar}
                                        FROM tbl_request_vehicle AS rvd
                                        LEFT JOIN tbl_customer AS cus ON rvd.c_id = cus.id
                                        ${dr.table}
                                        WHERE rvd.id = '${request_id}' AND JSON_CONTAINS(rvd.d_id, '${uid}') GROUP BY rvd.id ORDER BY id DESC`);

            if (rdata == "") {
                rdata = await DataFind(`SELECT rvd.*, COALESCE(cus.id, "") AS cus_id, COALESCE(cus.name, "") AS name,
                                        COALESCE(cus.country_code, "") AS country_code, COALESCE(cus.phone, "") AS phone
                                        ${dr.tot_review} ${dr.avgstar}
                                        FROM tbl_cart_vehicle AS rvd
                                        LEFT JOIN tbl_customer AS cus ON rvd.c_id = cus.id
                                        ${dr.table}
                                        WHERE rvd.id = '${request_id}' AND rvd.d_id = '${uid}'
                                        GROUP BY rvd.id ORDER BY rvd.id DESC;`);

                if (rdata == "") 2
            }

            let request_data = []
            if (sttaus == "0") request_data = await DriverRequestData(rdata);
            else return 0

            return { request_data: request_data[0] }
        }



        const AllFunction = {
            otpGenerate, ZoneLatlon, CheckZone, GetDistance, DriverUpdate, ZoneData, AddDateMinute, TodatDate, RadiusCheck, DriverRequestData, CheckBodyData,
            CheckCurrentLocation, CheckSocketData, SendDriverLatLong, VehicleRideStartEndData, VehicleAllRide, DateFormate, AllVehicleFormate, VehiclePaymentCal,
            TwoTimeDifference, FirstTime, SecoundTime, SetNewTimeFormate, DateConvertDay, PaymentCalculation, RideAddress, ConvertDateFormat, ConvertFullDateFormat, TimeUpdate,
            CustomerReview, DriverReview, CalculateMinuteToHour, PriceCalculation, VehicleBidding, MinuteToHour, AcceptVehicleRide, DriverNewRequestData, CurrentDatetoOldDateS
        }

        module.exports = AllFunction
]
]

I need the API calls to be efficient, handle errors gracefully, and function reliably.

Code Quality and Structure:

I require a complete refactoring of the project to ensure a clean, well-structured, and maintainable codebase. This includes:

Improving code readability and organization.

Implementing a logical file and folder structure.

Adhering to Flutter best practices.

UI/UX Design:

The project's current design needs a significant upgrade. I would like a better and more professional design applied to all screens and components.

Core Functionality:

Crucially, the original logic and functionality of the app must be preserved. All fixes and improvements should be implemented in a way that the app still works as intended, but without the bugs and performance issues.

