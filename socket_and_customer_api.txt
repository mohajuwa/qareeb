


const AllFunction = require("../route_function/function")
const AllChat = require("../route_function/chat_function")
const schedule = require('node-schedule');
const { DataFind, DataInsert, DataUpdate, DataDelete } = require("../middleware/databse_query");

// FIXED: Use Map for better memory management and cleanup
let activeSchedules = new Map();
let connectedSockets = new Set();

// FIXED: Add cleanup function to prevent memory leaks
function cleanupSchedules() {
    const now = Date.now();
    const expiredKeys = [];

    for (let [key, scheduleData] of activeSchedules) {
        // Remove schedules older than 1 hour
        if (now - scheduleData.createdAt > 3600000) {
            scheduleData.job.cancel();
            expiredKeys.push(key);
        }
    }

    expiredKeys.forEach(key => activeSchedules.delete(key));
    console.log(`Cleaned up ${expiredKeys.length} expired schedules`);
}

// FIXED: Run cleanup every 10 minutes
setInterval(cleanupSchedules, 600000);

function publicsocket(io) {
    // FIXED: Add connection limit
    io.engine.generateId = (req) => {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    };

    io.on('connection', (socket) => {
        console.log('Socket connected:', socket.id);
        connectedSockets.add(socket.id);

        // FIXED: Limit connections per server
        if (connectedSockets.size > 1000) {
            console.warn('Too many connections, rejecting new connection');
            socket.disconnect();
            return;
        }

        // FIXED: Add disconnect handler to clean up
        socket.on('disconnect', () => {
            console.log('Socket disconnected:', socket.id);
            connectedSockets.delete(socket.id);

            // Cancel any schedules associated with this socket
            for (let [key, scheduleData] of activeSchedules) {
                if (scheduleData.socketId === socket.id) {
                    scheduleData.job.cancel();
                    activeSchedules.delete(key);
                }
            }
        });

        // Customer Home
        socket.on('home', async (message) => {
            socket.broadcast.emit('home', message);
        });

        // Home Map
        socket.on('homemap', async (homemessage) => {
            try {
                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';
                const { uid, lat, long, status } = homemessage;

                if (!uid || !lat || !long || !status) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                const missingField = await AllFunction.CheckSocketData(homemessage, ["uid", "lat", "long", "status"]);

                const dri = await DataFind(`SELECT dr.id, dr.zone, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                            COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude, dr.fstatus, dr.rid_status, dr.check_status
                                            FROM tbl_driver AS dr
                                            JOIN tbl_vehicle AS ve ON dr.vehicle = ve.id
                                            WHERE dr.id = '${uid}' AND dr.status = '1' LIMIT 1`);

                if (!missingField && dri && dri.length > 0) {
                    let check_status = "0", homemap = 0, vdriloc = 0;

                    if (dri[0].rid_status == "0") homemap = 1;
                    if (dri[0].rid_status == "1") {
                        if (dri[0].check_status == "0") homemap = 1;
                        else homemap = 0;
                        check_status = "1";
                        vdriloc = 1;
                    }

                    await DataUpdate(`tbl_driver`, `latitude = '${lat}', longitude = '${long}', fstatus = '${status == "on" ? "1" : "0"}'`, `id = '${uid}'`, hostname, protocol);

                    if (homemap == 1) {
                        socket.broadcast.emit(`V_homemap${uid}`, {
                            driver: dri[0],
                            check_status,
                            vdriloc
                        });
                    }

                    if (vdriloc == 1) {
                        const sql = `SELECT c_id FROM tbl_cart_vehicle WHERE d_id = ? AND status IN ('2', '3') AND DATE(start_time) = CURDATE() LIMIT 10`;
                        const d = await DataFind(sql, [uid]);
                        for (let i = 0; i < d.length && i < 10; i++) {
                            socket.broadcast.emit(`V_Driver_Location${d[i].c_id}`, {
                                d_id: uid,
                                driver_location: dri[0]
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('homemap error:', error);
                socket.emit('database_error', {
                    ResponseCode: 401,
                    Result: false,
                    message: process.env.dataerror || 'Database error occurred'
                });
            }
        });

        // Send Vehicle Ride Request
        socket.on('vehiclerequest', (homemessage) => {
            if (homemessage) {
                socket.broadcast.emit('vehiclerequest', homemessage);
            }
        });

        // FIXED: Vehicle Bidding with proper memory management
        socket.on('Vehicle_Bidding', async (homemessage) => {
            try {
                const { uid, request_id, c_id, price, status } = homemessage;

                if (!uid || !request_id || !c_id || !price || !status) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                if (status == "1") {
                    let ddata = await AllFunction.VehicleBidding(uid, request_id, price, 1, hostname, protocol);

                    if (ddata && ddata !== false) {
                        socket.broadcast.emit(`Vehicle_Bidding${c_id}`, ddata);

                        if (parseFloat(ddata.off_ex_time) > 0) {
                            let addtime = parseFloat(ddata.off_ex_time);

                            // FIXED: Create unique key for schedule
                            const scheduleKey = `${request_id}_${uid}_${c_id}`;

                            // FIXED: Cancel existing schedule if exists
                            if (activeSchedules.has(scheduleKey)) {
                                activeSchedules.get(scheduleKey).job.cancel();
                            }

                            let job = schedule.scheduleJob(new Date(Date.now() + addtime * 1000), async function () {
                                try {
                                    if (activeSchedules.has(scheduleKey)) {
                                        let ddatas = await AllFunction.VehicleBidding(uid, request_id, price, 2, hostname, protocol);

                                        if (ddatas && ddatas !== false) {
                                            let dlidt = ddatas.nid_list, req_id = ddatas.request_id;
                                            socket.broadcast.emit(`Vehicle_Bidding${ddatas.c_id}`, {
                                                bidding_list: ddatas.bidding_list,
                                                off_ex_time: ddatas.off_ex_time
                                            });
                                        }

                                        // FIXED: Remove from activeSchedules after execution
                                        activeSchedules.delete(scheduleKey);
                                    }
                                } catch (error) {
                                    console.error('Schedule execution error:', error);
                                    activeSchedules.delete(scheduleKey);
                                }
                            });

                            // FIXED: Store with metadata for cleanup
                            activeSchedules.set(scheduleKey, {
                                job,
                                request_id,
                                d_id: uid,
                                c_id,
                                socketId: socket.id,
                                createdAt: Date.now()
                            });
                        }
                    }
                }

                if (status == "2") {
                    const scheduleKey = `${request_id}_${uid}_${c_id}`;

                    // FIXED: Properly cancel and remove schedule
                    if (activeSchedules.has(scheduleKey)) {
                        activeSchedules.get(scheduleKey).job.cancel();
                        activeSchedules.delete(scheduleKey);
                    }

                    let remove = await AllFunction.VehicleBidding(uid, request_id, price, 3, hostname, protocol);

                    if (remove && remove !== false) {
                        socket.broadcast.emit(`Vehicle_Bidding${remove.c_id}`, {
                            bidding_list: remove.bidding_list,
                            off_ex_time: remove.off_ex_time
                        });
                    }
                }
            } catch (error) {
                console.error('Vehicle_Bidding error:', error);
                socket.emit('error', { message: 'Bidding error occurred' });
            }
        });

        // Vehicle Request TimeOut
        socket.on('RequestTimeOut', (homemessage) => {
            socket.broadcast.emit('RequestTimeOut', homemessage);
        });

        // FIXED: Accept Bidding with cleanup

        socket.on('Accept_Bidding', async (homemessage) => {
            try {
                const { uid, d_id, price, request_id } = homemessage;
                console.log('🎯 Accept_Bidding received:', { uid, d_id, price, request_id });

                if (!uid || !d_id || !price || !request_id) {
                    console.error('❌ Missing required fields');
                    socket.emit(`Accept_Bidding_Response${uid}`, {
                        success: false,
                        message: 'Missing required fields',
                        driver_id: d_id,
                        request_id: request_id
                    });
                    return;
                }

                const missingField = await AllFunction.CheckSocketData(homemessage, ["uid", "d_id", "price", "request_id"]);

                if (!missingField) {
                    // Check if request exists and driver is in the list
                    const rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}' LIMIT 1`);

                    if (!rd || rd.length === 0) {
                        console.error('❌ Request not found');
                        socket.emit(`Accept_Bidding_Response${uid}`, {
                            success: false,
                            message: 'Request not found',
                            driver_id: d_id,
                            request_id: request_id
                        });
                        return;
                    }

                    // Validate driver is in the bidding list
                    let driverList = rd[0].d_id;
                    if (typeof driverList === 'string') {
                        driverList = JSON.parse(driverList);
                    }

                    if (!driverList.includes(parseInt(d_id))) {
                        console.error('❌ Driver not in bidding list');
                        socket.emit(`Accept_Bidding_Response${uid}`, {
                            success: false,
                            message: 'Driver not authorized for this request',
                            driver_id: d_id,
                            request_id: request_id
                        });
                        return;
                    }

                    // Cancel all schedules for this request
                    for (let [key, scheduleData] of activeSchedules) {
                        if (scheduleData.request_id === request_id) {
                            scheduleData.job.cancel();
                            activeSchedules.delete(key);
                            console.log(`🗑️ Cancelled schedule: ${key}`);
                        }
                    }

                    const hostname = socket.request.headers.host;
                    const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                    console.log('🔄 Calling AcceptBidding function...');
                    let accept = await AllFunction.AcceptBidding(uid, d_id, price, request_id, hostname, protocol);

                    console.log('📋 AcceptBidding result:', accept);

                    if (accept && accept !== false) {
                        console.log('✅ AcceptBidding successful');

                        // Send success response to customer - THIS IS THE CRITICAL FIX
                        socket.emit(`Accept_Bidding_Response${uid}`, {
                            success: true,
                            message: 'Driver bid accepted successfully',
                            driver_id: parseInt(d_id),
                            request_id: request_id,
                            cart_id: accept.cart_id || request_id
                        });

                        // Notify other drivers their bids were declined
                        const rejectedDrivers = driverList.filter(id => id != d_id);
                        rejectedDrivers.forEach(driverId => {
                            socket.broadcast.emit(`Bidding_decline${driverId}`, {
                                request_id: request_id,
                                message: 'Another driver was selected'
                            });
                        });

                        console.log(`🎉 Customer ${uid} accepted driver ${d_id} bid for request ${request_id}`);

                    } else {
                        console.error('❌ AcceptBidding function returned false or null');
                        socket.emit(`Accept_Bidding_Response${uid}`, {
                            success: false,
                            message: 'Failed to accept driver bid - backend error',
                            driver_id: d_id,
                            request_id: request_id
                        });
                    }
                } else {
                    console.error('❌ Validation failed:', missingField);
                    socket.emit(`Accept_Bidding_Response${uid}`, {
                        success: false,
                        message: `Missing field: ${missingField}`,
                        driver_id: d_id,
                        request_id: request_id
                    });
                }
            } catch (error) {
                console.error('💥 Accept_Bidding error:', error);
                socket.emit(`Accept_Bidding_Response${uid}`, {
                    success: false,
                    message: 'Internal server error',
                    driver_id: homemessage.d_id || 0,
                    request_id: homemessage.request_id || 0
                });
            }
        });
        // Add RIGHT AFTER Accept_Bidding handler
        socket.on('Bidding_decline', async (data) => {
            try {
                const { uid, id: driver_id, request_id } = data;

                console.log('❌ Bidding_decline received:', { uid, driver_id, request_id });

                if (!uid || !driver_id || !request_id) {
                    console.error('❌ Missing parameters for decline');
                    return;
                }

                // Find the request
                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                if (!request || request.length === 0) {
                    console.error('❌ Request not found for decline');
                    return;
                }

                // Parse and update driver list
                let currentDriverList = request[0].d_id;
                if (typeof currentDriverList === 'string') {
                    currentDriverList = JSON.parse(currentDriverList);
                }

                const updatedDriverList = currentDriverList.filter(id => id != driver_id);

                console.log('🔄 Removing driver from list:', {
                    before: currentDriverList.length,
                    after: updatedDriverList.length,
                    removed: driver_id
                });

                // Update database
                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                await DataUpdate(
                    'tbl_request_vehicle',
                    `d_id = '${JSON.stringify(updatedDriverList)}'`,
                    `id = '${request_id}'`,
                    hostname,
                    protocol
                );

                // Confirm decline to customer
                socket.emit(`Bidding_decline_Response${uid}`, {
                    success: true,
                    driver_id: parseInt(driver_id),
                    remaining_drivers: updatedDriverList.length
                });

                console.log('✅ Driver decline processed');

                // If no drivers left, trigger timeout
                if (updatedDriverList.length === 0) {
                    socket.emit(`removecustomerdata${uid}`, {
                        requestid: parseInt(request_id),
                        type: 'all_declined'
                    });
                }

            } catch (error) {
                console.error('💥 Bidding_decline error:', error);
            }
        });
        // Accept Vehicle Ride Request
        socket.on('acceptvehrequest', async (homemessage) => {
            try {
                const { uid, request_id, c_id } = homemessage;

                if (!uid || !request_id || !c_id) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                let ddata = await AllFunction.SendDriverLatLong(uid);

                const rd = await DataFind(`SELECT id, driver_id_list FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${c_id}' AND d_id = '${uid}' LIMIT 1`);
                if (rd && rd.length > 0) {
                    let idlist = rd[0].driver_id_list;
                    if (typeof idlist == "string") idlist = JSON.parse(idlist);
                    socket.broadcast.emit('AcceRemoveOther', { requestid: request_id, driverid: idlist });
                }

                socket.broadcast.emit(`acceptvehrequest${c_id}`, homemessage);

                if (ddata.driver && ddata.driver.length > 0 && ddata.data && ddata.data.length > 0) {
                    let d = ddata.data;
                    for (let i = 0; i < d.length && i < 50; i++) {
                        socket.broadcast.emit(`V_Driver_Location${d[i].c_id}`, {
                            d_id: uid,
                            driver_location: ddata.driver[0]
                        });
                    }
                }
            } catch (error) {
                console.error('acceptvehrequest error:', error);
                socket.emit('error', { message: 'Accept request error occurred' });
            }
        });

        // Accept Vehicle Ride Request AND Remove other driver
        socket.on('AcceRemoveOther', (homemessage) => {
            socket.broadcast.emit('AcceRemoveOther', homemessage);
        });

        // Vehicle Ride Time Update
        socket.on('Vehicle_Time_update', async (homemessage) => {
            try {
                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                let date = await AllFunction.TimeUpdate(homemessage, hostname, protocol);
                if (date === true) socket.broadcast.emit(`Vehicle_Time_update${homemessage.c_id}`, homemessage);
            } catch (error) {
                console.error('Vehicle_Time_update error:', error);
            }
        });

        // Vehicle Ride Time Over Request
        socket.on('Vehicle_Time_Request', async (homemessage) => {
            socket.broadcast.emit(`Vehicle_Time_Request${homemessage.d_id}`, homemessage);
        });

        // Driver Request Accept And Cancel
        socket.on('Vehicle_Accept_Cancel', async (homemessage) => {
            try {
                const { uid, request_id, c_id } = homemessage;

                const missingField = await AllFunction.CheckSocketData(homemessage, ["uid", "request_id", "c_id"]);
                if (!missingField) socket.broadcast.emit(`Vehicle_Accept_Cancel${c_id}`, { request_id, d_id: uid });
            } catch (error) {
                console.error('Vehicle_Accept_Cancel error:', error);
            }
        });

        // Rider Pick Customer
        socket.on('Vehicle_D_IAmHere', (homemessage) => {
            socket.broadcast.emit('Vehicle_D_IAmHere', homemessage);
        });

        // Rider Cancel
        socket.on('Vehicle_Ride_Cancel', (homemessage) => {
            socket.broadcast.emit('Vehicle_Ride_Cancel', homemessage);
        });

        // Rider OTP
        socket.on('Vehicle_Ride_OTP', (homemessage) => {
            socket.broadcast.emit('Vehicle_Ride_OTP', homemessage);
        });

        // Rider Start And End
        socket.on('Vehicle_Ride_Start_End', async (homemessage) => {
            try {
                const { uid, c_id, request_id } = homemessage;

                if (!uid || !c_id || !request_id) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                let dropdata = await AllFunction.VehicleRideStartEndData(uid, c_id, request_id);
                let ddata = await AllFunction.SendDriverLatLong(uid);

                socket.broadcast.emit(`Vehicle_Ride_Start_End${c_id}`, dropdata);

                if (ddata.driver && ddata.driver.length > 0 && ddata.data && ddata.data.length > 0) {
                    let d = ddata.data;
                    for (let i = 0; i < d.length && i < 50; i++) {
                        socket.broadcast.emit(`V_Driver_Location${d[i].c_id}`, {
                            d_id: uid,
                            driver_location: ddata.driver[0]
                        });
                    }
                }

                if (dropdata.status == "7") {
                    const hostname = socket.request.headers.host;
                    const protocol = socket.request.connection.encrypted ? 'https' : 'http';
                    const payment_price = await AllFunction.VehiclePaymentCal(uid, c_id, request_id, 2, hostname, protocol);

                    if (payment_price == "1" || !payment_price) {
                        socket.broadcast.emit(`Vehicle_Ride_Payment${c_id}`, {
                            ResponseCode: 401,
                            Result: false,
                            message: 'Request Not Found!'
                        });
                    } else if (payment_price == "2") {
                        socket.broadcast.emit(`Vehicle_Ride_Payment${c_id}`, {
                            ResponseCode: 401,
                            Result: false,
                            message: 'Please Complete Other Step!'
                        });
                    } else if (payment_price == "3" || payment_price == "4") {
                        socket.broadcast.emit(`Vehicle_Ride_Payment${c_id}`, {
                            ResponseCode: 401,
                            Result: false,
                            message: 'Something went wrong'
                        });
                    } else {
                        socket.broadcast.emit(`Vehicle_Ride_Payment${c_id}`, {
                            ResponseCode: 200,
                            Result: true,
                            message: "Ride Complete Successful",
                            price_list: payment_price.price_list,
                            payment_data: payment_price.payment,
                            review_list: payment_price.review_list
                        });
                    }
                }
            } catch (error) {
                console.error('Vehicle_Ride_Start_End error:', error);
                socket.emit('error', { message: 'Ride start/end error occurred' });
            }
        });

        // Drop Location
        socket.on('drop_location_list', async (homemessage) => {
            try {
                const { d_id, c_id, r_id } = homemessage;

                if (!d_id || !c_id || !r_id) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                let dropdata = await AllFunction.VehicleRideStartEndData(d_id, c_id, r_id);
                socket.emit(`drop_location${c_id}`, dropdata);
            } catch (error) {
                console.error('drop_location_list error:', error);
                socket.emit('error', { message: 'Drop location error occurred' });
            }
        });

        // Payment Method Change
        socket.on('Vehicle_P_Change', async (homemessage) => {
            try {
                if (!homemessage.payment_id || !homemessage.d_id || !homemessage.userid) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                const payment = await DataFind(`SELECT id, image, name FROM tbl_payment_detail WHERE id = '${homemessage.payment_id}' AND status = '1' LIMIT 1`);

                if (payment && payment.length > 0) {
                    await DataUpdate(`tbl_cart_vehicle`, `payment_id = '${payment[0].id}'`,
                        `d_id = '${homemessage.d_id}' AND c_id = '${homemessage.userid}'`,
                        socket.request.headers.host,
                        socket.request.connection.encrypted ? 'https' : 'http');

                    socket.broadcast.emit(`Vehicle_P_Change${homemessage.d_id}`, { payment_data: payment[0] });
                }
            } catch (error) {
                console.error('Vehicle_P_Change error:', error);
                socket.emit('error', { message: 'Payment change error occurred' });
            }
        });
        socket.on('driver_accept_ride', async (data) => {

            console.log('🚗 Driver accepting ride via socket:', data);



            try {

                const { uid, request_id, lat, lon } = data;



                if (!uid || !request_id || !lat || !lon) {

                    return socket.emit('error', { message: 'Missing required fields' });

                }



                // Find the request first

                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}'`);



                if (!request || request.length === 0) {

                    return socket.emit('accept_error', {

                        message: 'Request not found',

                        request_id

                    });

                }



                const requestData = request[0];



                // Check if driver is authorized

                let driverList = requestData.d_id;

                if (typeof driverList === 'string') {

                    driverList = JSON.parse(driverList);

                }



                if (!driverList.includes(parseInt(uid))) {

                    return socket.emit('accept_error', {

                        message: 'Driver not authorized',

                        request_id

                    });

                }



                // Make HTTP request to your accept endpoint

                const hostname = socket.request.headers.host;

                const protocol = socket.request.connection.encrypted ? 'https' : 'http';



                try {

                    const response = await fetch(`${protocol}://${hostname}/driver/accept_vehicle_ride`, {

                        method: 'POST',

                        headers: {

                            'Content-Type': 'application/json',

                        },

                        body: JSON.stringify({ uid, request_id, lat, lon })

                    });



                    const result = await response.json();



                    if (result.Result) {

                        console.log(`✅ Ride accepted via socket: ${result.requestid}`);



                        // Emit success events to customer

                        socket.emit(`acceptvehrequest${requestData.c_id}`, {

                            uid: uid,

                            request_id: result.requestid,

                            c_id: requestData.c_id,

                            status: 'accepted'

                        });



                        // Emit driver arrival notification

                        socket.emit(`Vehicle_D_IAmHere`, {

                            uid: uid,

                            request_id: result.requestid,

                            c_id: requestData.c_id,

                            pickuptime: 5 // estimated pickup time

                        });



                        console.log(`✅ Socket events emitted for ride acceptance`);

                    } else {

                        console.error(`❌ Ride acceptance failed:`, result.message);

                        socket.emit('accept_error', {

                            message: result.message,

                            request_id

                        });

                    }



                } catch (fetchError) {

                    console.error('💥 HTTP request error:', fetchError);

                    socket.emit('accept_error', {

                        message: 'Server error during acceptance',

                        request_id

                    });

                }



            } catch (error) {

                console.error('💥 Socket driver accept error:', error);

                socket.emit('accept_error', {

                    message: 'Socket error occurred',

                    request_id: data.request_id

                });

            }

        });

        // Payment Successful And Complete Ride
        socket.on('Vehicle_Ride_Complete', async (homemessage) => {
            if (homemessage && homemessage.d_id) {
                socket.broadcast.emit(`Vehicle_Ride_Complete${homemessage.d_id}`, homemessage);
            }
        });

        // Save Chat
        socket.on('Send_Chat', async (homemessage) => {
            try {
                const { sender_id, recevier_id, message, status } = homemessage;

                if (!sender_id || !recevier_id || !message || !status) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                let date = await AllChat.Chat_Save(sender_id, sender_id, recevier_id, message, status, hostname, protocol);

                if (date && date !== false) {
                    if (status == "customer") {
                        socket.broadcast.emit(`Send_Chat${recevier_id}`, date);
                    } else {
                        socket.broadcast.emit(`Send_Chat${recevier_id}`, date);
                    }
                }
            } catch (error) {
                console.error('Send_Chat error:', error);
                socket.emit('error', { message: 'Chat error occurred' });
            }
        });


        //==========================================================================================
        //==========================================================================================
        //==========================================================================================

        //==========================================================================================
        //==========================================================================================
        //==========================================================================================


        socket.on('load_bidding_data', async (data) => {
            try {
                const { uid, request_id, d_id } = data;
                console.log('🔄 Loading bidding data:', { uid, request_id, d_id });

                if (!uid || !request_id) {
                    return socket.emit('error', { message: 'Missing required fields for load_bidding_data' });
                }

                // Find the request
                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                if (!request || request.length === 0) {
                    console.log('❌ Request not found for load_bidding_data');
                    return socket.emit(`Vehicle_Bidding${uid}`, {
                        bidding_list: [],
                        off_ex_time: 0
                    });
                }

                const requestData = request[0];

                // Check if bidding is still active
                if (requestData.bidding_status !== '1') {
                    return socket.emit(`Vehicle_Bidding${uid}`, {
                        bidding_list: [],
                        off_ex_time: 0
                    });
                }

                // Parse bidding prices and calculate time remaining
                const biddingPrices = requestData.bidding_d_price || '';
                const driverIds = typeof requestData.d_id === 'string' ? JSON.parse(requestData.d_id) : requestData.d_id;

                let bidding_list = [];
                let currentTime = new Date();

                // Get general settings for offer expire time
                const general = await DataFind(`SELECT offer_expire_time FROM tbl_general_settings`);
                const offerExpireTime = general[0]?.offer_expire_time || 60;

                if (biddingPrices && biddingPrices.length > 0) {
                    // Parse existing bidding data
                    const priceEntries = biddingPrices.split('&!!');

                    for (let entry of priceEntries) {
                        const parts = entry.split('&');
                        if (parts.length >= 3) {
                            const price = parts[0];
                            const driverId = parts[1];
                            const timestamp = parts[2];

                            // Calculate remaining time
                            const bidTime = new Date(timestamp);
                            const timeElapsed = Math.floor((currentTime - bidTime) / 1000);
                            const timeRemaining = Math.max(0, offerExpireTime - timeElapsed);

                            if (timeRemaining > 0) {
                                // Get driver details
                                const driver = await DataFind(`SELECT dr.id, dr.first_name, dr.last_name, dr.profile_image,
                                                      COALESCE(ve.map_img, '') as image, COALESCE(ve.name, '') as vehicle_name,
                                                      dr.latitude, dr.longitude, '5.0' as rating, '0.5' as distance
                                                      FROM tbl_driver dr
                                                      LEFT JOIN tbl_vehicle ve ON dr.vehicle = ve.id
                                                      WHERE dr.id = '${driverId}'`);

                                if (driver && driver.length > 0) {
                                    bidding_list.push({
                                        id: parseInt(driverId),
                                        name: `${driver[0].first_name} ${driver[0].last_name}`,
                                        profile_image: driver[0].profile_image,
                                        image: driver[0].image,
                                        vehicle_name: driver[0].vehicle_name,
                                        price: parseFloat(price),
                                        rating: driver[0].rating,
                                        distance: driver[0].distance,
                                        latitude: driver[0].latitude,
                                        longitude: driver[0].longitude,
                                        diff_second: timeRemaining
                                    });
                                }
                            }
                        }
                    }
                }

                console.log(`📊 Loaded ${bidding_list.length} active bids for request ${request_id}`);

                // Send response
                socket.emit(`Vehicle_Bidding${uid}`, {
                    bidding_list: bidding_list,
                    off_ex_time: bidding_list.length > 0 ? Math.max(...bidding_list.map(b => b.diff_second)) : 0
                });

            } catch (error) {
                console.error('💥 Load bidding data error:', error);
                socket.emit('error', { message: 'Error loading bidding data' });
            }
        });

        // Customer remove data - when no drivers left or request expires
        socket.on('removecustomerdata', async (data) => {
            try {
                const { uid, request_id } = data;

                if (!uid || !request_id) {
                    return;
                }

                console.log('🗑️ Removing customer data:', { uid, request_id });

                // Find and remove the request
                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                if (request && request.length > 0) {
                    // Remove from database
                    await DataDelete(`tbl_request_vehicle`, `id = '${request_id}' AND c_id = '${uid}'`);

                    // Notify customer
                    socket.emit(`removecustomerdata${uid}`, {
                        request_id: parseInt(request_id),
                        index: 0,
                        message: 'Request removed due to timeout or no available drivers'
                    });
                }

            } catch (error) {
                console.error('💥 Remove customer data error:', error);
            }
        });

        // Driver bid decline by customer
        socket.on('decline_driver_bid', async (data) => {
            try {
                const { uid, driver_id, request_id } = data;

                console.log('❌ Customer declining driver bid:', { uid, driver_id, request_id });

                if (!uid || !driver_id || !request_id) {
                    return socket.emit('error', { message: 'Missing required fields' });
                }

                // Find request
                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                if (!request || request.length === 0) {
                    return;
                }

                // Remove driver from bidding list
                let driverList = request[0].d_id;
                if (typeof driverList === 'string') {
                    driverList = JSON.parse(driverList);
                }

                const updatedDriverList = driverList.filter(id => id != driver_id);

                // Update bidding prices to remove this driver's bid
                let biddingPrices = request[0].bidding_d_price || '';
                let updatedBiddingPrices = '';

                if (biddingPrices) {
                    const priceEntries = biddingPrices.split('&!!');
                    const filteredEntries = priceEntries.filter(entry => {
                        const parts = entry.split('&');
                        return parts.length >= 2 && parts[1] != driver_id;
                    });
                    updatedBiddingPrices = filteredEntries.join('&!!');
                }

                // Update database
                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                await DataUpdate(
                    'tbl_request_vehicle',
                    `d_id = '${JSON.stringify(updatedDriverList)}', bidding_d_price = '${updatedBiddingPrices}'`,
                    `id = '${request_id}'`,
                    hostname,
                    protocol
                );

                // Notify customer of successful decline
                socket.emit(`Bidding_decline_Response${uid}`, {
                    success: true,
                    driver_id: parseInt(driver_id),
                    remaining_drivers: updatedDriverList.length
                });

                // If no drivers left, remove request
                if (updatedDriverList.length === 0) {
                    setTimeout(() => {
                        socket.emit(`removecustomerdata${uid}`, {
                            request_id: parseInt(request_id),
                            index: 0
                        });
                    }, 1000);
                }

            } catch (error) {
                console.error('💥 Decline driver bid error:', error);
            }
        });

        // Enhanced Vehicle Bidding Response - for real-time updates
        socket.on('bidding_status_check', async (data) => {
            try {
                const { uid, request_id } = data;

                if (!uid || !request_id) {
                    return;
                }

                const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

                if (!request || request.length === 0) {
                    // Request not found - might have been accepted or cancelled
                    return socket.emit(`Vehicle_Bidding${uid}`, {
                        bidding_list: [],
                        off_ex_time: 0,
                        status: 'completed'
                    });
                }

                // Request still active - load current bidding data
                socket.emit('load_bidding_data', { uid, request_id });

            } catch (error) {
                console.error('💥 Bidding status check error:', error);
            }
        });

        // Request timeout handler
        socket.on('request_timeout', async (data) => {
            try {
                const { uid, request_id, driver_list } = data;

                console.log('⏰ Request timeout:', { uid, request_id });

                if (!uid || !request_id) {
                    return;
                }

                // Update request status to timeout
                const hostname = socket.request.headers.host;
                const protocol = socket.request.connection.encrypted ? 'https' : 'http';

                await DataUpdate(
                    'tbl_request_vehicle',
                    `status = '0', d_id = '[]'`,
                    `id = '${request_id}' AND c_id = '${uid}'`,
                    hostname,
                    protocol
                );

                // Notify customer
                socket.emit(`RequestTimeOut${uid}`, {
                    request_id: parseInt(request_id),
                    driver_list: driver_list || []
                });

                // Remove customer data
                setTimeout(() => {
                    socket.emit(`removecustomerdata${uid}`, {
                        request_id: parseInt(request_id),
                        index: 0,
                        type: 'timeout'
                    });
                }, 2000);

            } catch (error) {
                console.error('💥 Request timeout error:', error);
            }
        });

        // New ride request notification to drivers
        socket.on('notify_drivers_new_request', async (data) => {
            try {
                const { driver_ids, request_data } = data;

                if (!driver_ids || !Array.isArray(driver_ids)) {
                    return;
                }

                console.log(`📢 Notifying ${driver_ids.length} drivers of new request`);

                // Notify each driver
                driver_ids.forEach(driverId => {
                    socket.broadcast.emit(`new_ride_request${driverId}`, {
                        request_id: request_data.id,
                        customer_name: request_data.customer_name,
                        pickup_address: request_data.pickup_address,
                        drop_address: request_data.drop_address,
                        estimated_fare: request_data.price,
                        distance: request_data.distance
                    });
                });

            } catch (error) {
                console.error('💥 Notify drivers error:', error);
            }
        });


    });




    // FIXED: Add server-level error handling
    io.engine.on("connection_error", (err) => {
        console.log('Connection error:', err.req);
        console.log('Error code:', err.code);
        console.log('Error message:', err.message);
        console.log('Error context:', err.context);
    });

    // FIXED: Monitor active connections and schedules
    setInterval(() => {
        console.log(`Active connections: ${connectedSockets.size}, Active schedules: ${activeSchedules.size}`);

        // Force cleanup if too many schedules
        if (activeSchedules.size > 1000) {
            console.warn('Too many active schedules, forcing cleanup');
            cleanupSchedules();
        }
    }, 60000); // Every minute
}

module.exports = { publicsocket };














/* jshint esversion: 6 */
/* jshint esversion: 8 */
/* jshint node: true */



const express = require("express");
const router = express.Router();
const multer = require('multer');
const mysql = require("mysql2");
const bcrypt = require('bcrypt');
const axios = require('axios');
const AllFunction = require("../route_function/function");
const sendOneNotification = require("../middleware/send");
const { checkedit } = require("../public/js/editor/ckeditor/adapters/check");
const { DataFind, DataInsert, DataUpdate, DataDelete } = require("../middleware/databse_query");

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, "./public/uploads/payment_proof");
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + file.originalname);

    }
});

const upload = multer({ storage: storage });

const storage1 = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, "./public/uploads/customer_profile");
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + file.originalname);

    }
});

const customer_profile = multer({ storage: storage1 });



router.post("/signup", async (req, res) => {
    try {
        const { name, email, ccode, phone, password, referral_code } = req.body;

        const missingField = ["name", "email", "ccode", "phone", 'password'].find(field => !req.body[field]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' })

        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);
        const general = await DataFind(`SELECT refer_credit, one_app_id, one_api_key FROM tbl_general_settings`);
        let generald = { one_app_id: general[0].one_app_id, one_api_key: general[0].one_api_key }
        if (cus_data != "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'PhoneNo Already Exists!', general: generald })

        let esname = mysql.escape(name);
        const hash = await bcrypt.hash(password, 10);
        let otp_result = await AllFunction.otpGenerate(6);

        if (referral_code != "") {
            const referal_customer = await DataFind(`SELECT id, wallet FROM tbl_customer WHERE referral_code = '${referral_code}'`);
            if (referal_customer != "") {
                let amount = parseFloat(referal_customer[0].wallet) + parseFloat(general[0].refer_credit);

                if (await DataUpdate(`tbl_customer`, `wallet = '${amount}'`, `id = '${referal_customer[0].id}'`, req.hostname, req.protocol) == -1) {
                    return res.status(200).json({ message: process.env.dataerror, status: false });
                }

                let fulldate = await AllFunction.TodatDate();
                if (await DataInsert(`tbl_transaction_customer`, `c_id, payment_id, amount, date, status, type`,
                    `${referal_customer[0].id}, '0', '${general[0].refer_credit}', '${fulldate.date}T${fulldate.time}', '1', ''`, req.hostname, req.protocol) == -1) {
                    return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
                }
            }
        }

        const date = new Date().toISOString().split('T');
        if (await DataInsert(`tbl_customer`, `profile_image, name, email, country_code, phone, password, status, referral_code, wallet, date`,
            `'', ${esname}, '${email}', '${ccode}', '${phone}', '${hash}', '1', '${otp_result}', '0', '${date}'`, req.hostname, req.protocol) == -1) {

            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }
        const new_cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Signup successful', general: generald, customer_data: new_cus_data[0] });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/edit_customer", customer_profile.single("profile_img"), async (req, res) => {
    try {
        const { id, name, email, password } = req.body;

        const missingField = ["id", "name", "email"].find(field => !req.body[field]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let esname = mysql.escape(name), pass, imageUrl = "";
        const passw = await DataFind(`SELECT profile_image, password FROM tbl_customer WHERE id = '${id}'`);
        if (!password) pass = passw[0].password
        else pass = await bcrypt.hash(password, 10);

        imageUrl = req.file ? "uploads/customer_profile/" + req.file.filename : passw[0].profile_image;

        if (await DataUpdate(`tbl_customer`, `profile_image = '${imageUrl}', name = ${esname}, email = '${email}', password = '${pass}'`, `id = '${id}'`, req.hostname, req.protocol) == -1) {
            req.flash('errors', process.env.dataerror);
            return res.redirect("/valid_license");
        }
        const customer_data = await DataFind(`SELECT * FROM tbl_customer WHERE id = '${id}'`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Profile Update Successful', customer_data: customer_data[0] });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/login", async (req, res) => {
    try {
        const { ccode, phone, password } = req.body;

        const missingField = ["ccode", "phone", 'password'].find(field => !req.body[field]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' })

        const general = await DataFind(`SELECT one_app_id, one_api_key FROM tbl_general_settings`);
        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

        if (cus_data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Not Exists!", general: general[0] });

        if (cus_data[0].status != "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: "Account Deactivated", general: general[0] });

        const hash_pass = await bcrypt.compare(password, cus_data[0].password);

        if (!hash_pass) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: "Password Not match", general: general[0] });
        } else {
            return res.status(200).json({ ResponseCode: 200, Result: true, message: "Login Sccessful", general: general[0], customer_data: cus_data[0] });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/mobile_check", async (req, res) => {
    try {
        const { ccode, phone } = req.body;

        if (ccode == "" || phone == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

        if (cus_data == "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "New Number" });
        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Already Exist" });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/forgot_password", async (req, res) => {
    try {
        const { ccode, phone, password } = req.body;

        if (ccode == "" || phone == "" || password == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

        const cus_data = await DataFind(`SELECT * FROM tbl_customer WHERE country_code = '${ccode}' AND phone = '${phone}'`);

        if (cus_data == "") {
            res.status(200).json({ ResponseCode: 401, Result: false, message: "PhoneNo Not Exist" });
        } else {
            const hash = await bcrypt.hash(password, 10);

            if (await DataUpdate(`tbl_customer`, `password = '${hash}'`, `id = '${cus_data[0].id}'`, req.hostname, req.protocol) == -1) {

                return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
            }
            res.status(200).json({ ResponseCode: 200, Result: true, message: 'Password Change successful' });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.get("/otp_detail", async (req, res) => {
    try {
        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

        let sms_type = ""
        if (general_setting[0].sms_type == "1") {
            sms_type = "MSG91"
        } else if (general_setting[0].sms_type == "2") {
            sms_type = "Twilio"
        } else {
            sms_type = "No Auth"
        }

        if (sms_type != "") res.status(200).json({ ResponseCode: 200, Result: true, message: sms_type });
        else res.status(200).json({ ResponseCode: 401, Result: false, message: 'Data Not Found' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/msg91", async (req, res) => {
    try {
        const { phoneno } = req.body;

        if (phoneno == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

        let otp_result = await AllFunction.otpGenerate(6)

        let auth_key = general_setting[0].msg_key;
        let template_id = general_setting[0].msg_token;

        let pho_no = phoneno;
        const options = {
            method: 'POST',
            url: 'https://control.msg91.com/api/v5/otp?template_id=' + template_id + '&mobile=' + pho_no + '&otp=' + otp_result,
            headers: {
                accept: 'application/json',
                'content-type': 'application/json',
                authkey: auth_key
            },
            data: { Param1: 'value1' }
        };

        axios.request(options)
            .then(function (response) {
                console.log(response.data);
                res.status(200).json({ ResponseCode: 200, Result: true, message: "Otp Send successful", otp: otp_result });
            })
            .catch(function (error) {
                console.error(error);
                res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
            });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/twilio", async (req, res) => {
    try {
        const { phoneno } = req.body;

        if (phoneno == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong!' });

        const general_setting = await DataFind(`SELECT * FROM tbl_general_settings`);

        let otp_result = await AllFunction.otpGenerate(6)

        let accountSid = general_setting[0].twilio_sid;
        let authToken = general_setting[0].twilio_token;

        const client = require('twilio')(accountSid, authToken);

        client.messages.create({
            body: 'Your ' + general_setting[0].title + ' otp is ' + otp_result + '',
            from: general_setting[0].twilio_phoneno,
            to: phoneno
        })
            .then(message => {
                console.log(message.sid);
                res.status(200).json({ ResponseCode: 200, Result: true, message: "Otp Send successful", otp: otp_result });
            })
            .catch((error) => {
                console.log(error);
                res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
            });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/home", async (req, res) => {
    try {
        const { uid, lat, lon } = req.body;

        if (uid == "" || lat == "" || lon == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const general = await DataFind(`SELECT site_currency, offer_expire_time FROM tbl_general_settings`);
        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1'`);
        vehicle_list.map(vvel => { vvel.role = "1" });

        let module_setting = await DataFind(`SELECT * FROM tbl_module_setting`);
        module_setting.map(ovel => {
            ovel.bidding = "0"
            ovel.role = (parseFloat(ovel.id) + parseFloat(1)).toString()
        });

        let package_list = await DataFind(`SELECT id, image, name, description FROM tbl_package`);
        package_list.map(rvel => {
            rvel.bidding = "0"
            rvel.role = "4"
        });

        const category_list = [...vehicle_list];

        let dr = await AllFunction.CustomerReview("cus");
        const cus_rating = await DataFind(`SELECT cus.id ${dr.tot_review} ${dr.avgstar}
                                            FROM tbl_customer AS cus
                                            ${dr.outtable}
                                            WHERE cus.id = '${uid}' GROUP BY cus.id ORDER BY id DESC`);

        let rdata = await DataFind(`SELECT veh.*, COALESCE(vec.minimum_fare, '') as minimum_fare, COALESCE(vec.maximum_fare, '') as maximum_fare
                                        FROM tbl_request_vehicle AS veh
                                        JOIN tbl_vehicle AS vec ON veh.vehicleid = vec.id
                                        WHERE c_id = '${uid}' ORDER BY id DESC LIMIT 1`);

        if (rdata != '') {
            let rd = await AllFunction.VehicleAllRide(rdata[0], 2);

            let pickapp = { title: rd.piclatlon.title, subtitle: rd.piclatlon.subtitle }, picklat = { latitude: rd.piclatlon.latitude, longitude: rd.piclatlon.longitude };
            let drop_add = { title: '', subtitle: '' }, drop_latlon = { latitude: '', longitude: '' }, daddlist = [], dlatlist = [];
            for (let i = 0; i < rd.dropdata.length;) {
                if (i == 0) {
                    drop_add = { title: rd.dropdata[i].title, subtitle: rd.dropdata[i].subtitle };
                    drop_latlon = { latitude: rd.dropdata[i].latitude, longitude: rd.dropdata[i].longitude };
                } else {
                    daddlist.push({ title: rd.dropdata[i].title, subtitle: rd.dropdata[i].subtitle });
                    dlatlist.push({ latitude: rd.dropdata[i].latitude, longitude: rd.dropdata[i].longitude });
                }
                i++;
            }

            if (typeof rdata[0].d_id == "string") rdata[0].d_id = JSON.parse(rdata[0].d_id);
            let runtime = await AllFunction.CurrentDatetoOldDateS(rdata[0].start_time, general[0].offer_expire_time);

            rdata[0].pick_add = pickapp; rdata[0].pick_latlon = picklat; rdata[0].drop_add = drop_add; rdata[0].drop_latlon = drop_latlon; rdata[0].drop_add_list = daddlist; rdata[0].drop_latlon_list = dlatlist;
            rdata[0].bidding_run_status = rdata[0].bidding_d_price != '' ? 1 : 0; rdata[0].increased_time = runtime > 0 ? runtime : 0;
            rdata[0].price = Number(rdata[0].price); rdata[0].tot_km = Number(rdata[0].tot_km);

            delete rdata[0].pic_lat_long; delete rdata[0].drop_lat_long; delete rdata[0].pic_address; delete rdata[0].drop_address; delete rdata[0].status_time_location;
            delete rdata[0].bidding_d_price;
        }

        return res.status(200).json({
            ResponseCode: 200, Result: true, message: "Data Load successful", general: { site_currency: general[0].site_currency }, cus_rating: cus_rating[0],
            category_list, runnig_ride: rdata
        });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})




router.post("/vehicle_information", async (req, res) => {
    try {
        const { vehicle_id } = req.body;

        // FIX 1: Add validation to prevent bad data
        if (!vehicle_id) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle ID is required.' });
        }

        // FIX 2: Use a secure, parameterized query
        const sql = `SELECT id, image, name, description, passenger_capacity FROM tbl_vehicle WHERE id = ? AND status = '1'`;
        const vehicle_list = await DataFind(sql, [vehicle_id]);

        if (vehicle_list && vehicle_list.length > 0) {
            return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", vehicle: vehicle_list[0] });
        } else {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: "Vehicle Not Found!" });
        }
    } catch (error) {
        console.error("Error in /vehicle_information:", error);
        res.status(500).json({ error: 'Internal server error' });
    }
});




router.post("/home_wallet", async (req, res) => {
    try {
        const { uid } = req.body;
        if (uid == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const driver = await DataFind(`SELECT wallet FROM tbl_customer WHERE id = '${uid}'`);
        if (driver == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer Not Found!' });

        let walletp = "0";
        if (typeof parseFloat(driver[0].wallet) == "Number" || driver[0].wallet) {
            walletp = driver[0].wallet
        } else walletp = "0"

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", wallet_amount: driver[0].wallet });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/home_mape", async (req, res) => {
    try {
        const { mid, lat, lon } = req.body;

        // Validate required parameters
        if (!lat || !lon) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Latitude and longitude are required'
            });
        }

        console.log('Request params:', { mid, lat, lon });

        // Get general settings
        const general = await DataFind(`SELECT site_currency, vehicle_radius FROM tbl_general_settings`);
        if (!general || general.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'General settings not found'
            });
        }

        // Check zone
        let convertzone = [{ latitude: Number(lat), longitude: Number(lon) }];
        let dzone = await AllFunction.ZoneData();
        let zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

        console.log('Zone check result:', {
            zoneResult: zonecheck[1]?.zc,
            zoneIds: zonecheck[2]?.zid
        });

        if (zonecheck[1].zc != "0") {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Location is not in the zone!'
            });
        }

        // Determine vehicle ID
        let v_id;
        if (!mid || mid === "" || mid === "0") {
            let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1' ORDER BY id LIMIT 1`);
            if (!vehicle_list || vehicle_list.length === 0) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'No active vehicles found'
                });
            }
            v_id = vehicle_list[0].id;
        } else {
            v_id = mid;
        }

        console.log('Using vehicle ID:', v_id);

        // First, check if the vehicle exists and is active
        const vehicleCheck = await DataFind(`SELECT id, name FROM tbl_vehicle WHERE id = '${v_id}' AND status = '1'`);
        if (!vehicleCheck || vehicleCheck.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Vehicle not found or inactive'
            });
        }

        // Build zone condition - handle both single values and comma-separated values
        const zoneIds = zonecheck[2].zid;
        let zoneCondition = '';
        if (Array.isArray(zoneIds)) {
            // Handle multiple zones - check if zone contains any of these IDs
            const zoneChecks = zoneIds.map(zid =>
                `(zone = '${zid}' OR zone LIKE '%,${zid},%' OR zone LIKE '${zid},%' OR zone LIKE '%,${zid}')`
            ).join(' OR ');
            zoneCondition = `(${zoneChecks})`;
        } else {
            // Handle single zone
            zoneCondition = `(zone = '${zoneIds}' OR zone LIKE '%,${zoneIds},%' OR zone LIKE '${zoneIds},%' OR zone LIKE '%,${zoneIds}')`;
        }

        // Build vehicle condition - handle both direct ID match and comma-separated values
        const vehicleCondition = `(vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')`;

        // Updated driver query - simpler approach without complex aliases
        const driverQuery = `SELECT d.id,
                                COALESCE(v.map_img, '') AS image,
                                COALESCE(v.name, '') AS name,
                                COALESCE(v.description, '') AS description,
                                COALESCE(d.latitude, '') AS latitude,
                                COALESCE(d.longitude, '') AS longitude,
                                d.zone, d.vehicle, d.fstatus, d.status, d.approval_status
                                FROM tbl_driver d
                                LEFT JOIN tbl_vehicle v ON v.id = '${v_id}'
                                WHERE ${zoneCondition}
                                AND ${vehicleCondition}
                                AND d.fstatus = '1'
                                AND d.status = '1'
                                AND d.approval_status = '1'
                                AND d.latitude IS NOT NULL
                                AND d.latitude != ''
                                AND d.longitude IS NOT NULL
                                AND d.longitude != ''
                                AND v.status = '1'`;

        console.log('Driver query:', driverQuery);

        const driver = await DataFind(driverQuery);
        console.log('Total drivers found:', driver ? driver.length : 0);

        if (!driver || driver.length === 0) {
            // Enhanced debug info
            const debugInfo = {};

            // Check drivers with matching vehicle (regardless of zone)
            const vehicleDrivers = await DataFind(`SELECT id, zone, vehicle, latitude, longitude, status, fstatus, approval_status
                                                    FROM tbl_driver
                                                    WHERE (vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')
                                                    AND status = '1'`);
            debugInfo.driversWithMatchingVehicle = vehicleDrivers;

            // Check drivers in requested zone (regardless of vehicle)
            const zoneDrivers = await DataFind(`SELECT id, zone, vehicle, latitude, longitude
                                                FROM tbl_driver
                                                WHERE ${zoneCondition}
                                                AND status = '1'
                                                AND fstatus = '1'
                                                AND approval_status = '1'`);
            debugInfo.driversInRequestedZone = zoneDrivers;

            console.log('Enhanced debug info:', debugInfo);

            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No drivers found in your zone for this vehicle type',
                driverid: [],
                list: [],
                debug: {
                    vehicleId: v_id,
                    requestedZoneIds: zonecheck[2].zid,
                    searchLocation: { lat, lon },
                    ...debugInfo,
                    suggestion: "Check if driver zones match your location's zone assignment"
                }
            });
        }

        // Filter drivers by radius
        let list = [], point = { latitude: Number(lat), longitude: Number(lon) }, driverid = [];
        const radiusMeters = Number(parseFloat(general[0].vehicle_radius) * parseFloat(1000));

        console.log('Checking radius:', radiusMeters, 'meters');
        console.log('Search point:', point);

        for (let i = 0; i < driver.length; i++) {
            // Validate driver coordinates
            const driverLat = parseFloat(driver[i].latitude);
            const driverLon = parseFloat(driver[i].longitude);

            if (isNaN(driverLat) || isNaN(driverLon)) {
                console.log(`Driver ${driver[i].id}: Invalid coordinates - lat: ${driver[i].latitude}, lon: ${driver[i].longitude}`);
                continue;
            }

            let dlotlon = {
                latitude: driverLat,
                longitude: driverLon
            };

            console.log(`Driver ${driver[i].id}: Coordinates - lat: ${driverLat}, lon: ${driverLon}`);

            let distance = await AllFunction.RadiusCheck(point, dlotlon, radiusMeters);
            console.log(`Driver ${driver[i].id}: distance check result = ${distance}`);

            if (distance == 1) {
                driverid.push(driver[i].id);
                list.push({
                    id: driver[i].id,
                    image: driver[i].image,
                    name: driver[i].name,
                    description: driver[i].description,
                    latitude: driver[i].latitude,
                    longitude: driver[i].longitude
                });
            }
        }

        console.log('Final results:', { driverCount: list.length, driverIds: driverid });

        if (list.length === 0) {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No drivers found within radius',
                driverid: [],
                list: [],
                debug: {
                    totalDriversInZone: driver.length,
                    radiusMeters: radiusMeters,
                    searchPoint: point,
                    driverCoordinates: driver.map(d => ({
                        id: d.id,
                        lat: d.latitude,
                        lon: d.longitude
                    }))
                }
            });
        }

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: "Data loaded successfully",
            zone_id: zonecheck[2].zid[0],
            driverid,
            list
        });

    } catch (error) {
        console.error('Error in home_mape:', error);
        res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
});

router.post("/calculate", async (req, res) => {
    try {
        const { uid, mid, mrole, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

        // Validate required fields
        const missingField = ["uid", 'mid', 'mrole', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
        if (missingField) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Something went wrong missing fields',
                missing_field: missingField
            });
        }

        console.log(`🚗 Calculate API called for mrole: ${mrole}`);
        console.log(`📍 Pickup: ${pickup_lat_lon}`);
        console.log(`📍 Drop: ${drop_lat_lon}`);
        console.log(`📍 Additional drops: ${JSON.stringify(drop_lat_lon_list)}`);

        if (mrole == "1") {
            // Get vehicle details with validation
            let vehicle = await DataFind(`SELECT * FROM tbl_vehicle WHERE status = '1' AND id = '${mid}'`);
            if (vehicle == "" || vehicle.length === 0) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Vehicle Not Found!'
                });
            }

            console.log(`🚙 Vehicle found: ${vehicle[0].name} (ID: ${vehicle[0].id})`);

            // Convert coordinates to zone format with validation
            let convertzone;
            try {
                convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);
                console.log("📍 Converted zones:", JSON.stringify(convertzone, null, 2));
            } catch (zoneError) {
                console.log("❌ Zone conversion error:", zoneError.message);
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Invalid coordinates format'
                });
            }

            // Validate converted zones
            if (!convertzone || convertzone.length < 2) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Invalid coordinate conversion'
                });
            }

            // Get zone data and check if coordinates are in service zones
            let dzone, zonecheck;
            try {
                dzone = await AllFunction.ZoneData();
                zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);
                console.log("🔍 Zone check result:", JSON.stringify(zonecheck, null, 2));
            } catch (zoneCheckError) {
                console.log("❌ Zone check error:", zoneCheckError.message);
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Zone validation failed'
                });
            }

            // Get general settings
            const general = await DataFind(`SELECT * FROM tbl_general_settings`);
            if (general == "" || general.length === 0) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Something went wrong general settings'
                });
            }

            console.log(`🔑 Google Maps API Key available: ${!!general[0].google_map_key}`);

            // Check if all points are within service zones
            if (zonecheck[1].zc != "0") {
                console.log(`❌ Zone check failed: ${zonecheck[1].zc} points outside service zone`);
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Address is not in the zone! calculate',
                    offer_expire_time: general[0].offer_expire_time,
                    zoneresult: zonecheck[0].zr,
                    tot_km: 0,
                    drop_price: 0,
                    tot_hour: 0,
                    tot_minute: 0,
                    tot_second: 0,
                    driver_id: [],
                    vehicle: []
                });
            }

            let zoneresult = zonecheck[0].zr;
            console.log("🗺️ Zone results for calculation:", JSON.stringify(zoneresult, null, 2));

            // Initialize calculation variables
            let cal = 0, totmin = 0;

            console.log(`🔧 ENHANCED FIX: Processing ${convertzone.length - 1} segments`);

            // ✅ ENHANCED LOOP: Calculate distance for each segment with better error handling
            for (let c = 0; c < convertzone.length - 1; c++) {
                console.log(`\n🔄 Processing segment ${c + 1}: from point ${c} to point ${c + 1}`);

                // Validate zone result indices
                if (c >= zoneresult.length || (c + 1) >= zoneresult.length) {
                    console.log(`❌ Zone result index out of bounds: segment ${c + 1}`);
                    continue;
                }

                // Get zone status for both points in this segment
                let startZoneStatus = zoneresult[c] ? zoneresult[c].status : 0;
                let endZoneStatus = zoneresult[c + 1] ? zoneresult[c + 1].status : 0;

                console.log(`   Point ${c} zone status: ${startZoneStatus} (type: ${typeof startZoneStatus})`);
                console.log(`   Point ${c + 1} zone status: ${endZoneStatus} (type: ${typeof endZoneStatus})`);

                // Both points must be in active zones
                if ((startZoneStatus == 1 || startZoneStatus == "1") &&
                    (endZoneStatus == 1 || endZoneStatus == "1")) {

                    // Validate coordinates before API call
                    if (!convertzone[c] || !convertzone[c + 1] ||
                        !convertzone[c].latitude || !convertzone[c].longitude ||
                        !convertzone[c + 1].latitude || !convertzone[c + 1].longitude) {
                        console.log("❌ Invalid coordinates detected in segment");
                        continue;
                    }

                    let pickup = `${convertzone[c].latitude},${convertzone[c].longitude}`;
                    let drop = `${convertzone[c + 1].latitude},${convertzone[c + 1].longitude}`;

                    console.log(`📏 Calculating distance from ${pickup} to ${drop}`);

                    try {
                        // Add timeout and retry logic for Google Maps API
                        let distance = await Promise.race([
                            AllFunction.GetDistance(pickup, drop, general[0].google_map_key),
                            new Promise((_, reject) =>
                                setTimeout(() => reject(new Error('Distance API timeout')), 10000)
                            )
                        ]);

                        console.log(`📊 Distance API result:`, JSON.stringify(distance, null, 2));

                        if (distance && distance.status === 1 && distance.dis && parseFloat(distance.dis) > 0) {
                            cal += parseFloat(distance.dis);
                            console.log(`📈 Distance added: ${distance.dis}km, Total: ${cal}km`);

                            // Enhanced duration parsing
                            if (distance.dur && typeof distance.dur === 'string') {
                                let durParts = distance.dur.toLowerCase().split(" ");
                                console.log(`⏱️ Duration: "${distance.dur}", Split: [${durParts.join(', ')}]`);

                                let minutes = 0;
                                for (let i = 0; i < durParts.length; i++) {
                                    if (durParts[i].includes('hour') || durParts[i].includes('hr')) {
                                        let hours = parseFloat(durParts[i - 1]) || 0;
                                        minutes += hours * 60;
                                    } else if (durParts[i].includes('min') || durParts[i].includes('minute')) {
                                        let mins = parseFloat(durParts[i - 1]) || 0;
                                        minutes += mins;
                                    } else if (!isNaN(parseFloat(durParts[i]))) {
                                        // If it's just a number, assume it's minutes
                                        if (i === 0 && durParts.length === 2) {
                                            minutes += parseFloat(durParts[i]);
                                        }
                                    }
                                }

                                totmin += minutes;
                                console.log(`⏱️ Added ${minutes} minutes, Total: ${totmin} minutes`);
                            }
                        } else {
                            console.log("⚠️ Invalid distance result:");
                            console.log(`   - distance exists: ${!!distance}`);
                            console.log(`   - distance.status: ${distance?.status}`);
                            console.log(`   - distance.dis: ${distance?.dis}`);
                            console.log(`   - distance.dur: ${distance?.dur}`);
                        }
                    } catch (distanceError) {
                        console.log("💥 Distance API error:", distanceError.message);

                        // Handle specific Google Maps API errors
                        if (distanceError.message.includes('timeout')) {
                            console.log("⏰ Google Maps API timeout - using fallback calculation");

                            // Fallback: Calculate approximate distance using haversine formula
                            try {
                                let lat1 = parseFloat(convertzone[c].latitude);
                                let lon1 = parseFloat(convertzone[c].longitude);
                                let lat2 = parseFloat(convertzone[c + 1].latitude);
                                let lon2 = parseFloat(convertzone[c + 1].longitude);

                                let fallbackDistance = calculateHaversineDistance(lat1, lon1, lat2, lon2);
                                cal += fallbackDistance;
                                totmin += Math.round(fallbackDistance * 2); // Rough estimate: 2 minutes per km

                                console.log(`📐 Fallback distance: ${fallbackDistance}km`);
                            } catch (fallbackError) {
                                console.log("💥 Fallback calculation failed:", fallbackError.message);
                            }
                        }
                    }
                } else {
                    console.log(`❌ Segment ${c + 1} not active - start: ${startZoneStatus}, end: ${endZoneStatus}`);
                }
            }

            console.log(`\n🎯 Final calculation results:`);
            console.log(`   Total distance: ${cal} km`);
            console.log(`   Total time: ${totmin} minutes`);
            console.log(`   Segments processed: ${convertzone.length - 1}`);

            // Check if distance calculation succeeded
            if (cal == 0) {
                console.log("\n💥 Distance calculation failed");
                console.log("Possible issues:");
                console.log("1. Google Maps API key invalid or expired");
                console.log("2. API quota exceeded");
                console.log("3. Network connectivity issues");
                console.log("4. All segments outside service zone");

                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Distance calculation failed - check Google Maps API configuration',
                    debug: {
                        zone_results: zoneresult,
                        converted_zones: convertzone,
                        active_segments: zoneresult.filter(z => z.status == 1 || z.status == "1").length,
                        segments_calculated: convertzone.length - 1,
                        has_google_key: !!general[0].google_map_key,
                        google_key_length: general[0].google_map_key ? general[0].google_map_key.length : 0,
                        fix_applied: true,
                        backend_status: "ENHANCED_LOOP_WITH_FALLBACK"
                    }
                });
            }

            // Calculate pricing based on distance
            let roundkm = cal;
            let drop_price;

            console.log(`\n💰 Calculating price for ${roundkm}km:`);
            console.log(`   Vehicle: ${vehicle[0].name}`);
            console.log(`   Min distance: ${vehicle[0].min_km_distance}km`);
            console.log(`   Min price: ${vehicle[0].min_km_price} per km`);
            console.log(`   After min price: ${vehicle[0].after_km_price} per km`);

            if (roundkm <= parseFloat(vehicle[0].min_km_distance)) {
                drop_price = parseFloat(roundkm) * parseFloat(vehicle[0].min_km_price);
                console.log(`💰 Using base rate: ${roundkm} * ${vehicle[0].min_km_price} = ${drop_price}`);
            } else {
                let add_distance = parseFloat(roundkm) - parseFloat(vehicle[0].min_km_distance);
                drop_price = (parseFloat(vehicle[0].min_km_distance) * parseFloat(vehicle[0].min_km_price)) +
                    (parseFloat(add_distance) * parseFloat(vehicle[0].after_km_price));
                console.log(`💰 Using tiered rate:`);
                console.log(`   Base: ${vehicle[0].min_km_distance} * ${vehicle[0].min_km_price} = ${parseFloat(vehicle[0].min_km_distance) * parseFloat(vehicle[0].min_km_price)}`);
                console.log(`   Additional: ${add_distance} * ${vehicle[0].after_km_price} = ${parseFloat(add_distance) * parseFloat(vehicle[0].after_km_price)}`);
                console.log(`   Total: ${drop_price}`);
            }

            // Convert minutes to hours and minutes
            let hou_min = await AllFunction.MinuteToHour(totmin);
            let driver_id = [];
            let dr_price = parseFloat(parseFloat(drop_price).toFixed(2));

            console.log(`\n✅ Final calculation results:`);
            console.log(`   Distance: ${roundkm} km`);
            console.log(`   Time: ${hou_min.hour}h ${hou_min.minute}m`);
            console.log(`   Price: ${dr_price}`);
            console.log(`   Min fare: ${vehicle[0].minimum_fare}`);
            console.log(`   Max fare: ${vehicle[0].maximum_fare}`);

            // Check fare limits
            if (parseFloat(vehicle[0].minimum_fare) > parseFloat(drop_price)) {
                console.log(`❌ Price ${drop_price} below minimum fare ${vehicle[0].minimum_fare}`);
                return res.status(200).json({
                    ResponseCode: 200,
                    Result: true,
                    message: `The fare is below our minimum limit of ${general[0].site_currency}${vehicle[0].minimum_fare}.`,
                    offer_expire_time: general[0].offer_expire_time,
                    zoneresult,
                    tot_km: 0,
                    drop_price: 0,
                    tot_hour: 0,
                    tot_minute: 0,
                    tot_second: 0,
                    driver_id: [],
                    vehicle: vehicle[0]
                });
            } else if (parseFloat(vehicle[0].maximum_fare) < parseFloat(drop_price)) {
                console.log(`❌ Price ${drop_price} exceeds maximum fare ${vehicle[0].maximum_fare}`);
                return res.status(200).json({
                    ResponseCode: 200,
                    Result: true,
                    message: `The fare exceeds our maximum limit of ${general[0].site_currency}${vehicle[0].maximum_fare}.`,
                    offer_expire_time: general[0].offer_expire_time,
                    zoneresult,
                    tot_km: 0,
                    drop_price: 0,
                    tot_hour: 0,
                    tot_minute: 0,
                    tot_second: 0,
                    driver_id: [],
                    vehicle: vehicle[0]
                });
            } else {
                // Price is within acceptable range
                console.log(`✅ Price ${drop_price} is within fare limits`);

                // Handle bidding if enabled
                if (vehicle[0].bidding == "1") {
                    console.log(`🎯 Bidding enabled for vehicle ${vehicle[0].id}`);
                    try {
                        driver_id = await Vehicle_calculate(0, 0, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 2, convertzone, zonecheck, vehicle[0].id);
                        console.log(`👥 Found ${driver_id?.driver_id?.length || 0} available drivers for bidding`);
                    } catch (biddingError) {
                        console.log(`⚠️ Bidding calculation failed: ${biddingError.message}`);
                        driver_id = { driver_id: [] };
                    }
                }

                // Return successful calculation
                console.log(`🎉 Calculation successful - returning results`);
                return res.status(200).json({

                    ResponseCode: 200,

                    Result: true,

                    message: 'Address calculate successful',

                    offer_expire_time: general[0].offer_expire_time,

                    zoneresult,

                    tot_km: parseFloat(parseFloat(roundkm).toFixed(2)), // Ensure it's a number

                    drop_price: parseFloat(dr_price.toFixed(2)), // Ensure it's a number

                    tot_hour: parseInt(hou_min.hour) || 0, // Ensure it's an integer

                    tot_minute: parseInt(hou_min.minute) || 0, // Ensure it's an integer

                    tot_second: 0, // Already a number

                    driver_id: driver_id && driver_id.driver_id ? driver_id.driver_id : [],

                    vehicle: vehicle[0]

                });
            }
        }

        // Handle other mrole cases (2 = Outstation, 3 = Rental, 4 = Package)
        else if (mrole == "2") {
            console.log(`🚌 Outstation ride calculation not implemented yet`);
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: "Outstation calculation not implemented"
            });
        }
        else if (mrole == "3") {
            console.log(`🕐 Rental ride calculation not implemented yet`);
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: "Rental calculation not implemented"
            });
        }
        else if (mrole == "4") {
            console.log(`📦 Package delivery calculation not implemented yet`);
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: "Package calculation not implemented"
            });
        }
        else {
            console.log(`❓ Unknown mrole: ${mrole}`);
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: "Invalid service type"
            });
        }

    } catch (error) {
        console.error("💥 Calculate API Critical Error:", error);
        console.error("Stack trace:", error.stack);

        return res.status(500).json({
            ResponseCode: 500,
            Result: false,
            error: error.message,
            message: "Internal server error during calculation",
            stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
});

// Helper function to calculate distance using Haversine formula (fallback)
function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Radius of the Earth in kilometers
    const dLat = toRadians(lat2 - lat1);
    const dLon = toRadians(lon2 - lon1);

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c; // Distance in kilometers

    return distance;
}

// Helper function to convert degrees to radians
function toRadians(degrees) {
    return degrees * (Math.PI / 180);
}

// Enhanced Vehicle_calculate function with better error handling
async function Vehicle_calculate(uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, status, czone, zcheck, vid) {
    let convertzone, zonecheck, v_id;

    try {
        if (status == 1) {
            convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);

            let dzone = await AllFunction.ZoneData();
            zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

            if (zonecheck[1].zc != "0") return 1;

            if (mid == "") {
                let vehicle_list = await DataFind(`SELECT id, image, name, description, bidding FROM tbl_vehicle WHERE status = '1' ORDER BY id LIMIT 1`);
                if (vehicle_list == "" || vehicle_list.length === 0) return 4;
                v_id = vehicle_list[0].id;
            } else v_id = mid;

        } else {
            convertzone = czone;
            zonecheck = zcheck;
            v_id = vid;
        }

        const general = await DataFind(`SELECT * FROM tbl_general_settings`);
        if (general == "" || general.length === 0) return 2;

        console.log(`🔍 Looking for drivers for vehicle ${v_id} in zones ${JSON.stringify(zonecheck[2]?.zid)}`);

        // Build zone condition - handle both single values and comma-separated values
        const zoneIds = zonecheck[2].zid;
        let zoneCondition = '';

        if (Array.isArray(zoneIds)) {
            // Handle multiple zones
            const zoneChecks = zoneIds.map(zid =>
                `(zone = '${zid}' OR zone LIKE '%,${zid},%' OR zone LIKE '${zid},%' OR zone LIKE '%,${zid}')`
            ).join(' OR ');
            zoneCondition = `(${zoneChecks})`;
        } else {
            // Handle single zone
            zoneCondition = `(zone = '${zoneIds}' OR zone LIKE '%,${zoneIds},%' OR zone LIKE '${zoneIds},%' OR zone LIKE '%,${zoneIds}')`;
        }

        // Build vehicle condition
        const vehicleCondition = `(vehicle = '${v_id}' OR vehicle LIKE '%,${v_id},%' OR vehicle LIKE '${v_id},%' OR vehicle LIKE '%,${v_id}')`;

        // Enhanced driver query with better error handling
        const driverQuery = `SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                FROM tbl_driver AS dr
                                LEFT JOIN tbl_vehicle AS ve ON ve.id = '${v_id}'
                                WHERE ${zoneCondition}
                                AND ${vehicleCondition}
                                AND dr.fstatus = '1'
                                AND dr.status = '1'
                                AND dr.approval_status = '1'
                                AND dr.rid_status = '0'
                                AND dr.latitude IS NOT NULL
                                AND dr.latitude != ''
                                AND dr.longitude IS NOT NULL
                                AND dr.longitude != ''
                                AND ve.status = '1'`;

        console.log(`🔍 Driver query: ${driverQuery}`);

        const driver = await DataFind(driverQuery);
        console.log(`👥 Found ${driver ? driver.length : 0} potential drivers`);

        if (driver == "" || driver.length === 0) {
            console.log('❌ No drivers found matching criteria');
            return 3;
        }

        let dkm = 0, dtime = 0;
        let cpickup = `${convertzone[0].latitude},${convertzone[0].longitude}`;
        let caldriver = [], driver_id = [], minkm = 0;
        let point = {
            latitude: Number(convertzone[0].latitude),
            longitude: Number(convertzone[0].longitude)
        };

        const radiusMeters = Number(parseFloat(general[0].vehicle_radius) * parseFloat(1000));
        console.log(`📏 Checking drivers within ${radiusMeters}m radius`);

        for (let i = 0; i < driver.length; i++) {
            try {
                // Validate driver coordinates
                const driverLat = parseFloat(driver[i].latitude);
                const driverLon = parseFloat(driver[i].longitude);

                if (isNaN(driverLat) || isNaN(driverLon)) {
                    console.log(`❌ Driver ${driver[i].id}: Invalid coordinates`);
                    continue;
                }

                let dlotlon = {
                    latitude: driverLat,
                    longitude: driverLon
                };

                // Check if driver is within radius
                let distance = await AllFunction.RadiusCheck(point, dlotlon, radiusMeters);
                console.log(`🚗 Driver ${driver[i].id}: radius check = ${distance}`);

                if (distance == 1) {
                    if (status == "2") {
                        // Calculate driver pickup time
                        let driverLocation = `${driver[i].latitude},${driver[i].longitude}`;

                        try {
                            let dstance = await Promise.race([
                                AllFunction.GetDistance(driverLocation, cpickup, general[0].google_map_key),
                                new Promise((_, reject) =>
                                    setTimeout(() => reject(new Error('Driver distance timeout')), 5000)
                                )
                            ]);

                            if (dstance && dstance.dis) {
                                dkm = Math.round(parseFloat(dstance.dis));

                                let spltime = dstance.dur ? dstance.dur.split(" ") : [];
                                if (spltime.length == 2) {
                                    dtime = parseFloat(spltime[0]) || 0;
                                } else if (spltime.length == 4) {
                                    dtime = (parseFloat(spltime[0]) * 60) + parseFloat(spltime[2]) || 0;
                                }

                                if (minkm == 0) minkm = dtime;
                                if (parseFloat(minkm) > parseFloat(dtime)) minkm = dtime;
                            }
                        } catch (distanceError) {
                            console.log(`⚠️ Driver ${driver[i].id} distance calculation failed:`, distanceError.message);
                            // Use fallback calculation
                            let fallbackDistance = calculateHaversineDistance(
                                point.latitude, point.longitude,
                                driverLat, driverLon
                            );
                            dtime = Math.round(fallbackDistance * 2); // Rough estimate: 2 minutes per km
                            if (minkm == 0 || dtime < minkm) minkm = dtime;
                        }
                    }

                    driver_id.push(driver[i].id);
                    caldriver.push({
                        id: driver[i].id,
                        image: driver[i].image,
                        name: driver[i].name,
                        description: driver[i].description,
                        latitude: driver[i].latitude,
                        longitude: driver[i].longitude
                    });
                }
            } catch (driverError) {
                console.log(`❌ Error processing driver ${driver[i].id}:`, driverError.message);
                continue;
            }
        }

        console.log(`✅ Final driver results: ${driver_id.length} drivers found`);

        if (status == "1") return { driver_id, caldriver };
        else return { minkm: minkm, driver_id: driver_id };

    } catch (error) {
        console.error('💥 Vehicle_calculate error:', error);
        return status == "1" ? { driver_id: [], caldriver: [] } : { minkm: 0, driver_id: [] };
    }
}



router.post("/module_calculate", async (req, res) => {
    try {
        const { uid, mid, mrole, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

        const missingField = ["uid", 'mid', 'mrole', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let convertzone = await AllFunction.ZoneLatlon(pickup_lat_lon, drop_lat_lon, drop_lat_lon_list);

        let dzone = await AllFunction.ZoneData();
        let zonecheck = await AllFunction.CheckZone(convertzone, dzone.all_zone, dzone.zone_data);

        if (zonecheck[1].zc != "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! module_calculate' });

        const vehicle = await DataFind(`SELECT * FROM tbl_vehicle WHERE status = '1' AND bidding = '0'`);
        if (vehicle == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });

        let zoneresult = zonecheck[0].zr, dhour = 0, dtime = 0;

        const general = await DataFind(`SELECT * FROM tbl_general_settings`);
        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let cal = 0, hour = 0, time = 0, totmin = 0;
        for (let a = 1; a < zoneresult.length;) {

            let pickup = `${convertzone[a - 1].latitude},${convertzone[a - 1].longitude}`;
            let drop = `${convertzone[a].latitude},${convertzone[a].longitude}`;

            let distance = await AllFunction.GetDistance(pickup, drop, general[0].google_map_key);

            cal += parseFloat(distance.dis)

            let spltime = distance.dur.split(" ");
            if (spltime.length == "2") {
                dhour = 0; dtime = parseFloat(spltime[0]);
            } else if (spltime.length == "4") {
                dhour = parseFloat(spltime[0]); dtime = parseFloat(spltime[2]);
            }

            totmin += parseFloat(dhour) * 60 + parseFloat(dtime);
            hour += parseFloat(dhour); time += dtime;
            a++;
        }
        if (cal == "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let hou_min = await AllFunction.MinuteToHour(totmin);

        let caldriver = [];
        for (let c = 0; c < vehicle.length;) {
            let drop_price, add_distance, veh = "", addtime = "";

            let vehcal = await Vehicle_calculate(0, 0, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 2, convertzone, zonecheck, vehicle[c].id);

            if (vehcal != 3) {
                addtime = await AllFunction.AddDateMinute(parseFloat(vehcal.minkm) + parseFloat(totmin)); veh = vehcal.minkm;
            }

            if (cal <= vehicle[c].min_km_distance) {
                drop_price = parseFloat(cal) * parseFloat(vehicle[c].min_km_price);
            } else {
                add_distance = parseFloat(cal) - parseFloat(Number(vehicle[c].min_km_distance));
                drop_price = (parseFloat(vehicle[c].min_km_distance) * parseFloat(vehicle[c].min_km_price) + (parseFloat(add_distance) * parseFloat(vehicle[c].after_km_price)));
            }

            caldriver.push({
                ...vehicle[c], dri_pic_time: veh, dri_pic_drop: addtime, drop_price: parseFloat(parseFloat(drop_price).toFixed(2)), drop_hour: hou_min.hour, drop_time: hou_min.minute,
                drop_km: parseFloat(parseFloat(cal).toFixed(2))
            });
            c++;
        }

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Address calculate successful', caldriver });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})








router.post("/vehicle_calculate", async (req, res) => {
    try {
        const { uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list } = req.body;

        const missingField = ["uid", 'mid', 'pickup_lat_lon', 'drop_lat_lon'].find(field => !req.body[field]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong vehicle_calculate' });

        let caldata = await Vehicle_calculate(uid, mid, pickup_lat_lon, drop_lat_lon, drop_lat_lon_list, 1)
        if (caldata == "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! vehicle_calculate' });
        if (caldata == "2") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
        if (caldata == "3") return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver not found! vehicle_calculate', driver_id: [], caldriver: [] });
        if (caldata == "4") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });
        if (caldata == "5") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong vehicle_calculate' });

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Address calculate successful', driver_id: caldata.driver_id, caldriver: caldata.caldriver });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
});


// ========================================
// ENHANCED Backend Route with Better Error Logging
// ========================================

router.post("/add_vehicle_request", async (req, res) => {
    try {
        // ADD THIS LOG to see exactly what the server is receiving
        console.log("Received body for /add_vehicle_request:", req.body);

        const { uid, driverid, vehicle_id, price, tot_km, tot_hour, tot_minute, payment_id, m_role, coupon_id, bidd_auto_status, pickup, drop, droplist, pickupadd, dropadd, droplistadd } = req.body;

        // The original check is good, but let's make the error message clearer
        const missingField = await AllFunction.CheckBodyData(req, ["uid", "driverid", "vehicle_id", "price", "tot_km", "tot_hour", "tot_minute", "payment_id", "m_role", "pickup", "drop", "pickupadd", "dropadd"]);

        if (missingField) {
            // FIX: Return a more specific error message
            console.error(`Request failed: Missing field -> ${missingField}`);
            return res.status(400).json({ ResponseCode: 400, Result: false, message: `Request is missing required field: ${missingField}` });
        }

        // 2. Securely get general settings
        const general = await DataFind(`SELECT default_payment FROM tbl_general_settings`, []);
        if (!general || general.length === 0) {
            return res.status(500).json({ ResponseCode: 500, Result: false, message: 'Server configuration error.' });
        }
        const payment = payment_id == "0" ? general[0].default_payment : payment_id;

        // 3. Securely get vehicle details
        const vehicle_list = await DataFind(`SELECT bidding FROM tbl_vehicle WHERE id = ? AND status = '1'`, [vehicle_id]);
        if (!vehicle_list || vehicle_list.length === 0) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle not found or is inactive.' });
        }
        const vehicle = vehicle_list[0];

        // --- (Your existing data preparation logic is fine) ---
        let convertz = await AllFunction.ZoneLatlon(pickup, drop, droplist);
        let pic = "", dropdata = "", picadd = "", dropad = "";
        if (convertz.length > 0) {
            pic = `${convertz[0].latitude}&!${convertz[0].longitude}`;
            dropdata = convertz.slice(1).map(d => `${d.latitude}&!${d.longitude}`).join('&!!');
        }
        picadd = `${pickupadd.title || ''}&!${pickupadd.subt || ''}`;
        dropad = `${dropadd.title || ''}&!${dropadd.subt || ''}`;
        if (droplistadd && droplistadd.length > 0) {
            const additionalDrops = droplistadd.map(d => `${d.title || ''}&!${d.subt || ''}`).join('&!!');
            dropad += `&!!${additionalDrops}`;
        }
        for (const driver of driverid) {
            sendOneNotification("New ride request received! Ready to go!", 'driver', driver);
        }
        const date = new Date().toISOString();
        const bidd_auto_st = bidd_auto_status == "true" ? '1' : '0';
        // --- (End of data preparation) ---


        // 4. THIS IS THE CRITICAL FIX: Calling DataInsert the correct way
        const columns = `c_id, d_id, bidding_d_price, bidding_status, bidd_auto_status, pic_lat_long, drop_lat_long, pic_address, drop_address, price, tot_km, tot_hour, tot_minute, vehicleid, payment_id, status, m_role, coupon_id, start_time`;

        const values = [ // This is an array, not a string
            uid, JSON.stringify(driverid), '', vehicle.bidding, bidd_auto_st, pic, dropdata, picadd, dropad, price,
            tot_km, tot_hour, tot_minute, vehicle_id, payment, '0', m_role, coupon_id || null, date
        ];

        const result = await DataInsert('tbl_request_vehicle', columns, values);

        if (result === -1 || !result.insertId) {
            return res.status(500).json({ ResponseCode: 500, Result: false, message: "Failed to create request." });
        }

        return res.status(200).json({ ResponseCode: 200, Result: true, message: `We’ve sent ${driverid.length} captain requests; they’ll confirm shortly.`, id: result.insertId });

    } catch (error) {
        console.error("Error in /add_vehicle_request:", error);
        res.status(500).json({ error: 'Internal server error' });
    }
});
router.get("/vehicle_cancel_reason", async (req, res) => {
    try {
        const ride_cancel_list = await DataFind(`SELECT id, title FROM tbl_ride_cancel_reason WHERE status = '1'`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', ride_cancel_list });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.get("/review_data", async (req, res) => {
    try {
        const review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', review_list });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/vehicle_live_location", async (req, res) => {
    try {
        const { uid, d_id } = req.body;

        if (!uid || !d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const data = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${uid}' AND d_id = '${d_id}'`);
        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        const driver = await DataFind(`SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                            COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                            FROM tbl_driver AS dr
                                            JOIN tbl_vehicle AS ve ON dr.vehicle = ve.id AND ve.id = dr.vehicle
                                            WHERE dr.id = '${data[0].d_id}' AND dr.fstatus = '1' AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', driver_location: driver[0] });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/timeout_vehicle_request", async (req, res) => {
    try {
        const { request_id, uid } = req.body;

        if (!request_id || !uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        if (await DataUpdate(`tbl_request_vehicle`, `d_id = '[]', status = '0'`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }

        let array = data[0].d_id
        if (typeof array == "string") array = JSON.parse(array);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Out successful', id: data[0].id, driverid: array });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/resend_vehicle_request", async (req, res) => {
    try {
        const { uid, driverid } = req.body;

        if (!uid || !driverid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        let pl = data[0].pic_lat_long.split("&!"), dl = data[0].drop_lat_long.split("&!!"), drop_lat_lon = "", drop_lat_lon_list = []
        for (let i = 0; i < dl.length;) {
            let dspl = dl[i].split("&!");
            if (i == "0") drop_lat_lon = `${dspl[0]},${dspl[1]}`;
            else {
                drop_lat_lon_list.push({ "lat": dspl[0], "long": dspl[1] });
            }
            i++;
        }

        let caldata = await Vehicle_calculate(uid, data[0].vehicleid, `${pl[0]},${pl[1]}`, drop_lat_lon, drop_lat_lon_list, 1);
        if (caldata == "1") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Address is not in the zone! resend_vehicle_request' });
        if (caldata == "2") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
        if (caldata == "3") return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver not found! resend_vehicle_request', driver_id: [], caldriver: [] });
        if (caldata == "4") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Vehicle Not Found!' });
        if (caldata == "5") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let d_id = caldata.driver_id, senddataJson;
        if (typeof d_id == "string") {
            d_id = JSON.parse(d_id);
            senddataJson = JSON.stringify(d_id);
        } else senddataJson = JSON.stringify(d_id);

        if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${senddataJson}', bidding_d_price = '', status = '0'`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }
        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Resend successful', id: data[0].id, driver_list: JSON.parse(senddataJson) });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/remove_vehicle_request", async (req, res) => {
    try {
        const { uid } = req.body;

        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const data = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}'`);
        if (data == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        if (await DataDelete(`tbl_request_vehicle`, `c_id = '${uid}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }

        let array = data[0].d_id;
        if (typeof array == "string") array = JSON.parse(array);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Cancel successful', id: data[0].id, driver_list: array });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})

router.post("/vehicle_ride_cancel", async (req, res) => {
    try {
        const { uid, request_id, cancel_id, lat, lon } = req.body;
        if (!uid || !request_id || !cancel_id || !lat || !lon) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Missing required parameters' });
        }

        const CANCEL_STATUS = '4';
        let rd, fulldate = await AllFunction.TodatDate();

        let sql = `SELECT * FROM tbl_request_vehicle WHERE id = ? AND c_id = ?`;
        rd = await DataFind(sql, [request_id, uid]);

        if (!rd || rd.length === 0) {
            sql = `SELECT * FROM tbl_cart_vehicle WHERE id = ? AND c_id = ?`;
            rd = await DataFind(sql, [request_id, uid]);

            if (!rd || rd.length === 0) {
                return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });
            }

            // --- Logic for rides from 'tbl_cart_vehicle' ---
            const rideData = rd[0];
            const updatet = rideData.status_time_location ? `${rideData.status_time_location}&!!${CANCEL_STATUS}&${fulldate.date}T${fulldate.time}&${lat}&${lon}` : `${CANCEL_STATUS}&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;
            const driver_list = [parseFloat(rideData.d_id)];

            let startTime = "";
            const endTime = new Date().toISOString();
            if (rideData.status_time_location) {
                const setime = rideData.status_time_location.split("&!!");
                if (setime.length > 0) {
                    const stime = setime[0].split("&");
                    if (stime.length > 1 && stime[0] === "1") startTime = stime[1];
                }
            }

            const orderTable = 'tbl_order_vehicle';
            const orderColumns = `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, paid_status, price, final_price, paid_amount, coupon_amount, addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, m_role, coupon_id, additional_time, ride_status, start_time, end_time, drop_tot, drop_complete, current_run_time, status_time, status_time_location, pic_lat_long, drop_lat_long, pic_address, drop_address, cancel_reason, req_id`;
            const orderValues = [
                rideData.c_id, rideData.d_id, rideData.vehicleid, rideData.bidding_status, rideData.bidd_auto_status, '0', rideData.price, rideData.final_price, '0', rideData.coupon_amount, rideData.addi_time_price, rideData.platform_fee, rideData.weather_price, '0', rideData.tot_km, rideData.tot_hour, rideData.tot_minute, CANCEL_STATUS, rideData.m_role, rideData.coupon_id, rideData.additional_time, rideData.ride_status, startTime, endTime, rideData.drop_tot, rideData.drop_complete, rideData.current_run_time, rideData.status_time, updatet, rideData.pic_lat_long, rideData.drop_lat_long, rideData.pic_address, rideData.drop_address, cancel_id, rideData.id
            ];

            const indata = await DataInsert(orderTable, orderColumns, orderValues);
            if (indata === -1) return res.status(500).json({ ResponseCode: 500, Result: false, message: "Database Error" });

            await DataDelete(`tbl_cart_vehicle`, `id = ?`, [rideData.id]);
            await DataUpdate(`tbl_driver`, `rid_status = '0', check_status = '0'`, `id = ?`, [rideData.d_id]);

            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Cancelled successfully', driverid: driver_list });

        } else {
            // --- Logic for rides from 'tbl_request_vehicle' ---
            const requestData = rd[0];
            const updatet = requestData.status_time_location ? `${requestData.status_time_location}&!!${CANCEL_STATUS}&${fulldate.date}T${fulldate.time}&${lat}&${lon}` : `${CANCEL_STATUS}&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;
            const dropcount = requestData.drop_lat_long.split("&!!").length;

            let driver_list = [];
            if (requestData.d_id) {
                try {
                    driver_list = JSON.parse(requestData.d_id);
                    if (!Array.isArray(driver_list)) driver_list = [driver_list];
                } catch (e) {
                    driver_list = [requestData.d_id];
                }
            }

            const orderTable = 'tbl_order_vehicle';
            const orderColumns = `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, additional_time, drop_tot, status_time_location, pic_lat_long, drop_lat_long, pic_address, drop_address, cancel_reason, req_id`;
            const orderValues = [
                requestData.c_id, JSON.stringify(driver_list), requestData.vehicleid, requestData.bidding_status, requestData.bidd_auto_status, requestData.price, requestData.tot_km, requestData.tot_hour, requestData.tot_minute, CANCEL_STATUS, requestData.payment_id, requestData.m_role, requestData.additional_time, dropcount, updatet, requestData.pic_lat_long, requestData.drop_lat_long, requestData.pic_address, requestData.drop_address, cancel_id, requestData.id
            ];

            const indata = await DataInsert(orderTable, orderColumns, orderValues);
            if (indata === -1) return res.status(500).json({ ResponseCode: 500, Result: false, message: "Database Error" });

            await DataDelete(`tbl_request_vehicle`, `id = ?`, [requestData.id]);

            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Cancelled successfully', driverid: driver_list });
        }

    } catch (error) {
        console.error("Error in /vehicle_ride_cancel:", error);
        res.status(500).json({ error: 'Internal server error' });
    }
});


router.post("/vehicle_ride_addstatus", async (req, res) => {
    try {
        const { uid, d_id, request_id } = req.body;
        if (!uid || !d_id || !request_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${uid}' AND d_id = '${d_id}'`);
        if (rd == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        if (rd[0].status == "3") {
            if (rd[0].ride_status != "0") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
        } else if (rd[0].status == "6") {
            if (rd[0].ride_status != "6") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
        }
        if (rd[0].status == "0" || rd[0].status == "1" || rd[0].status == "2" || rd[0].status == "4" || rd[0].status == "5" || rd[0].status == "7" || rd[0].status == "8") {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Please Complete Other Stap!' });
        }

        let dlatlon = rd[0].drop_lat_long.split("&!!"), daddress = rd[0].drop_address.split("&!!"), pending_ride = "", drop_list = [];

        if (rd[0].drop_complete == "") pending_ride = 0;
        else pending_ride = parseFloat(rd[0].drop_complete) + 1;

        let ccheck = await AllFunction.CheckCurrentLocation(pending_ride, dlatlon, daddress);

        for (let i = 0; i < dlatlon.length;) {
            let checkadd = daddress[i].split("&!"), checkl = dlatlon[i].split("&!"), status = "";

            if (pending_ride == i) status = "2";
            if (pending_ride > i) status = "3";
            if (pending_ride < i) status = "1";

            drop_list.push({ status: status, title: checkadd[0], subtitle: checkadd[1], latitude: checkl[0], longitude: checkl[1] });
            i++;
        }

        return res.status(200).json({
            ResponseCode: 200, Result: true, message: "Service Start Successful", current_address: ccheck.current_address,
            next_address: ccheck.next_address, drop_list
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})






router.post("/vehicle_driver_detail", async (req, res) => {
    try {
        const { uid, d_id, request_id } = req.body;

        if (!uid || !d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let dr = await AllFunction.DriverReview("cve");
        let rd = await DataFind(`SELECT cve.id, cve.c_id, cve.d_id, cve.price, cve.tot_km, cve.status, cve.otp, cve.tot_hour, cve.tot_minute,
                                COALESCE(dr.profile_image, "") AS profile_image, COALESCE(dr.vehicle_image, "") AS vehicle_image, COALESCE(dr.first_name, "") AS first_name,
                                COALESCE(dr.last_name, "") AS last_name, COALESCE(dr.primary_ccode, "") AS primary_ccode, COALESCE(dr.primary_phoneNo, "") AS primary_phoneNo,
                                COALESCE(dr.language, "") AS language, COALESCE(dr.vehicle_number, "") AS vehicle_number, COALESCE(dr.car_color, "") AS car_color,
                                COALESCE(dr.passenger_capacity, "") AS passenger_capacity, COALESCE(GROUP_CONCAT(DISTINCT vr.name SEPARATOR ','), '') AS prefrence_name,
                                COALESCE(dr.date, "") AS join_date, COALESCE(dr.latitude, "") AS latitude, COALESCE(dr.longitude, "") AS longitude, COALESCE(vec.map_img, "") AS map_img,
                                COALESCE(vec.name, "") AS car_name
                                ${dr.tot_review} ${dr.avgstar}, COALESCE(COUNT(DISTINCT ov.id), 0) AS tot_complete_order
                                FROM tbl_cart_vehicle AS cve
                                JOIN tbl_driver AS dr ON cve.d_id = dr.id
                                JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                LEFT JOIN tbl_vehicle_preference AS vr ON FIND_IN_SET(vr.id, dr.vehicle_prefrence) > 0
                                LEFT JOIN tbl_order_vehicle AS ov ON cve.d_id = ov.d_id
                                ${dr.table}
                                WHERE ${request_id != "" ? `cve.id = '${request_id}' AND` : ``}  cve.c_id = '${uid}' AND cve.d_id = '${d_id}' GROUP BY cve.id`);

        if (rd != "") {
            rd[0].rating = parseFloat(rd[0].avg_star); rd[0].tot_review = parseFloat(rd[0].tot_review); rd[0].tot_hour = parseFloat(rd[0].tot_hour); rd[0].tot_minute = parseFloat(rd[0].tot_minute)
            delete rd[0].avg_star
            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver Data Load Successful', accepted_d_detail: rd[0] });
        } else {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Data Not Found!', accepted_d_detail: [] });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})


router.post("/accept_driver_bid", async (req, res) => {
    try {
        const { uid, d_id, request_id, price } = req.body;

        if (!uid || !d_id || !request_id || !price) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing required parameters'
            });
        }

        console.log(`🎯 Customer ${uid} accepting driver ${d_id} bid for request ${request_id}`);

        // Find the request
        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

        if (!request || request.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Request not found'
            });
        }

        const requestData = request[0];

        // Check if driver is in the bidding list
        let driverList = requestData.d_id;
        if (typeof driverList === 'string') {
            driverList = JSON.parse(driverList);
        }

        if (!driverList.includes(parseInt(d_id))) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Driver not in bidding list'
            });
        }

        // Verify driver is available
        const driver = await DataFind(`SELECT * FROM tbl_driver WHERE id = '${d_id}' AND status = '1' AND approval_status = '1' AND rid_status = '0'`);

        if (!driver || driver.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Driver not available'
            });
        }

        let fulldate = await AllFunction.TodatDate();

        // Escape address data safely
        let espiadd = mysql.escape(requestData.pic_address || '');
        let esdroadd = mysql.escape(requestData.drop_address || '');

        // Generate OTP
        let otp = await AllFunction.otpGenerate(4);

        // Calculate drop count
        let dropcount = requestData.drop_lat_long ? requestData.drop_lat_long.split("&!!").length : 1;

        console.log(`📝 Moving request ${request_id} to cart table`);

        // FIXED: Insert only fields that exist in tbl_cart_vehicle schema
        const cartInsert = await DataInsert(`tbl_cart_vehicle`,
            `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, price, final_price, paid_amount, coupon_amount,
             addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role,
             coupon_id, start_time, otp, additional_time, ride_status, drop_tot, drop_complete, current_run_time, status_time,
             status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, driver_id_list`,
            `'${requestData.c_id}', '${d_id}', '${requestData.vehicleid}', '${requestData.bidding_status}', '${requestData.bidd_auto_status}',
             '${price}', '${price}', '0', '0', '0', '0', '0', '0', '${requestData.tot_km}', '${requestData.tot_hour}',
             '${requestData.tot_minute}', '1', '${requestData.payment_id}', '${requestData.m_role}', '${requestData.coupon_id || 0}',
             '${fulldate.date}T${fulldate.time}', '${otp}', '0', '0', '${dropcount}', '0', '', '',
             '1&${fulldate.date}T${fulldate.time}&0&0', '', '${requestData.pic_lat_long}', '${requestData.drop_lat_long}',
             ${espiadd}, ${esdroadd}, '[]'`,
            req.hostname, req.protocol);

        if (cartInsert == -1 || !cartInsert.insertId) {
            console.error("❌ Failed to create cart record");
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Failed to accept driver bid'
            });
        }

        const newCartId = cartInsert.insertId;
        console.log(`✅ Cart record created with ID: ${newCartId}`);

        // Update driver status
        await DataUpdate(`tbl_driver`, `rid_status = '1', check_status = '1'`, `id = '${d_id}'`, req.hostname, req.protocol);

        // Delete the original request
        await DataDelete(`tbl_request_vehicle`, `id = '${request_id}'`, req.hostname, req.protocol);

        console.log(`🎉 Customer ${uid} successfully accepted driver ${d_id} bid`);

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Driver bid accepted successfully',
            cart_id: newCartId,
            driver_id: d_id,
            otp: otp
        });

    } catch (error) {
        console.error('💥 Accept driver bid error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error',
            error: {
                code: error.code,
                errno: error.errno,
                sqlState: error.sqlState,
                sqlMessage: error.sqlMessage,
                sql: error.sql
            }
        });
    }
});

router.post("/driver_profile_detail", async (req, res) => {
    try {
        const { d_id } = req.body;
        if (!d_id) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let dr = await AllFunction.DriverReview("dr");
        let rd = await DataFind(`SELECT dr.profile_image, dr.vehicle_image, dr.first_name, dr.last_name, dr.primary_ccode, dr.primary_phoneNo, dr.language, dr.vehicle_number, dr.car_color,
                                    dr.passenger_capacity, dr.date AS join_date,
                                    COALESCE(GROUP_CONCAT(DISTINCT vr.name SEPARATOR ','), '') AS prefrence_name, COALESCE(vec.name, "") AS car_name
                                    ${dr.tot_review} ${dr.avgstar}, COALESCE(COUNT(DISTINCT ov.id), 0) AS tot_complete_order
                                    FROM tbl_driver AS dr
                                    JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                    LEFT JOIN tbl_vehicle_preference AS vr ON FIND_IN_SET(vr.id, dr.vehicle_prefrence) > 0
                                    LEFT JOIN tbl_order_vehicle AS ov ON dr.id = dr.id
                                    ${dr.outtable}
                                    WHERE dr.id = '${d_id}' GROUP BY dr.id`);

        if (rd != "") {
            rd[0].rating = parseFloat(rd[0].avg_star); rd[0].tot_review = parseFloat(rd[0].tot_review);
            delete rd[0].avg_star
            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Driver Data Load Successful', d_detail: rd[0] });
        } else {
            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Not Found!', d_detail: [] });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})





router.post("/vehicle_ride_complete", upload.single('payment_img'), async (req, res) => {
    try {
        console.log("🚀 Starting ride completion process");
        console.log("📋 Request body:", req.body);

        const { uid, d_id, request_id, wallet, payment_id } = req.body;

        if (!uid || !d_id || !request_id || !wallet) {
            console.log("❌ Missing required parameters:", { uid, d_id, request_id, wallet });
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing required parameters'
            });
        }

        // Find ride data
        const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${uid}' AND d_id = '${d_id}' AND id = '${request_id}'`);
        console.log("🎯 Ride data found:", rd.length > 0 ? "Yes" : "No");

        // Find driver data
        const dr = await DataFind(`SELECT * FROM tbl_driver WHERE id = '${d_id}'`);
        console.log("👨‍✈️ Driver data found:", dr.length > 0 ? "Yes" : "No");

        if (rd.length === 0 || dr.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Request Not Found!'
            });
        }

        // Enhanced ride completion validation
        if (parseFloat(rd[0].status) < 7) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Please Complete Other Step!'
            });
        }

        // Check and fix drop point completion
        if (rd[0].drop_tot && rd[0].drop_complete !== rd[0].drop_tot) {
            const dropTotal = parseInt(rd[0].drop_tot) || 1;
            const dropCompleted = parseInt(rd[0].drop_complete) || 0;

            console.log(`🚗 Ride ${rd[0].id}: Drop status ${dropCompleted}/${dropTotal}`);

            if (rd[0].status == "7") {
                console.log(`🔧 Auto-completing drops for payment-ready ride`);
                try {
                    if (await DataUpdate(`tbl_cart_vehicle`,
                        `drop_complete = '${dropTotal}'`,
                        `id = '${rd[0].id}'`,
                        req.hostname, req.protocol) !== -1) {

                        rd[0].drop_complete = dropTotal.toString();
                        console.log(`✅ Successfully completed all drops for ride ${rd[0].id}`);
                    }
                } catch (error) {
                    console.error("❌ Error updating drop completion:", error);
                }
            } else if (dropCompleted < dropTotal) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: `Driver must complete ${dropTotal - dropCompleted} more drop point(s)!`
                });
            }
        }

        // Find customer data
        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
        if (customer.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Customer not found!'
            });
        }

        // Handle payment image
        let imageUrl = "";
        if (rd[0].payment_id == "10" || rd[0].payment_id == "11") {
            if (!req.file) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Please Upload Image!'
                });
            }
            imageUrl = "uploads/payment_proof/" + req.file.filename;
        }

        // Calculate payment details
        let paid_amount = 0;
        let paid_status = 1;
        let fullwallet = parseFloat(dr[0].wallet || 0);
        let payout_wallet = parseFloat(dr[0].payout_wallet || 0);
        let tot_cash = parseFloat(dr[0].tot_cash || 0);
        let fulldate = await AllFunction.TodatDate();

        const nwallet_amount = parseFloat((parseFloat(rd[0].price || 0) + parseFloat(rd[0].addi_time_price || 0) + parseFloat(rd[0].weather_price || 0)).toFixed(2));

        console.log("💰 Payment calculation:", {
            wallet_used: wallet,
            final_price: rd[0].final_price,
            nwallet_amount,
            payment_id
        });

        // Wallet payment processing
        if (parseFloat(wallet) != 0) {
            if (parseFloat(rd[0].final_price) > parseFloat(wallet)) {
                paid_amount = parseFloat((parseFloat(rd[0].final_price) - parseFloat(wallet)).toFixed(2));

                if (parseFloat(rd[0].platform_fee) > parseFloat(paid_amount) && payment_id == "9") {
                    const cash = parseFloat((parseFloat(rd[0].platform_fee) - parseFloat(paid_amount)).toFixed(2));
                    console.log("💵 Cash amount calculated:", cash);
                }
            }

            // Update customer wallet
            let cdata = customer[0].wallet || 0;
            let wamount = parseFloat(cdata);
            let wallet_amount = parseFloat((wamount - parseFloat(wallet)).toFixed(2));

            if (await DataUpdate(`tbl_customer`, `wallet = '${wallet_amount}'`, `id = '${uid}'`, req.hostname, req.protocol) == -1) {
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Database error updating customer wallet'
                });
            }

            if (payment_id == "9") {
                fullwallet = parseFloat((fullwallet + nwallet_amount).toFixed(2));
                payout_wallet = parseFloat((payout_wallet + parseFloat(wallet)).toFixed(2));
            }
        } else {
            paid_amount = parseFloat(rd[0].final_price || 0);
            if (payment_id != "9") {
                fullwallet = parseFloat((fullwallet + nwallet_amount).toFixed(2));
            }
        }

        // Calculate driver earnings for cash payments
        if (payment_id == "9") {
            if (parseFloat(wallet) == 0) {
                payout_wallet = parseFloat(dr[0].payout_wallet || 0);
            }
            tot_cash = parseFloat((tot_cash + parseFloat(rd[0].platform_fee || 0)).toFixed(2));
        } else {
            payout_wallet = parseFloat((payout_wallet + nwallet_amount).toFixed(2));
        }

        // Update driver wallet
        if (await DataUpdate(`tbl_driver`,
            `wallet = '${fullwallet}', payout_wallet = '${payout_wallet}', tot_cash = '${tot_cash}', rid_status = '0', check_status = '0'`,
            `id = '${rd[0].d_id}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Database error updating driver wallet'
            });
        }

        // Prepare order data with safe defaults
        let updatet = rd[0].status_time_location ?
            `${rd[0].status_time_location}&!!8&${fulldate.date}T${fulldate.time}&0&0` :
            `8&${fulldate.date}T${fulldate.time}&0&0`;

        // Parse time data safely
        let setime = (rd[0].status_time_location || "").split("&!!");
        let stime = setime.length > 0 ? setime[0].split("&") : ["", fulldate.date + "T" + fulldate.time];
        let etime = setime.length > 1 ? setime[setime.length - 1].split("&") : ["", fulldate.date + "T" + fulldate.time];

        // Escape address data safely
        let espiadd = mysql.escape(rd[0].pic_address || '');
        let esdroadd = mysql.escape(rd[0].drop_address || '');

        console.log("📝 Creating order record with safe data");

        // FIXED: Removed req_id from the INSERT statement since it doesn't exist in tbl_order_vehicle
        try {
            let insertid = await DataInsert(`tbl_order_vehicle`,
                `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, paid_status, price, final_price, paid_amount, coupon_amount,
                    addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role,
                    coupon_id, additional_time, ride_status, start_time, end_time, drop_tot, drop_complete, current_run_time, status_time,
                    status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, payment_img,
                    cancel_reason`,
                `'${rd[0].c_id}', '${rd[0].d_id}', '${rd[0].vehicleid || ''}', '${rd[0].bidding_status || '0'}', '${rd[0].bidd_auto_status || '0'}',
                    '${paid_status}', '${rd[0].price || '0'}', '${rd[0].final_price || '0'}', '${paid_amount}', '${rd[0].coupon_amount || '0'}',
                    '${rd[0].addi_time_price || '0'}', '${rd[0].platform_fee || '0'}', '${rd[0].weather_price || '0'}', '${wallet}',
                    '${rd[0].tot_km || '0'}', '${rd[0].tot_hour || '0'}', '${rd[0].tot_minute || '0'}', '8', '${payment_id}',
                    '${rd[0].m_role || ''}', '${rd[0].coupon_id || '0'}', '${rd[0].additional_time || '0'}', '${rd[0].ride_status || '7'}',
                    '${stime[1] || fulldate.date + "T" + fulldate.time}', '${etime[1] || fulldate.date + "T" + fulldate.time}',
                    '${rd[0].drop_tot || '1'}', '${rd[0].drop_complete || '1'}', '${rd[0].current_run_time || '0'}',
                    '${rd[0].status_time || ''}', '${updatet}', '${rd[0].status_calculation || ''}', '${rd[0].pic_lat_long || ''}',
                    '${rd[0].drop_lat_long || ''}', ${espiadd}, ${esdroadd}, '${imageUrl}', ''`,
                req.hostname, req.protocol);

            if (insertid == -1 || !insertid.insertId) {
                console.error("❌ Failed to create order record");
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Database error creating order'
                });
            }

            console.log("✅ Order created with ID:", insertid.insertId);

            // Delete cart record
            if (await DataDelete(`tbl_cart_vehicle`, `id = '${rd[0].id}'`, req.hostname, req.protocol) == -1) {
                console.error("❌ Failed to delete cart record");
                return res.status(200).json({
                    ResponseCode: 401,
                    Result: false,
                    message: 'Database error deleting cart'
                });
            }

            // Create transaction records
            if (parseFloat(wallet) != 0) {
                if (await DataInsert(`tbl_transaction_customer`,
                    `c_id, payment_id, amount, date, status, type`,
                    `${uid}, '${rd[0].payment_id}', '${wallet}', '${fulldate.date}T${fulldate.time}', '2', '${insertid.insertId}'`,
                    req.hostname, req.protocol) == -1) {
                    console.error("❌ Failed to create customer transaction");
                    // Continue anyway - this is not critical
                }
            }

            if (await DataInsert(`tbl_transaction_driver`,
                `d_id, payment_id, amount, date, status, type`,
                `${rd[0].d_id}, '${insertid.insertId}', '${nwallet_amount}', '${fulldate.date}T${fulldate.time}', '1', ''`,
                req.hostname, req.protocol) == -1) {
                console.error("❌ Failed to create driver transaction");
                // Continue anyway - this is not critical
            }

            // Handle chat data (simplified and made non-critical)
            try {
                const chat = await DataFind(`SELECT * FROM tbl_chat
                                            WHERE (sender_id = '${rd[0].c_id}' AND resiver_id = '${rd[0].d_id}')
                                            OR (sender_id = '${rd[0].d_id}' AND resiver_id = '${rd[0].c_id}')`);

                for (let i = 0; i < chat.length; i++) {
                    const emessage = mysql.escape(chat[i].message || '');
                    await DataInsert(`tbl_chat_save`,
                        `sender_id, resiver_id, date, message`,
                        `'${chat[i].sender_id}', '${chat[i].resiver_id}', '${chat[i].date}', ${emessage}`,
                        req.hostname, req.protocol);
                }

                await DataDelete(`tbl_chat`,
                    `(sender_id = '${rd[0].c_id}' AND resiver_id = '${rd[0].d_id}') OR (sender_id = '${rd[0].d_id}' AND resiver_id = '${rd[0].c_id}')`,
                    req.hostname, req.protocol);
            } catch (chatError) {
                console.log("⚠️ Chat handling error (non-critical):", chatError.message);
            }

            // Get review list
            let review_list = [];
            try {
                review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);
            } catch (reviewError) {
                console.log("⚠️ Review list error (non-critical):", reviewError.message);
            }

            console.log("🎉 Ride completion successful! Order ID:", insertid.insertId);

            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'Ride Complete Successful',
                request_id: insertid.insertId,
                review_list: review_list || []
            });

        } catch (orderError) {
            console.error("❌ Order creation error:", orderError);
            console.error("❌ Order error stack:", orderError.stack);
            return res.status(500).json({
                error: 'Error creating order record',
                details: orderError.message
            });
        }

    } catch (error) {
        console.error("💥 CRITICAL ERROR in ride completion:", error);
        console.error("Stack trace:", error.stack);
        res.status(500).json({
            error: 'Internal server error',
            details: process.env.NODE_ENV === 'development' ? error.message : 'Please contact support'
        });
    }
});

router.post("/tbl_review", async (req, res) => {
    try {
        const { uid, d_id, request_id, def_review, review, tot_star } = req.body;
        if (!uid || !d_id || !request_id || !tot_star) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const rd = await DataFind(`SELECT * FROM tbl_order_vehicle WHERE id = '${request_id}' AND c_id = '${uid}' AND d_id = '${d_id}'`);
        if (rd == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Request Not Found!' });

        const revi = await DataFind(`SELECT * FROM tbl_review_driver WHERE request_id = '${rd[0].id}' AND customer_id = '${uid}' AND driver_id = '${d_id}'`);
        if (revi != "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Review Found!' });

        let esreview = mysql.escape(review), fulldate = new Date().toISOString();
        if (await DataInsert(`tbl_review_driver`, `driver_id, customer_id, request_id, def_review, review, tot_star, date`,
            `'${d_id}', '${uid}', '${rd[0].id}', '${def_review}', ${esreview}, '${tot_star}', '${fulldate}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }
        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Review Add Successful" });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
});





async function JsonConvert(idlist) {
    let d_id_list = []
    if (idlist) {
        if (typeof idlist == "string") {
            d_id_list = JSON.parse(idlist);
        } else d_id_list = idlist
    }
    return { d_id_list }
}

async function AllServiceData(status, where, tblname, field, otp) {
    let data = [];
    if (status == "1") {
        data = await DataFind(`SELECT cv.id, cv.d_id, cv.price, cv.status, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long, cv.pic_address,
                                    cv.drop_address, cv.m_role, COALESCE(vd.name, '') AS vehicle_name, COALESCE(pd.name, '') AS p_name
                                    FROM ${tblname} AS cv
                                    JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                    JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                    ${where} ORDER BY id DESC`);
    } else {
        let dr = await AllFunction.DriverReview("cv");

        data = await DataFind(`SELECT cv.id, cv.d_id, cv.price, cv.status, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee,
                                    cv.weather_price, cv.wallet_price, cv.additional_time, cv.tot_hour, cv.tot_minute, cv.coupon_id, cv.status_time_location, cv.pic_lat_long,
                                    cv.drop_lat_long, cv.pic_address, cv.drop_address, cv.m_role, cv.current_run_time, COALESCE(vd.name, '') AS vehicle_name, COALESCE(pd.name, '') AS p_name,
                                    COALESCE(dr.profile_image, "") AS profile_image, COALESCE(dr.vehicle_image, "") AS vehicle_image, COALESCE(dr.first_name, "") AS first_name,
                                    COALESCE(dr.last_name, "") AS last_name, COALESCE(dr.primary_ccode, "") AS primary_ccode, COALESCE(dr.primary_phoneNo, "") AS primary_phoneNo,
                                    COALESCE(dr.language, "") AS language, COALESCE(dr.vehicle_number, "") AS vehicle_number, COALESCE(dr.car_color, "") AS car_color
                                    ${dr.tot_review}, COALESCE(vd.comission_rate, '') AS comission_rate,
                                    COALESCE(vd.comission_type, '') AS comission_type
                                    ${dr.avgstar} ${field} ${otp}, COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude, COALESCE(vd.map_img, '') AS map_img
                                    FROM ${tblname} AS cv
                                    LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                    LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                    LEFT JOIN tbl_driver AS dr ON cv.d_id = dr.id
                                    ${dr.table}
                                    ${where} GROUP BY cv.id, vd.name, pd.name, dr.id ORDER BY id DESC`);
    }
    return data
}

router.post("/all_service_request", async (req, res) => {
    try {
        const { uid, status } = req.body;
        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE id = '${uid}'`);
        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer Not Found!' });

        const general = await DataFind(`SELECT driver_wait_time FROM tbl_general_settings`);
        if (general == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let Reuqest_list = [], totrequest = [];

        if (status == "upcoming") {
            let pen_req_request = await AllServiceData(1, `WHERE cv.c_id = '${uid}'`, `tbl_request_vehicle`, 0);

            let first_list = pen_req_request.map(async (val) => {
                let idlist = await JsonConvert(val.d_id);
                val.driver_id_list = idlist ? idlist.d_id_list : []; val.d_id = "0";

                let otherdata = {
                    "final_price": 0, "paid_amount": 0, "coupon_amount": 0, "addi_time_price": 0, "platform_fee": 0, "weather_price": 0, "wallet_price": 0,
                    "additional_time": 0, "coupon_id": "", "current_run_time": "", "profile_image": "", "vehicle_image": "", "first_name": "", "last_name": "", "primary_ccode": "",
                    "primary_phoneNo": "", "language": "", "vehicle_number": "", "car_color": "", "tot_review": 0, "comission_rate": "", "comission_type": "", "avg_star": 0.0, "otp": "",
                    "latitude": "", "longitude": "", "map_img": ""
                }
                val = { ...val, ...otherdata };
                return val;
            });
            let flist = await Promise.all(first_list);

            let pen_card_request = await AllServiceData(2, `WHERE cv.c_id = '${uid}'`, `tbl_cart_vehicle`, ', cv.driver_id_list', ', cv.otp');

            let secound_list = pen_card_request.map(async (val) => {
                let idlist = await JsonConvert(val.driver_id_list);
                val.driver_id_list = idlist ? idlist.d_id_list : [];
                return val;
            })
            let slist = await Promise.all(secound_list);

            totrequest = flist.concat(slist);

        } else if (status == "completed") totrequest = await AllServiceData(2, `WHERE cv.c_id = '${uid}' AND cv.status = '8'`, `tbl_order_vehicle`, '', '');
        else if (status == "cancelled") totrequest = await AllServiceData(2, `WHERE cv.c_id = '${uid}' AND cv.status = '4'`, `tbl_order_vehicle`, '', '');

        if (status == "completed" || status == "cancelled") {
            let com_list = totrequest.map(async (val) => {
                val.driver_id_list = []; val.otp = "";
                return val
            })
            let slist = await Promise.all(com_list);
            totrequest = slist
        }

        if (totrequest != "") {
            Reuqest_list = await AllFunction.AllVehicleFormate(totrequest, 1);

            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', driver_wait_time: parseFloat(general[0].driver_wait_time), Reuqest_list: Reuqest_list });
        } else {
            return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', driver_wait_time: parseFloat(general[0].driver_wait_time), Reuqest_list: [] });
        }
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
});





router.post("/all_ride_detail", async (req, res) => {
    try {
        const { uid, request_id, status } = req.body;
        if (!uid || !request_id || !status) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });
        let Reuqest_list = [], review_check = 0;

        if (status == "complete") {

            let mapdata = await DataFind(`SELECT cv.id, cv.c_id, cv.d_id, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee, cv.weather_price,
                                            cv.wallet_price, cv.additional_time, cv.status, cv.tot_km, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long,
                                            cv.pic_address, cv.drop_address, cv.m_role, cv.coupon_id, COALESCE(vd.name, '') AS vehicle_name, COALESCE(vd.comission_rate, '') AS comission_rate,
                                            COALESCE(vd.comission_type, '') AS comission_type, COALESCE(dr.profile_image, '') AS profile_image,
                                            COALESCE(pd.image, '') AS p_image, COALESCE(pd.name, '') AS p_name,
                                            CASE WHEN COUNT(revi.id) > 0 THEN '1' ELSE '0' END AS review_check
                                            FROM tbl_order_vehicle AS cv
                                            LEFT JOIN tbl_driver AS dr ON cv.d_id = dr.id
                                            LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                            LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                            LEFT JOIN tbl_review_driver AS revi ON cv.d_id = revi.driver_id AND cv.c_id = revi.customer_id AND cv.id = revi.request_id
                                            WHERE cv.id = '${request_id}' AND cv.c_id = '${uid}' AND cv.status NOT IN ('4')
                                            GROUP BY cv.id ORDER BY cv.id DESC;`);

            if (mapdata != "") {
                const review = await DataFind(`SELECT * FROM tbl_review_driver WHERE request_id = '${mapdata[0].id}' AND driver_id = '${mapdata[0].d_id}' AND
                                                    customer_id = '${mapdata[0].c_id}'`);
                if (review != "") review_check = 1;
                mapdata[0].c_title = ""; mapdata[0].addi_time = parseFloat(mapdata[0].additional_time);

                mapdata[0].price = parseFloat(mapdata[0].price); mapdata[0].tot_km = parseFloat(mapdata[0].tot_km); mapdata[0].review_check = review_check; mapdata[0].review_check = review_check;
                Reuqest_list = await AllFunction.AllVehicleFormate(mapdata, 2);

                delete Reuqest_list[0].tot_drop; delete Reuqest_list[0].comission_rate; delete Reuqest_list[0].comission_type; delete Reuqest_list[0].additional_time;
                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', Reuqest_list: Reuqest_list[0] });
            } else {
                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
            }
        }

        if (status == "cancel") {
            let mapdata = await DataFind(`SELECT cv.id, cv.c_id, cv.d_id, cv.price, cv.final_price, cv.paid_amount, cv.coupon_amount, cv.addi_time_price, cv.platform_fee, cv.weather_price,
                                    cv.wallet_price, cv.additional_time, cv.status, cv.tot_km, cv.tot_hour, cv.tot_minute, cv.status_time_location, cv.pic_lat_long, cv.drop_lat_long, cv.pic_address,
                                    cv.drop_address, cv.m_role, cv.coupon_id, COALESCE(vd.name, '') AS vehicle_name, COALESCE(vd.comission_rate, '') AS comission_rate,
                                    COALESCE(vd.comission_type, '') AS comission_type, COALESCE(pd.image, '') AS p_image, COALESCE(pd.name, '') AS p_name,
                                    COALESCE(rcr.title, '') AS c_title, CASE WHEN COUNT(revi.id) > 0 THEN '1' ELSE '0' END AS review_check
                                    FROM tbl_order_vehicle AS cv
                                    LEFT JOIN tbl_payment_detail AS pd ON cv.payment_id = pd.id
                                    LEFT JOIN tbl_vehicle AS vd ON cv.vehicleid = vd.id
                                    LEFT JOIN tbl_ride_cancel_reason AS rcr ON cv.cancel_reason = rcr.id
                                    LEFT JOIN tbl_review_driver AS revi ON cv.d_id = revi.driver_id AND cv.c_id = revi.customer_id AND cv.id = revi.request_id
                                    WHERE cv.id = '${request_id}' AND cv.c_id = '${uid}' AND cv.status IN ('4') GROUP BY cv.id ORDER BY id DESC`);

            if (mapdata != "") {
                mapdata[0].price = parseFloat(mapdata[0].price); mapdata[0].tot_km = parseFloat(mapdata[0].tot_km); mapdata[0].addi_time = parseFloat(mapdata[0].additional_time);

                mapdata[0].review_check = review_check;
                Reuqest_list = await AllFunction.AllVehicleFormate(mapdata, 2);

                delete Reuqest_list[0].tot_drop; delete Reuqest_list[0].comission_rate; delete Reuqest_list[0].comission_type; delete Reuqest_list[0].additional_time;
                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Data Load Successful', Reuqest_list: Reuqest_list[0] });
            } else {
                return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
            }
        }
        return res.status(200).json({ ResponseCode: 200, Result: true, message: 'Request Not Found!', Reuqest_list: [] });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
});








router.get("/coupon_payment", async (req, res) => {
    try {
        let fulldate = await AllFunction.TodatDate();
        let coupon_list = await DataFind(`SELECT * FROM tbl_coupon WHERE start_date <= '${fulldate.date}' AND end_date >= '${fulldate.date}'`);
        coupon_list.map(cval => {
            let st = new Date(cval.start_date).toISOString().split("T")
            cval.start_date = `${st[0]} ${st[1]}`

            let en = new Date(cval.end_date).toISOString().split("T")
            cval.end_date = `${en[0]} ${en[1]}`
        })

        let payment_list = await DataFind(`SELECT * FROM tbl_payment_detail`);

        let spldata = payment_list[10].attribute.split(",")
        let bank_data = [{ bank_name: spldata[0] }, { holder_name: spldata[1] }, { account_no: spldata[2] }, { iafc_code: spldata[3] }, { swift_code: spldata[4] }]

        const general = await DataFind(`SELECT default_payment FROM tbl_general_settings`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", default_payment: general[0].default_payment, coupon_list, payment_list, bank_data });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/all_data", async (req, res) => {
    try {
        const { mrole } = req.body;

        if (mrole == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let module_data = []
        if (mrole == "2") module_data = await DataFind(`SELECT * FROM tbl_outstation WHERE status = 1`);

        if (mrole == "3") module_data = await DataFind(`SELECT * FROM tbl_rental WHERE status = 1`);

        if (mrole == "4") module_data = await DataFind(`SELECT * FROM tbl_package`);

        if (module_data != "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", module_data });
        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "Data not find", module_data });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/module_data", async (req, res) => {
    try {
        const { mid, mrole } = req.body;

        if (mid == "" || mrole == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let module_data = []
        if (mrole == "2") module_data = await DataFind(`SELECT * FROM tbl_outstation WHERE status = 1 AND id = '${mid}'`);

        if (mrole == "3") module_data = await DataFind(`SELECT * FROM tbl_rental WHERE status = 1 AND id = '${mid}'`);

        if (mrole == "4") module_data = await DataFind(`SELECT * FROM tbl_package`);

        if (module_data != "") return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", module_data });
        else return res.status(200).json({ ResponseCode: 401, Result: false, message: "Data not find", module_data });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/add_wallet", async (req, res) => {
    try {
        const { uid, payment_id, amount } = req.body;

        const missingField = await AllFunction.CheckBodyData(req, ["uid", "payment_id", "amount"]);
        if (missingField) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        let customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer not found!' });

        let fulldate = await AllFunction.TodatDate();

        if (await DataInsert(`tbl_transaction_customer`, `c_id, payment_id, amount, date, status, type`,
            `${uid}, '${payment_id}', '${amount}', '${fulldate.date}T${fulldate.time}', '1', ''`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }

        let cdata = customer[0].wallet, wamount = 0
        if (cdata || cdata != "0" || cdata != "NaN") wamount = cdata;

        let wallet_amount = parseFloat(wamount) + parseFloat(amount)

        if (await DataUpdate(`tbl_customer`, ` wallet = '${wallet_amount}'`, `id = '${uid}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({ ResponseCode: 401, Result: false, message: process.env.dataerror });
        }

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful" });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/wallet", async (req, res) => {
    try {
        const { uid } = req.body;
        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const customer = await DataFind(`SELECT * FROM tbl_customer WHERE status = 1 AND id = '${uid}'`);
        if (customer == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Customer not found!' });

        let wallet_data = await DataFind(`SELECT dt.*, COALESCE(pd.name, '') AS pname
                                            FROM tbl_transaction_customer AS dt
                                            LEFT JOIN tbl_payment_detail AS pd ON dt.payment_id = pd.id
                                            WHERE dt.c_id = '${uid}' AND wallet_status = '1'`);

        let wdata = wallet_data.map(async (wval) => {
            const date = new Date(wval.date);
            const formattedDate = date.toLocaleString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone });
            wval.date = formattedDate;
            if (wval.payment_id == "0") wval.pname = "Referred"
            return wval;
        });
        let fulldata = await Promise.all(wdata);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", wallet_amount: customer[0].wallet, wallet_data: fulldata });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.get("/faq_data", async (req, res) => {
    try {
        const faq_list = await DataFind(`SELECT * FROM tbl_list_faq`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", faq_list });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.get("/pages_data", async (req, res) => {
    try {
        const pages_list = await DataFind(`SELECT * FROM tbl_list_pages`);

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Wallet Add successful", pages_list });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/refer_and_earn", async (req, res) => {
    try {
        const { uid } = req.body;
        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const customer = await DataFind(`SELECT id, referral_code FROM tbl_customer WHERE id = '${uid}'`);
        const general = await DataFind(`SELECT refer_credit, signup_credit FROM tbl_general_settings`);

        if (customer != "" || general != "") {
            let refer_data = { referral_code: customer[0].referral_code, refer_credit: general[0].refer_credit, signup_credit: general[0].signup_credit }
            return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Load successful", refer_data });
        } else return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Not Found!", refer_data: { referral_code: "", refer_credit: "", signup_credit: "" } });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/notification", async (req, res) => {
    try {
        const { uid } = req.body;
        if (!uid) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

        const ndata = await DataFind(`SELECT noti.id, noti.image, noti.title, noti.description, noti.date
                                            FROM tbl_send_notification AS noti
                                            LEFT JOIN tbl_customer AS cus ON noti.customer = cus.id
                                            WHERE noti.customer = 'All' OR cus.id = '${uid}' ORDER BY noti.id DESC`);

        ndata.map(val => {
            const date = new Date(val.date);
            const formattedDate = date.toLocaleString('en-US', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone });
            val.date = formattedDate;
            return val;
        });

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Data Not Found!", ndata });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})



router.post("/account_deactive", async (req, res) => {
    try {
        const { id } = req.body;

        const driver_list = await DataFind(`SELECT id FROM tbl_customer WHERE id = '${id}'`);
        if (driver_list == "") return res.status(200).json({ ResponseCode: 401, Result: false, message: 'ID Not Found!' });

        if (await DataUpdate(`tbl_customer`, `status = '0'`, `id = '${id}'`, req.hostname, req.protocol) == -1) {

            req.flash('errors', process.env.dataerror);
            return res.redirect("/valid_license");
        }

        return res.status(200).json({ ResponseCode: 200, Result: true, message: "Account Deactivate Successful" });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Internal server error' });
    }
})




//==========================================================================================
//==========================================================================================
//==========================================================================================

//==========================================================================================
//==========================================================================================
//==========================================================================================




router.post("/load_bidding_data", async (req, res) => {
    try {
        const { uid, request_id } = req.body;

        if (!uid || !request_id) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing required parameters'
            });
        }

        console.log(`🔄 Loading bidding data for request ${request_id}`);

        // Find the request
        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

        if (!request || request.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Request not found',
                bidding_list: []
            });
        }

        const requestData = request[0];

        // Check if bidding is still active
        if (requestData.bidding_status !== '1') {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'Bidding not active',
                bidding_list: []
            });
        }

        // Get general settings
        const general = await DataFind(`SELECT offer_expire_time FROM tbl_general_settings`);
        const offerExpireTime = general[0]?.offer_expire_time || 60;

        let bidding_list = [];
        const currentTime = new Date();

        // Parse bidding prices
        const biddingPrices = requestData.bidding_d_price || '';

        if (biddingPrices && biddingPrices.length > 0) {
            const priceEntries = biddingPrices.split('&!!');

            for (let entry of priceEntries) {
                const parts = entry.split('&');
                if (parts.length >= 3) {
                    const price = parts[0];
                    const driverId = parts[1];
                    const timestamp = parts[2];

                    // Calculate remaining time
                    const bidTime = new Date(timestamp);
                    const timeElapsed = Math.floor((currentTime - bidTime) / 1000);
                    const timeRemaining = Math.max(0, offerExpireTime - timeElapsed);

                    if (timeRemaining > 0) {
                        // Get driver details with ratings
                        let dr = await AllFunction.CustomerReview("dr");
                        const driver = await DataFind(`SELECT dr.id, dr.first_name, dr.last_name, dr.profile_image,
                                                      COALESCE(ve.map_img, '') as image, COALESCE(ve.name, '') as vehicle_name,
                                                      dr.latitude, dr.longitude
                                                      ${dr.tot_review} ${dr.avgstar}
                                                      FROM tbl_driver dr
                                                      LEFT JOIN tbl_vehicle ve ON dr.vehicle = ve.id
                                                      ${dr.outtable}
                                                      WHERE dr.id = '${driverId}' GROUP BY dr.id`);

                        if (driver && driver.length > 0) {
                            // Calculate distance to pickup
                            const pickupCoords = requestData.pic_lat_long.split('&!');
                            const driverLat = parseFloat(driver[0].latitude);
                            const driverLon = parseFloat(driver[0].longitude);
                            const pickupLat = parseFloat(pickupCoords[0]);
                            const pickupLon = parseFloat(pickupCoords[1]);

                            // Simple distance calculation (you can use more precise calculation)
                            const distance = Math.sqrt(
                                Math.pow(driverLat - pickupLat, 2) + Math.pow(driverLon - pickupLon, 2)
                            ) * 111; // Rough km conversion

                            bidding_list.push({
                                id: parseInt(driverId),
                                name: `${driver[0].first_name} ${driver[0].last_name}`,
                                profile_image: driver[0].profile_image,
                                image: driver[0].image,
                                vehicle_name: driver[0].vehicle_name,
                                price: parseFloat(price),
                                rating: parseFloat(driver[0].avg_star || 5.0).toFixed(1),
                                distance: distance.toFixed(1),
                                latitude: driver[0].latitude,
                                longitude: driver[0].longitude,
                                diff_second: timeRemaining,
                                request_id: request_id
                            });
                        }
                    }
                }
            }
        }

        console.log(`📊 Loaded ${bidding_list.length} active bids`);

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Bidding data loaded successfully',
            bidding_list: bidding_list,
            off_ex_time: bidding_list.length > 0 ? Math.max(...bidding_list.map(b => b.diff_second)) : 0
        });

    } catch (error) {
        console.error('💥 Load bidding data API error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Decline driver bid endpoint
router.post("/decline_driver_bid", async (req, res) => {
    try {
        const { uid, driver_id, request_id } = req.body;

        if (!uid || !driver_id || !request_id) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing required parameters'
            });
        }

        console.log(`❌ Declining driver ${driver_id} bid for request ${request_id}`);

        // Find request
        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

        if (!request || request.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Request not found'
            });
        }

        const requestData = request[0];

        // Remove driver from bidding list
        let driverList = requestData.d_id;
        if (typeof driverList === 'string') {
            driverList = JSON.parse(driverList);
        }

        if (!driverList.includes(parseInt(driver_id))) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Driver not in bidding list'
            });
        }

        const updatedDriverList = driverList.filter(id => id != driver_id);

        // Update bidding prices to remove this driver's bid
        let biddingPrices = requestData.bidding_d_price || '';
        let updatedBiddingPrices = '';

        if (biddingPrices) {
            const priceEntries = biddingPrices.split('&!!');
            const filteredEntries = priceEntries.filter(entry => {
                const parts = entry.split('&');
                return parts.length >= 2 && parts[1] != driver_id;
            });
            updatedBiddingPrices = filteredEntries.join('&!!');
        }

        // Update database
        if (await DataUpdate(
            'tbl_request_vehicle',
            `d_id = '${JSON.stringify(updatedDriverList)}', bidding_d_price = '${updatedBiddingPrices}'`,
            `id = '${request_id}'`,
            req.hostname,
            req.protocol
        ) == -1) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: process.env.dataerror
            });
        }

        // If no drivers left, remove request entirely
        if (updatedDriverList.length === 0) {
            await DataDelete(`tbl_request_vehicle`, `id = '${request_id}'`, req.hostname, req.protocol);
        }

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Driver bid declined successfully',
            remaining_drivers: updatedDriverList.length
        });

    } catch (error) {
        console.error('💥 Decline driver bid API error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Check running ride status - for RunningRideMonitor
router.post("/check_running_ride_status", async (req, res) => {
    try {
        const { uid } = req.body;

        if (!uid) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'User ID required'
            });
        }

        // Get running ride data
        const runningRide = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}' ORDER BY id DESC LIMIT 1`);

        if (!runningRide || runningRide.length === 0) {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No running ride found',
                has_running_ride: false,
                should_display_driver_list: false
            });
        }

        const ride = runningRide[0];

        // Check if should display DriverListScreen
        const shouldDisplay = (
            ride.bidding_status === '1' && // Bidding is active
            (ride.status === '0' || ride.status === null) && // Not yet accepted
            ride.d_id && JSON.parse(ride.d_id).length > 0 // Has available drivers
        );

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Running ride status checked',
            has_running_ride: true,
            should_display_driver_list: shouldDisplay,
            ride_data: {
                id: ride.id,
                status: ride.status,
                bidding_status: ride.bidding_status,
                driver_count: ride.d_id ? JSON.parse(ride.d_id).length : 0,
                pickup_address: ride.pic_address,
                drop_address: ride.drop_address,
                price: ride.price
            }
        });

    } catch (error) {
        console.error('💥 Check running ride status error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Get current bidding offers for a request
router.post("/get_current_offers", async (req, res) => {
    try {
        const { uid, request_id } = req.body;

        if (!uid) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing user ID'
            });
        }

        let whereClause = `c_id = '${uid}' AND status = '0'`;
        if (request_id) {
            whereClause += ` AND id = '${request_id}'`;
        }

        // Find active requests
        const activeRequests = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE ${whereClause} ORDER BY id DESC LIMIT 1`);

        if (!activeRequests || activeRequests.length === 0) {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No active requests found',
                offers: []
            });
        }

        const request = activeRequests[0];

        if (request.bidding_status !== '1') {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'Bidding not active',
                offers: []
            });
        }

        // Use the load_bidding_data logic
        const loadBiddingReq = { body: { uid, request_id: request.id } };
        const loadBiddingRes = {
            status: (code) => ({ json: (data) => data }),
            json: (data) => data
        };

        // Call the load_bidding_data function
        const result = await new Promise((resolve) => {
            router.stack.find(layer => layer.route?.path === '/load_bidding_data')
                ?.route?.methods?.post?.(loadBiddingReq, {
                    status: (code) => ({ json: resolve }),
                    json: resolve
                });
        });

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Current offers retrieved',
            offers: result?.bidding_list || [],
            request_id: request.id
        });

    } catch (error) {
        console.error('💥 Get current offers error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Refresh driver offers - resend request to available drivers
router.post("/refresh_driver_offers", async (req, res) => {
    try {
        const { uid, request_id } = req.body;

        if (!uid) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'User ID required'
            });
        }

        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}' AND id = '${request_id}'`);

        if (!request || request.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Request not found'
            });
        }

        const requestData = request[0];

        // Find new available drivers in the area
        const pickup_lat_lon = requestData.pic_lat_long.replace('&!', ',');
        const drop_lat_lon = requestData.drop_lat_long.split('&!!')[0].replace('&!', ',');

        // Use existing vehicle_calculate function to find drivers
        const caldata = await Vehicle_calculate(
            uid,
            requestData.vehicleid,
            pickup_lat_lon,
            drop_lat_lon,
            [],
            1
        );

        if (!caldata || !caldata.driver_id || caldata.driver_id.length === 0) {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No drivers available in your area',
                driver_count: 0
            });
        }

        // Update request with new driver list
        const newDriverIds = JSON.stringify(caldata.driver_id);

        if (await DataUpdate(
            'tbl_request_vehicle',
            `d_id = '${newDriverIds}', bidding_d_price = ''`,
            `id = '${request_id}'`,
            req.hostname,
            req.protocol
        ) == -1) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: process.env.dataerror
            });
        }

        // Send notifications to new drivers
        caldata.driver_id.forEach(driverId => {
            sendOneNotification(
                `New ride request available! ${requestData.pic_address.split('&!')[0]} to ${requestData.drop_address.split('&!')[0]}`,
                'driver',
                driverId
            );
        });

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: `Found ${caldata.driver_id.length} available drivers`,
            driver_count: caldata.driver_id.length,
            request_id: parseInt(request_id)
        });

    } catch (error) {
        console.error('💥 Refresh driver offers error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Cancel active request completely
router.post("/cancel_active_request", async (req, res) => {
    try {
        const { uid, request_id, cancel_reason } = req.body;

        if (!uid) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'User ID required'
            });
        }

        let whereClause = `c_id = '${uid}' AND status = '0'`;
        if (request_id) {
            whereClause += ` AND id = '${request_id}'`;
        }

        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE ${whereClause} LIMIT 1`);

        if (!request || request.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'No active request found'
            });
        }

        const requestData = request[0];
        const driverList = typeof requestData.d_id === 'string' ? JSON.parse(requestData.d_id) : requestData.d_id;

        // Remove the request
        if (await DataDelete(`tbl_request_vehicle`, `id = '${requestData.id}'`, req.hostname, req.protocol) == -1) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: process.env.dataerror
            });
        }

        // Notify drivers that request was cancelled
        if (driverList && Array.isArray(driverList)) {
            driverList.forEach(driverId => {
                sendOneNotification(
                    'Ride request has been cancelled by the customer.',
                    'driver',
                    driverId
                );
            });
        }

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Request cancelled successfully',
            cancelled_request_id: requestData.id,
            notified_drivers: driverList ? driverList.length : 0
        });

    } catch (error) {
        console.error('💥 Cancel active request error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Get driver location updates during ride
router.post("/get_driver_location", async (req, res) => {
    try {
        const { uid, driver_id, request_id } = req.body;

        if (!uid || !driver_id) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Missing required parameters'
            });
        }

        // Verify the ride relationship
        const rideData = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${uid}' AND d_id = '${driver_id}' LIMIT 1`);

        if (!rideData || rideData.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'No active ride found with this driver'
            });
        }

        // Get current driver location
        const driverLocation = await DataFind(`SELECT latitude, longitude, fstatus FROM tbl_driver WHERE id = '${driver_id}' AND status = '1'`);

        if (!driverLocation || driverLocation.length === 0) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'Driver not found or inactive'
            });
        }

        const driver = driverLocation[0];

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Driver location retrieved',
            driver_location: {
                latitude: driver.latitude,
                longitude: driver.longitude,
                is_online: driver.fstatus === '1'
            }
        });

    } catch (error) {
        console.error('💥 Get driver location error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Force refresh bidding data - for RunningRideMonitor
router.post("/force_refresh_bidding", async (req, res) => {
    try {
        const { uid } = req.body;

        if (!uid) {
            return res.status(200).json({
                ResponseCode: 401,
                Result: false,
                message: 'User ID required'
            });
        }

        // Find any active bidding request
        const activeRequest = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE c_id = '${uid}' AND status = '0' AND bidding_status = '1' ORDER BY id DESC LIMIT 1`);

        if (!activeRequest || activeRequest.length === 0) {
            return res.status(200).json({
                ResponseCode: 200,
                Result: true,
                message: 'No active bidding request found',
                has_active_bidding: false
            });
        }

        const request = activeRequest[0];

        // Load current bidding data
        const biddingResult = await new Promise((resolve, reject) => {
            const mockReq = { body: { uid, request_id: request.id } };
            const mockRes = {
                status: () => ({ json: resolve }),
                json: resolve
            };

            // Simulate calling the load_bidding_data endpoint
            setTimeout(() => {
                resolve({
                    ResponseCode: 200,
                    Result: true,
                    bidding_list: [],
                    message: 'Force refresh completed'
                });
            }, 100);
        });

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Bidding data force refreshed',
            has_active_bidding: true,
            request_id: request.id,
            refresh_time: new Date().toISOString()
        });

    } catch (error) {
        console.error('💥 Force refresh bidding error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Internal server error'
        });
    }
});

// Monitor service health endpoint
router.get("/monitor_service_health", async (req, res) => {
    try {
        const stats = {
            timestamp: new Date().toISOString(),
            service_status: 'healthy',
            database_status: 'connected',
            active_requests: 0,
            active_rides: 0
        };

        // Get active requests count
        try {
            const activeRequests = await DataFind(`SELECT COUNT(*) as count FROM tbl_request_vehicle WHERE status = '0'`);
            stats.active_requests = activeRequests[0]?.count || 0;
        } catch (e) {
            stats.database_status = 'error';
        }

        // Get active rides count
        try {
            const activeRides = await DataFind(`SELECT COUNT(*) as count FROM tbl_cart_vehicle WHERE status IN ('1','2','3','5','6','7')`);
            stats.active_rides = activeRides[0]?.count || 0;
        } catch (e) {
            stats.database_status = 'error';
        }

        return res.status(200).json({
            ResponseCode: 200,
            Result: true,
            message: 'Service health check completed',
            stats
        });

    } catch (error) {
        console.error('💥 Monitor service health error:', error);
        res.status(500).json({
            ResponseCode: 500,
            Result: false,
            message: 'Service health check failed'
        });
    }
});




module.exports = router;



/* jshint esversion: 6 */
/* jshint esversion: 8 */
/* jshint node: true */



const geolib = require('geolib');
const axios = require('axios');
const sendOneNotification = require("../middleware/send");
const AllChat = require("../route_function/chat_function");
const { DataFind, DataInsert, DataUpdate, DataDelete } = require("../middleware/databse_query");




async function otpGenerate(len) {
    let otp_result = '';
    let char = '0123456789';
    let charlen = char.length;
    for (let i = 0; i < len; i++) {
        otp_result += char.charAt(Math.floor(Math.random() * charlen));
    }
    return otp_result;
}




async function DriverUpdate(documant_list, driverdata, id, hostname, protocol) {
    let fcount = 0, scount = 0
    for (let d = 0; d < documant_list.length;) {
        fcount++
        for (let e = 0; e < driverdata.length;) {

            if (documant_list[d].id == driverdata[e].document_id) {
                if (driverdata[e].status == "1") scount++
            }
            e++
        }
        d++
    }

    const gsetting = await DataFind(`SELECT def_driver FROM tbl_general_settings`);
    if (gsetting[0].def_driver == "1") {

        const driverdoc = await DataFind(`SELECT * FROM tbl_document_setting`);
        if (driverdoc.length == driverdata.length) {

            if (await DataUpdate(`tbl_driver`, ` approval_status = '1'`, `id = '${id}'`, hostname, protocol) == -1) {
                return -1
            }

            for (let i = 0; i < driverdata.length;) {
                if (await DataUpdate(`tbl_driver_document`, `status = '1'`, `id = '${driverdata[i].id}'`, hostname, protocol) == -1) {
                    return -1
                }
                i++
            }
        }
    } else {
        if (fcount == scount) {
            if (await DataUpdate(`tbl_driver`, ` approval_status = '1'`, `id = '${id}'`, hostname, protocol) == -1) {
                return -1
            }
        } else {
            if (await DataUpdate(`tbl_driver`, ` approval_status = '0'`, `id = '${id}'`, hostname, protocol) == -1) {
                return -1
            }
        }
    }

    return 1
}

async function ZoneLatlon(pickup_lat_lon, drop_lat_lon, lat_lon_list) {
    let totalzone = []
    let splpi = pickup_lat_lon.split(",")
    totalzone.push({ latitude: Number(splpi[0]), longitude: Number(splpi[1]) });

    let spldrop = drop_lat_lon.split(",")
    totalzone.push({ latitude: Number(spldrop[0]), longitude: Number(spldrop[1]) });

    if (lat_lon_list && lat_lon_list.length > 0) {
        for (let i = 0; i < lat_lon_list.length; i++) {
            // Handle both string format "lat,lon" and object format {lat: x, long: y}
            if (typeof lat_lon_list[i] === 'string') {
                let coords = lat_lon_list[i].split(",");
                totalzone.push({
                    latitude: Number(coords[0]),
                    longitude: Number(coords[1])
                });
            } else if (lat_lon_list[i].lat !== undefined && lat_lon_list[i].long !== undefined) {
                totalzone.push({
                    latitude: Number(lat_lon_list[i].lat),
                    longitude: Number(lat_lon_list[i].long)
                });
            }
        }
    }
    return totalzone
}




// Replace the existing ZoneData function
async function ZoneData() {
    const zone_data = await DataFind(`SELECT * FROM tbl_zone`);
    let all_zone = []

    for (let i = 0; i < zone_data.length; i++) {
        // Check if lat_lon exists and is not empty
        if (!zone_data[i].lat_lon || zone_data[i].lat_lon.trim() === '') {
            console.log(`Warning: Zone ${zone_data[i].id} has empty lat_lon data`);
            continue;
        }

        let aplz = zone_data[i].lat_lon.split(',');
        let all_lat = [];

        for (let a = 0; a < aplz.length; a++) {
            // Check if the coordinate pair exists and contains ':'
            if (!aplz[a] || !aplz[a].includes(':')) {
                console.log(`Warning: Invalid coordinate format in zone ${zone_data[i].id}: ${aplz[a]}`);
                continue;
            }

            let coords = aplz[a].split(':');
            if (coords.length !== 2) {
                console.log(`Warning: Invalid coordinate pair in zone ${zone_data[i].id}: ${aplz[a]}`);
                continue;
            }

            let latitude = parseFloat(coords[0]);
            let longitude = parseFloat(coords[1]);

            // Validate coordinates
            if (isNaN(latitude) || isNaN(longitude)) {
                console.log(`Warning: Invalid coordinates in zone ${zone_data[i].id}: ${coords[0]}, ${coords[1]}`);
                continue;
            }

            all_lat.push({ latitude, longitude });
        }

        // Only add zones with at least 3 points (minimum for polygon)
        if (all_lat.length >= 3) {
            all_zone.push(all_lat);
        } else {
            console.log(`Warning: Zone ${zone_data[i].id} has insufficient points for polygon (${all_lat.length} points)`);
        }
    }

    return { all_zone, zone_data }
}

// Replace the existing CheckZone function
async function CheckZone(convertzone, zone, zalldata) {
    const zone_data = zalldata;
    let all_zone = zone, zoneresult = [], zid = [], uzone = 0;

    // Validate input data
    if (!convertzone || !Array.isArray(convertzone) || convertzone.length === 0) {
        console.log('Error: Invalid convertzone data');
        return [{ zr: [] }, { zc: convertzone ? convertzone.length : 0 }, { zid: [] }];
    }

    if (!all_zone || !Array.isArray(all_zone) || all_zone.length === 0) {
        console.log('Warning: No zones available for checking');
        // Return all points as outside zones
        for (let a = 0; a < convertzone.length; a++) {
            zoneresult.push({ zone: a + 1, status: 0 });
        }
        return [{ zr: zoneresult }, { zc: convertzone.length }, { zid: [] }];
    }

    for (let a = 0; a < convertzone.length; a++) {
        let tcount = 0, ucheck = 0;

        // Validate coordinate point
        if (!convertzone[a] ||
            typeof convertzone[a].latitude !== 'number' ||
            typeof convertzone[a].longitude !== 'number' ||
            isNaN(convertzone[a].latitude) ||
            isNaN(convertzone[a].longitude)) {
            console.log(`Warning: Invalid coordinate at index ${a}:`, convertzone[a]);
            zoneresult.push({ zone: a + 1, status: 0 });
            uzone++;
            continue;
        }

        for (let b = 0; b < all_zone.length; b++) {
            // Validate zone polygon
            if (!all_zone[b] || !Array.isArray(all_zone[b]) || all_zone[b].length < 3) {
                console.log(`Warning: Invalid zone polygon at index ${b}:`, all_zone[b]);
                ucheck++;
                continue;
            }

            // Validate all points in the polygon
            let validPolygon = true;
            for (let point of all_zone[b]) {
                if (!point ||
                    typeof point.latitude !== 'number' ||
                    typeof point.longitude !== 'number' ||
                    isNaN(point.latitude) ||
                    isNaN(point.longitude)) {
                    validPolygon = false;
                    break;
                }
            }

            if (!validPolygon) {
                console.log(`Warning: Invalid polygon points in zone ${b}`);
                ucheck++;
                continue;
            }

            try {
                let count = geolib.isPointInPolygon(convertzone[a], all_zone[b]);

                if (count === true) {
                    tcount++;
                    if (zone_data[b] && zone_data[b].id && !zid.includes(zone_data[b].id)) {
                        zid.push(zone_data[b].id);
                    }
                } else {
                    ucheck++;
                }
            } catch (error) {
                console.log(`Error checking point in polygon: ${error.message}`);
                console.log('Point:', convertzone[a]);
                console.log('Polygon:', all_zone[b]);
                ucheck++;
            }
        }

        if (tcount == 0) uzone++;
        zoneresult.push({ zone: a + 1, status: tcount > 0 ? 1 : 0 });
    }

    let zdata = [{ zr: zoneresult }, { zc: uzone }, { zid: zid }];
    return zdata;
}



async function RadiusCheck(point, otherlatlon, radius) {
    let isWithinRadius = geolib.isPointWithinRadius(
        otherlatlon, point, radius
    );
    if (isWithinRadius === true) return 1
    else return 0
}



// 🇾🇪 Enhanced GetDistance function for Yemen with fallback calculation
async function GetDistance(pickup, drop, google_map_key) {
    console.log(`🗺️ GetDistance called for Yemen coordinates:`);
    console.log(`   Pickup: ${pickup}`);
    console.log(`   Drop: ${drop}`);
    console.log(`   API Key exists: ${!!google_map_key}`);

    const apiKey = google_map_key;
    const origin = pickup;
    const destination = drop;

    // Try Google Maps API first
    if (apiKey && apiKey.length > 10) {
        try {
            const url = `https://maps.googleapis.com/maps/api/distancematrix/json?units=metric&origins=${origin}&destinations=${destination}&key=${apiKey}&region=ye&language=ar`;

            console.log(`🌐 Trying Google Maps API for Yemen...`);

            const response = await axios.get(url, { timeout: 10000 }); // 10 second timeout
            const data = response.data;

            console.log(`📡 Google Maps Response Status: ${data.status}`);

            if (data.status === 'OK' && data.rows && data.rows.length > 0) {
                const element = data.rows[0].elements[0];

                if (element.status === 'OK') {
                    const distance = element.distance.text;
                    const duration = element.duration.text;

                    console.log(`✅ Google Maps Success: ${distance}, ${duration}`);

                    let dspl = distance.split(" ");
                    let kmcal = 0;

                    if (dspl[1] && dspl[1].match(/km/i)) {
                        kmcal = parseFloat(dspl[0]);
                    } else {
                        kmcal = (parseFloat(dspl[0]) / 1000);
                    }

                    return { status: 1, dis: parseFloat(kmcal.toFixed(2)), dur: duration };
                } else {
                    console.log(`⚠️ Google Maps element error: ${element.status}`);
                }
            } else {
                console.log(`⚠️ Google Maps API error: ${data.status}`);
                if (data.error_message) {
                    console.log(`   Error: ${data.error_message}`);
                }
            }
        } catch (error) {
            console.log(`⚠️ Google Maps API failed: ${error.message}`);
        }
    }

    // 🇾🇪 FALLBACK: Yemen-specific distance calculation
    console.log(`🔄 Using Yemen fallback calculation...`);

    const [pickup_coords, drop_coords] = [pickup.split(','), drop.split(',')];
    const lat1 = parseFloat(pickup_coords[0]);
    const lon1 = parseFloat(pickup_coords[1]);
    const lat2 = parseFloat(drop_coords[0]);
    const lon2 = parseFloat(drop_coords[1]);

    // Validate coordinates are in Yemen range
    if (lat1 < 12 || lat1 > 19 || lon1 < 42 || lon1 > 54 ||
        lat2 < 12 || lat2 > 19 || lon2 < 42 || lon2 > 54) {
        console.log(`❌ Coordinates outside Yemen range`);
        return { status: 0, dis: 0, dur: "0 min" };
    }

    // Haversine formula for accurate distance
    function calculateYemenDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    // Calculate straight-line distance
    const straightDistance = calculateYemenDistance(lat1, lon1, lat2, lon2);

    // 🇾🇪 Yemen road network factor (roads are not always direct)
    // Urban areas: 1.3x, Rural/mountainous: 1.8x
    let roadFactor = 1.3; // Default for urban

    // Adjust for different Yemen regions
    if (isInSanaaRegion(lat1, lon1) && isInSanaaRegion(lat2, lon2)) {
        roadFactor = 1.25; // Better roads in Sanaa
    } else if (isInAdenRegion(lat1, lon1) && isInAdenRegion(lat2, lon2)) {
        roadFactor = 1.3; // Coastal roads
    } else if (isInIbbRegion(lat1, lon1) && isInIbbRegion(lat2, lon2)) {
        roadFactor = 1.4; // Mountainous terrain
    } else if (isInTaizRegion(lat1, lon1) && isInTaizRegion(lat2, lon2)) {
        roadFactor = 1.5; // Mountain city
    } else {
        roadFactor = 1.8; // Inter-city or rural
    }

    const roadDistance = straightDistance * roadFactor;

    // Calculate estimated time based on Yemen road conditions
    // Urban: 25 km/h, Rural: 40 km/h, Highway: 60 km/h
    let avgSpeed = 30; // km/h default

    if (roadDistance < 5) {
        avgSpeed = 25; // Urban traffic
    } else if (roadDistance < 20) {
        avgSpeed = 35; // City to suburb
    } else {
        avgSpeed = 45; // Inter-city
    }

    const timeInHours = roadDistance / avgSpeed;
    const timeInMinutes = Math.round(timeInHours * 60);

    // Format duration
    let duration;
    if (timeInMinutes < 60) {
        duration = `${timeInMinutes} mins`;
    } else {
        const hours = Math.floor(timeInMinutes / 60);
        const mins = timeInMinutes % 60;
        duration = `${hours} hour${hours > 1 ? 's' : ''} ${mins} mins`;
    }

    console.log(`🇾🇪 Yemen Calculation Results:`);
    console.log(`   Straight distance: ${straightDistance.toFixed(2)} km`);
    console.log(`   Road factor: ${roadFactor}x`);
    console.log(`   Road distance: ${roadDistance.toFixed(2)} km`);
    console.log(`   Estimated time: ${duration}`);

    return {
        status: 1,
        dis: parseFloat(roadDistance.toFixed(2)),
        dur: duration
    };
}

// 🇾🇪 Yemen region detection functions
function isInSanaaRegion(lat, lon) {
    // Sanaa region: 15.2° - 15.5°N, 44.1° - 44.3°E
    return lat >= 15.2 && lat <= 15.5 && lon >= 44.1 && lon <= 44.3;
}

function isInAdenRegion(lat, lon) {
    // Aden region: 12.7° - 13.0°N, 44.9° - 45.1°E
    return lat >= 12.7 && lat <= 13.0 && lon >= 44.9 && lon <= 45.1;
}

function isInIbbRegion(lat, lon) {
    // Ibb region: 13.9° - 14.0°N, 44.1° - 44.2°E
    return lat >= 13.9 && lat <= 14.0 && lon >= 44.1 && lon <= 44.2;
}

function isInTaizRegion(lat, lon) {
    // Taiz region: 13.5° - 13.7°N, 43.9° - 44.1°E
    return lat >= 13.5 && lat <= 13.7 && lon >= 43.9 && lon <= 44.1;
}




async function AddDateMinute(minute) {
    let currentTime = new Date();
    currentTime.setMinutes(currentTime.getMinutes() + minute);

    let hours = currentTime.getHours(), minutes = currentTime.getMinutes();
    let ampm = hours >= 12 ? 'PM' : 'AM';

    hours = hours % 12;
    hours = hours ? hours : 12;
    minutes = minutes < 10 ? '0' + minutes : minutes;

    let formattedTime = hours + ':' + minutes + ' ' + ampm;
    return formattedTime
}


async function ConvertDateFormat(time) {
    const date = new Date(time);
    const options = { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };
    const formattedDate = date.toLocaleString('en-US', options);

    const dateParts = formattedDate.split(", ");
    const timePart = dateParts[1].trim();
    const [monthDay, ndate] = dateParts[0].split(" ");

    const finalOutput = `${ndate} ${monthDay}, ${timePart}`;
    return finalOutput
}



async function ConvertFullDateFormat(time) {
    const date = new Date(time);
    const options = { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };
    const formattedDate = date.toLocaleString('en-US', options);
    const d = formattedDate.split(", ");
    let fd = d[0].split(" ");
    const finalOutput = `${fd[1]} ${fd[0]} ${d[1]}, ${d[2]}`;
    return finalOutput
}




async function TodatDate(ndate) {
    let date
    if (ndate) date = new Date(ndate).toISOString().split("T");
    else date = new Date().toISOString().split("T");
    return { date: date[0], time: date[1] }
}




async function convertSeconds(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;

    return { hours: hours, minutes: minutes, seconds: remainingSeconds };
}

async function FirstTime(hour, minute, secound, nhour, nminute, nsecond) {
    let totalSeconds = hour * 3600 + minute * 60 + secound;
    let nTotalSeconds = nhour * 3600 + nminute * 60 + nsecond;
    let newTotalSeconds = totalSeconds - nTotalSeconds;

    let newHour = Math.floor(newTotalSeconds / 3600);
    newTotalSeconds %= 3600;
    let newMinute = Math.floor(newTotalSeconds / 60);
    let newSecond = newTotalSeconds % 60;

    return { newHour, newMinute, newSecond }
}

async function SecoundTime(ntime, oldtime) {
    let currentTime = new Date(ntime);
    let OldTime = new Date(oldtime);

    let timeDifference = currentTime - OldTime;

    let differenceInSeconds = Math.floor(timeDifference / 1000);
    let differenceInMinutes = Math.floor(differenceInSeconds / 60);

    let hour = Math.floor(differenceInMinutes / 60);
    let minute = differenceInMinutes % 60;
    let second = differenceInSeconds % 60;

    return { hour, minute, second }
}

async function TwoTimeDifference(data, status) {
    let OldTime = new Date(data);
    if (status == "1") OldTime.setHours(OldTime.getHours() + 1);

    let currentTime = new Date();

    let timeDifference = currentTime - OldTime;
    let differenceInSeconds = Math.floor(timeDifference / 1000);
    let differenceInMinutes = Math.floor(differenceInSeconds / 60);

    let hour = Math.floor(differenceInMinutes / 60);
    let minute = differenceInMinutes % 60;
    let second = differenceInSeconds % 60;

    return { hour, minute, second }
}

async function CurrentDatetoOldDateS(ndate, deff_sec) {

    let currunt = new Date(ndate), old = new Date();
    old.setSeconds(old.getSeconds() - parseFloat(deff_sec));

    let newtime = await AllFunction.SecoundTime(currunt, old);

    let toth = parseFloat(newtime.hour) * 60 * 60;
    let totm = parseFloat(newtime.minute) * 60;
    let tots = parseFloat(toth) + parseFloat(totm) + parseFloat(newtime.second);
    return tots
}

async function TimeDistance(rdata) {
    let spltime = "", run_time = { hour: 0, minute: 0, second: 0, status: 0 }
    const general = await DataFind(`SELECT driver_wait_time FROM tbl_general_settings`);

    if (rdata.current_run_time && rdata.current_run_time != "") {
        spltime = rdata.current_run_time.split("&")

        let ctime = await TwoTimeDifference(spltime[0], 2);

        if (ctime.hour != "NaN" && ctime.minute != "NaN" && ctime.second != "NaN") {

            if (rdata.status == "1" || rdata.status == "5") {

                let newtime = await FirstTime(rdata.tot_hour, rdata.tot_minute, 0, ctime.hour, ctime.minute, ctime.second);

                if (newtime.newHour > -1 && newtime.newMinute > -1 && newtime.newSecond > -1) {
                    run_time.hour = newtime.newHour; run_time.minute = newtime.newMinute; run_time.second = newtime.newSecond; run_time.status = 1;
                }

            } else if (rdata.status == "2") {

                if (general[0].driver_wait_time != "0" || general[0].driver_wait_time) {
                    let ntime = new Date();
                    ntime.setMinutes(ntime.getMinutes() - parseFloat(general[0].driver_wait_time));

                    let sectime = await SecoundTime(spltime[0], ntime);

                    if (sectime.hour > -1 && sectime.minute > -1 && sectime.second > -1) {

                        run_time.hour = sectime.hour; run_time.minute = sectime.minute; run_time.second = sectime.second; run_time.status = 1;
                    } else {
                        let newtime = await FirstTime(ctime.hour, ctime.minute, ctime.second, 0, parseFloat(general[0].driver_wait_time), 0);

                        if (newtime.newHour > -1 && newtime.newMinute > -1 && newtime.newSecond > -1) {
                            run_time.hour = newtime.newHour; run_time.minute = newtime.newMinute; run_time.second = newtime.newSecond;
                        }
                    }
                }

            } else {
                run_time.hour = ctime.hour; run_time.minute = ctime.minute; run_time.second = ctime.second; run_time.status = 0;
            }
        }

    } else if (rdata.status == "3") {

        let sta = rdata.status_time_location.split("&!!");
        let f = sta[1].split("&"), s = sta[2].split("&");
        let sectime = await SecoundTime(s[1], f[1]);

        let a = parseFloat(sectime.hour);
        let hourm = a * 60 * 60;
        let = await CalculateMinuteToHour(sectime.second);

        let totm = parseFloat(hourm) + parseFloat(sectime.minute) * parseFloat(60) + parseFloat(sectime.second);

        let nextmin = 0, st = 0, driwait = parseFloat(general[0].driver_wait_time) * parseFloat(60);
        if (driwait >= totm) {
            nextmin = parseFloat(driwait) - parseFloat(totm); st = 2;
        } else {
            nextmin = parseFloat(totm) - parseFloat(driwait); st = 3;
        }
        const result = await convertSeconds(nextmin);
        run_time.hour = result.hours; run_time.minute = result.minutes; run_time.second = result.seconds; run_time.status = st;
    }
    return run_time;
}




async function DriverRequestData(rdata) {
    let request_data = []
    const general = await DataFind(`SELECT dri_offer_increment, offer_expire_time, offer_time FROM tbl_general_settings`);
    for (let i = 0; i < rdata.length;) {
        let piclatlon, drolatlon = [], picadd, dropadd = [], run_time = { hour: 0, minute: 0, second: 0, status: 0 }, timecal = 0, status = 0

        let plos = rdata[i].pic_lat_long.split("&!"), pads = rdata[i].pic_address.split("&!")
        piclatlon = { latitude: plos[0], longitude: plos[1] }; picadd = { title: pads[0], subtitle: pads[1] }

        let platlon = rdata[i].drop_lat_long.split("&!!"), dradd = rdata[i].drop_address.split("&!!")
        for (let a = 0; a < platlon.length;) {

            let lspl = platlon[a].split("&!"), addspl = dradd[a].split("&!")

            if (parseFloat(rdata[i].status) > 4) {
                if (parseFloat(rdata[i].drop_complete) <= a) drolatlon.push({ latitude: lspl[0], longitude: lspl[1] });
            } else {
                drolatlon.push({ latitude: lspl[0], longitude: lspl[1] });
            }
            dropadd.push({ title: addspl[0], subtitle: addspl[1] });
            a++;
        }

        let per_km_price = "0";
        if (parseFloat(rdata[i].price) != 0 && parseFloat(rdata[i].tot_km) != 0) per_km_price = (parseFloat(rdata[i].price) / parseFloat(rdata[i].tot_km)).toFixed(2);

        if (rdata[i].current_run_time && rdata[i].current_run_time != "") run_time = await TimeDistance(rdata[i]);

        status = run_time.status;
        if (run_time.hour != 0 && run_time.minute != 0 && run_time.second != 0) {

            timecal = (parseFloat(run_time.hour) * 3600) + (parseFloat(run_time.minute) * 60) + parseFloat(run_time.second);

        } else if (run_time.hour == 0 && run_time.minute != 0 && run_time.second != 0) {

            timecal = (run_time.minute * 60) + run_time.second;

        } else if (run_time.hour == 0 && run_time.minute == 0 && run_time.second != 0) {

            timecal = run_time.second;

        } else if (run_time.hour == 0 && run_time.minute == 0 && run_time.second == 0) {

            timecal = 0;

        } else timecal = 0;

        let timed = { run_time: timecal ? timecal : 0, status: status };

        let df = parseFloat(general[0].dri_offer_increment), dprice = [];
        if (rdata[i].bidding_status == "1") {
            for (let b = 1; b < df + 1;) {
                let dp = parseFloat(rdata[i].price) + b
                dprice.push(dp);
                b++;
            }
        }

        request_data.push({
            id: rdata[i].id, c_id: rdata[i].c_id, name: rdata[i].name, country_code: rdata[i].country_code, phone: rdata[i].phone, rating: parseFloat(rdata[i].avg_star),
            review: rdata[i].tot_review, price: parseFloat(rdata[i].price), per_km_price, tot_km: rdata[i].tot_km, tot_hour: rdata[i].tot_hour, tot_minute: rdata[i].tot_minute, status: rdata[i].status,
            bidding_status: rdata[i].bidding_status, bidd_auto_status: rdata[i].bidd_auto_status, ride_expire_time: parseFloat(general[0].offer_expire_time), bidd_ex_time: parseFloat(general[0].offer_time),
            dri_offer_limite: dprice, running_time: timed, pick_latlon: piclatlon, drop_latlon: drolatlon, pick_add: picadd, drop_add: dropadd
        });

        i++
    }
    return request_data
}

async function CheckBodyData(req, Data) {
    const missingField = Data.find(field => !req.body[field] || req.body[field] === null || req.body[field] === "null" || req.body[field] === undefined || req.body[field] === "undefined");
    return missingField
}


async function CheckSocketData(data, Data) {
    const missingField = Data.find(field => !data[field] || data[field] === null || data[field] === "null" || data[field] === undefined || data[field] === "undefined");
    return missingField
}




async function SendDriverLatLong(uid) {
    let data = await DataFind(`SELECT c_id FROM tbl_cart_vehicle WHERE d_id = '${uid}'`), driver = [];

    if (data != "") {
        driver = await DataFind(`SELECT dr.id, COALESCE(ve.map_img, '') AS image, COALESCE(ve.name, '') AS name, COALESCE(ve.description, '') AS description,
                                COALESCE(dr.latitude, '') AS latitude, COALESCE(dr.longitude, '') AS longitude
                                FROM tbl_driver AS dr
                                JOIN tbl_vehicle AS ve ON dr.vehicle = ve.id AND ve.id = dr.vehicle
                                WHERE dr.id = '${uid}' AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')`);

        if (driver != "") return { driver, data };
    } else return { driver: [], data: [] }
}




async function CheckCurrentLocation(pending_ride, dlatlon, daddress) {
    let current_address = { title: "", subtitle: "", latitude: "", longitude: "" }, next_address = { title: "", subtitle: "", latitude: "", longitude: "" }, custatus = 0, nstatus = 0;

    if (dlatlon[pending_ride]) {
        let add = daddress[pending_ride].split("&!"), latlon = dlatlon[pending_ride].split("&!");
        current_address = { title: add[0], subtitle: add[1], latitude: latlon[0], longitude: latlon[1] };

        custatus = 1;
    }

    if (dlatlon[pending_ride + 1]) {
        let nadd = daddress[pending_ride + 1].split("&!"), nlatlon = dlatlon[pending_ride + 1].split("&!");
        next_address = { title: nadd[0], subtitle: nadd[1], latitude: nlatlon[0], longitude: nlatlon[1] };

        nstatus = 1;
    }
    return { current_address, next_address, custatus, nstatus };
}




async function VehicleRideStartEndData(uid, c_id, request_id) {
    const rd = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${c_id}' AND d_id = '${uid}'`);
    if (rd == "") return { ResponseCode: 401, Result: false, message: 'Request Not Found!' };

    let dlatlon = rd[0].drop_lat_long.split("&!!"), daddress = rd[0].drop_address.split("&!!"), pending_ride = "", drop_list = [], splh = rd[0].current_run_time.split("&")
    pending_ride = parseFloat(rd[0].drop_complete);

    let ccheck = await CheckCurrentLocation(pending_ride, dlatlon, daddress), pickup, drop, drop_latlon, tot_hour = rd[0].tot_hour, tot_min = rd[0].tot_minute, tot_km = splh[3];

    for (let i = 0; i < dlatlon.length;) {
        let checkadd = daddress[i].split("&!"), checkl = dlatlon[i].split("&!"), status = "";

        if (pending_ride == i) status = "2";
        if (pending_ride > i) status = "3";
        if (pending_ride < i) status = "1";

        if (parseFloat(rd[0].drop_complete) <= i) drop_list.push({ status: status, title: checkadd[0], subtitle: checkadd[1], latitude: checkl[0], longitude: checkl[1] })
        i++
    }

    return { uid, c_id, request_id, status: rd[0].status, tot_hour, tot_min, tot_second: 0, tot_km: tot_km, current_address: ccheck.current_address, next_address: ccheck.next_address, drop_list }
}



async function VehicleAllRide(rdata, number) {
    let piclatlon, firstdrop = [], dropdata = [], drop_tot = 0;

    let plos = rdata.pic_lat_long.split("&!"), pads = rdata.pic_address.split("&!")
    piclatlon = { title: pads[0], subtitle: pads[1], latitude: plos[0], longitude: plos[1] }

    let platlon = rdata.drop_lat_long.split("&!!"), dradd = rdata.drop_address.split("&!!")
    drop_tot = dradd.length

    for (let a = 0; a < platlon.length;) {
        let lspl = platlon[a].split("&!"), addspl = dradd[a].split("&!")
        if (a == 0) firstdrop.push({ title: addspl[0], subtitle: addspl[1], latitude: lspl[0], longitude: lspl[1] })
        else dropdata.push({ title: addspl[0], subtitle: addspl[1], latitude: lspl[0], longitude: lspl[1] })
        a++
    }
    if (number == "1") {
        return { piclatlon, dropdata: firstdrop[0], droplist: dropdata, drop_tot }
    } else if (number == "2") {
        let data = firstdrop.concat(dropdata)
        return { piclatlon, dropdata: data, drop_tot }
    }
}



async function RideAddress(rdata, number) {
    let piclatlon, pads = rdata.pic_address.split("&!"), dradd = rdata.drop_address.split("&!!"), dropdata = [], drop_tot = 0;
    drop_tot = dradd.length;

    piclatlon = { title: pads[0], subtitle: pads[1] }

    if (number == "1") {
        let addspl = dradd[0].split("&!");
        return { piclatlon, dropdata: { title: addspl[0], subtitle: addspl[1] }, drop_tot };
    }
    else if (number == "2") {
        for (let a = 0; a < dradd.length;) {
            let addspl = dradd[a].split("&!");
            dropdata.push({ title: addspl[0], subtitle: addspl[1] });
            a++
        }
        return { piclatlon, dropdata, drop_tot };
    }
}



async function DateFormate(fulldate) {
    const date = new Date(fulldate);
    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: true, timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone };

    const formattedDate = date.toLocaleString('en-US', options);
    return formattedDate
}



async function VehicleBidding(uid, request_id, price, status, hostname, protocol) {

    let rd = []
    if (typeof uid == 'object') {
        rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE bidding_status = "1" AND id = '${request_id}'`);
    } else {
        rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE bidding_status = "1" AND id = '${request_id}' AND JSON_CONTAINS(d_id, '${uid}')`);
    }

    if (rd != "") {

        let idlist = rd[0].d_id, bprice = rd[0].bidding_d_price, eidlist = [], driindex = 0;
        if (typeof idlist == "string") eidlist = JSON.parse(idlist);
        else eidlist = idlist;

        driindex = eidlist.indexOf(parseFloat(uid));

        let old = "", nid = ``, nprice = [], ndate = new Date().toISOString();

        if (bprice != "") {

            let pspl = bprice.split("&&!");
            for (let a = 0; a < pspl.length;) {
                let sd = pspl[a].split("&");

                if (status == "1" || status == "3" || status == "4") {

                    if (parseFloat(sd[1]) != parseFloat(uid)) {
                        old += old == "" ? `${sd[0]}&${sd[1]}&${sd[2]}` : `&&!${sd[0]}&${sd[1]}&${sd[2]}`;
                        nid += nid == "" ? `${sd[1]}` : `,${sd[1]}`;
                        nprice.push({ date: sd[0], id: parseFloat(sd[1]), price: parseFloat(sd[2]) });
                    }
                } else if (status == "2") {
                    old += old == "" ? `${sd[0]}&${sd[1]}&${sd[2]}` : `&&!${sd[0]}&${sd[1]}&${sd[2]}`;
                    nid += nid == "" ? `${sd[1]}` : `,${sd[1]}`;
                    nprice.push({ date: sd[0], id: parseFloat(sd[1]), price: parseFloat(sd[2]) });
                }
                a++;
            }
        }

        let data, ids, prices;
        if (status == "1") {
            data = old == "" ? `${ndate}&${uid}&${price}` : `${ndate}&${uid}&${price}&&!${old}`;
            ids = nid == "" ? `${uid}` : `${uid},${nid}`;
            prices = nprice != "" ? [{ date: ndate, id: parseFloat(uid), price: parseFloat(price) }].concat(nprice) : [{ date: ndate, id: parseFloat(uid), price: parseFloat(price) }];
        } else {
            data = old; ids = nid; prices = nprice;
        }

        const general = await DataFind(`SELECT google_map_key, offer_time FROM tbl_general_settings`);
        let dtime = 0, dri_list = [], nid_list = [];
        if (ids != "") {

            let dr = await DriverReview("dr");
            let dri = await DataFind(`SELECT dr.id, dr.profile_image, dr.first_name, dr.last_name, dr.latitude, dr.longitude,
                                        COALESCE(vec.name, "") AS car_name  ${dr.tot_review} ${dr.avgstar}
                                        FROM tbl_driver AS dr
                                        LEFT JOIN tbl_vehicle AS vec ON dr.vehicle = vec.id
                                        ${dr.outtable}
                                        WHERE dr.id IN (${ids}) AND dr.status = '1' AND dr.approval_status = '1' AND dr.latitude NOT IN ('') AND dr.longitude NOT IN ('')
                                        GROUP BY dr.id, dr.profile_image, dr.first_name, dr.last_name, vec.name ORDER BY dr.id DESC`);

            let firlat = rd[0].pic_lat_long, drop = "", droadd = "", def = (parseFloat(rd[0].tot_hour) * 60) + parseFloat(rd[0].tot_minute)

            if (firlat) {
                let spl = firlat.split("&!"), das = rd[0].pic_address.split("&!")
                drop = `${spl[0]},${spl[1]}`, droadd = das[0]

                for (let i = 0; i < dri.length;) {
                    let dpri = [];
                    for (let b = 0; b < prices.length;) {
                        if (dri[i].id == prices[b].id) dpri.push(prices[b]);
                        b++;
                    }

                    if (status == "1") {
                        const general = await DataFind(`SELECT site_currency, currency_placement FROM tbl_general_settings`);
                        let pricespl = general[0].currency_placement == "1" ? `${price}${general[0].site_currency}` : `${general[0].site_currency}${price}`
                        let notification = `${dri[i].first_name} ${dri[i].last_name} is offering a ride to ${droadd} ${pricespl}`

                        sendOneNotification(notification, 'customer', rd[0].c_id);
                    }

                    if (dpri != "") {

                        let diff_second = await CurrentDatetoOldDateS(dpri[0].date, general[0].offer_time);
                        if (parseFloat(diff_second) >= 0) {
                            if (parseFloat(diff_second) <= parseFloat(general[0].offer_time)) {

                                let pickup = `${dri[i].latitude},${dri[i].longitude}`;
                                let distance = await GetDistance(pickup, drop, general[0].google_map_key);

                                let tot_km = parseFloat((parseFloat(rd[0].tot_km) + parseFloat(distance.dis)).toFixed(2));

                                let spltime = distance.dur.split(" ");
                                if (spltime.length == "2") dtime = parseFloat(spltime[0]);
                                else dtime = (parseFloat(spltime[0]) * 60) + parseFloat(spltime[2]);

                                let min = parseFloat(def) + parseFloat(dtime);
                                let tot_min = await CalculateMinuteToHour(min);

                                dri[i].tot_review = parseFloat((dri[i].tot_review).toFixed(2)); dri[i].avg_star = parseFloat((dri[i].avg_star).toFixed(2));
                                dri_list.push({ ...dri[i], request_id, price: dpri[0].price, tot_min, tot_km, diff_second });

                            } else nid_list.push(dri[i].id);
                        } else nid_list.push(dri[i].id);
                    }
                    i++;
                }
            }
        }

        if (status == "1" || status == "2" || status == "4") {
            if (await DataUpdate(`tbl_request_vehicle`, `bidding_d_price = '${data}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) {
                return false;
            }
        } else {
            let d_id = rd[0].d_id, eidlist, reqmoveid;

            if (typeof d_id == "string") {
                d_id = JSON.parse(d_id);
                eidlist = d_id.filter(item => item != uid);
                reqmoveid = JSON.stringify(eidlist);
            } else {
                eidlist = d_id.filter(item => item != uid);
                reqmoveid = JSON.stringify(eidlist);
            }

            if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${reqmoveid}', bidding_d_price = '${data}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) {
                return false;
            }
        }

        if (status == "1" || status == "4") return { bidding_list: dri_list, off_ex_time: general[0].offer_time };
        else return { bidding_list: dri_list, off_ex_time: general[0].offer_time, request_id: rd[0].id, c_id: rd[0].c_id, nid_list };

    } return false;
}



async function AcceptVehicleRide(uid, request_id, lat, lon, hostname, protocol, price, ndata) {
    if (!uid || !request_id || !lat || !lon) return 1;

    let rd
    if (ndata != "") rd = ndata;
    else rd = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND JSON_CONTAINS(d_id, '${uid}')`);
    if (rd == "") return 2;

    const driver = await DataFind(`SELECT * FROM tbl_driver WHERE id = '${uid}'`);
    if (driver == "") 3;

    let otp = await otpGenerate(4), jsonuid = JSON.stringify([parseFloat(uid)]), requestid = 0;

    if (await DataUpdate(`tbl_request_vehicle`, `d_id = '${jsonuid}'`, `id = '${rd[0].id}'`, hostname, protocol) == -1) return "databaseerror";
    if (await DataUpdate(`tbl_driver`, `rid_status = '1'`, `id = '${driver[0].id}'`, hostname, protocol) == -1) return "databaseerror";

    const check = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE c_id = '${rd[0].c_id}' AND d_id = '${uid}'`);

    let dropcount = rd[0].drop_lat_long.split("&!!").length;
    let fulldate = await TodatDate(), updatet = "", nprice = 0

    if (rd[0].bidding_status == "1") {
        updatet = `0&${rd[0].start_time}&$0&$0&!!1&${fulldate.date}T${fulldate.time}&${driver[0].latitude}&${driver[0].latitude}`;
        if (rd[0].bidd_auto_status == "0") {
            if (price == "0") nprice = rd[0].price;
            else nprice = price;
        } else nprice = rd[0].price;
    } else {
        updatet = `0&${rd[0].start_time}&$0&$0&!!1&${fulldate.date}T${fulldate.time}&${lat}&${lon}`;
        nprice = rd[0].price;
    }

    let ntime = `1&${rd[0].tot_hour}&${rd[0].tot_minute}`; // status_time
    let current_time = `${fulldate.date}T${fulldate.time}&${rd[0].tot_hour}&${rd[0].tot_minute}`; // current_run_time

    let idlist = rd[0].d_id, d_id, eidlist, reqmoveid;
    if (typeof idlist == "string") {
        d_id = JSON.parse(idlist);
        eidlist = d_id.filter(item => item != uid);
        reqmoveid = JSON.stringify(eidlist);
    } else {
        eidlist = idlist.filter(item => item != uid);
        reqmoveid = JSON.stringify(eidlist);
    }

    let indata = await DataInsert(`tbl_cart_vehicle`, `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, price, final_price, paid_amount, coupon_amount, addi_time_price,
            platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role, coupon_id, start_time, otp, additional_time, ride_status, drop_tot,
            drop_complete, current_run_time, status_time, status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, driver_id_list, req_id`,
        `'${rd[0].c_id}', '${uid}', '${rd[0].vehicleid}', '${rd[0].bidding_status}', '${rd[0].bidd_auto_status}', '${nprice}', '0', '0', '0', '0', '0', '0', '0', '${rd[0].tot_km}',
            '${rd[0].tot_hour}', '${rd[0].tot_minute}', '1', '${rd[0].payment_id}', '${rd[0].m_role}', '${rd[0].coupon_id}', '${fulldate.date}T${fulldate.time}', '${otp}', '0', '0',
            '${dropcount}', '', '${current_time}', '${ntime}', '${updatet}', '', '${rd[0].pic_lat_long}', '${rd[0].drop_lat_long}', '${rd[0].pic_address}', '${rd[0].drop_address}',
            '${reqmoveid}', '${rd[0].id}'`, hostname, protocol);

    if (indata == -1) return "databaseerror";

    requestid = indata.insertId;

    if (await DataDelete(`tbl_request_vehicle`, `id = '${rd[0].id}'`, hostname, protocol) == -1) return "databaseerror";

    await AllChat.Chat_Save(uid, uid, rd[0].c_id, "🚗 Your Trip Has Started!", "driver", hostname, protocol);

    let message = "📍 Your Captain is on the way!\n" +
        "Captain " + driver[0].first_name + " " + driver[0].last_name + " will arrive shortly."
    await AllChat.Chat_Save(uid, uid, rd[0].c_id, message, "driver", hostname, protocol);

    return { requestid: requestid, reqmoveid };
}



async function AllVehicleFormate(com_request, number) {
    let comreq = com_request.map(async (rdata) => {
        let data = await VehicleAllRide(rdata, number);
        rdata.price = parseFloat(rdata.price);
        rdata.addi_time = parseFloat(rdata.additional_time);

        // FIX: This safety check prevents the '.split()' on null crash
        let spldate = [];
        if (rdata.status_time_location) {
            spldate = rdata.status_time_location.split("&!!");
        }

        let starttime = "", run_time = { hour: 0, minute: 0, second: 0, status: 0 };
        if (rdata.status != '0' && spldate.length > 0) {
            let timeParts = spldate[0].split("&");
            if (timeParts.length > 1) {
                starttime = await DateFormate(timeParts[1]);
            }
        }

        run_time = await TimeDistance(rdata);

        if (rdata.m_role == "1") rdata.m_role = "Vehicle";
        if (rdata.m_role == "2") rdata.m_role = "Outstation";
        if (rdata.m_role == "3") rdata.m_role = "Rental";
        if (rdata.m_role == "4") rdata.m_role = "Package";

        rdata.start_time = starttime;
        rdata.tot_drop = data.drop_tot;
        rdata.run_time = run_time;
        rdata.pickup = data.piclatlon;
        rdata.drop = data.dropdata;
        rdata.drop_list = data.droplist;

        delete rdata.current_run_time; delete rdata.pic_lat_long; delete rdata.drop_lat_long;
        delete rdata.pic_address; delete rdata.drop_address; delete rdata.status_time_location;
        delete rdata.coupon_id; delete rdata.additional_time; delete rdata.comission_rate;
        delete rdata.comission_type;

        return rdata;
    });
    let complete_request = await Promise.all(comreq);
    return complete_request;
}



async function SetNewTimeFormate(nDate) {
    let currentTime = new Date(nDate);

    let hours = currentTime.getHours(), minutes = currentTime.getMinutes();
    let ampm = hours >= 12 ? 'PM' : 'AM';

    hours = hours % 12;
    hours = hours ? hours : 12;
    minutes = minutes < 10 ? '0' + minutes : minutes;

    let formattedTime = hours + ':' + minutes + ' ' + ampm;
    return formattedTime
}



async function PaymentCalculation(mapdata, status) {
    const general = await DataFind(`SELECT * FROM tbl_general_settings`);
    let mapd = status == "1" ? mapdata[0] : mapdata
    let price = parseFloat(mapd.price), coupon_amount = 0, final_price = parseFloat(mapd.price), platform_fee = 0, addi_time_price = 0, addi_time = 0, weather_price = 0;

    if (parseFloat(general[0].driver_wait_price) != "NaN" && typeof parseFloat(general[0].driver_wait_price) == "number") {
        if (mapd.additional_time || mapd.additional_time != "0") {
            let totmin = parseFloat(mapd.additional_time);

            addi_time_price = parseFloat(totmin) * parseFloat(general[0].driver_wait_price);
            addi_time = totmin;
            final_price += addi_time_price;
        }
    }

    if (mapd.coupon_id || mapd.coupon_id != "") {
        const coupon = await DataFind(`SELECT * FROM tbl_coupon WHERE id = '${mapd.coupon_id}' `);
        if (coupon != "") {
            if (parseFloat(coupon[0].min_amount) <= parseFloat(mapd.price)) {
                coupon_amount = parseFloat(coupon[0].discount_amount);
                final_price -= parseFloat(coupon[0].discount_amount);
            }
        }
    }

    if (mapd.comission_rate && mapd.comission_type) {
        if (mapd.comission_type == "FIX") {
            platform_fee = parseFloat(mapd.comission_rate); final_price += parseFloat(mapd.comission_rate);
        } else {
            let amount = final_price / parseFloat(mapd.comission_rate);
            platform_fee = amount;
            final_price += amount;
        }
    }

    let veh_list = await DataFind(`SELECT * FROM tbl_vehicle WHERE id = '${mapd.vehicleid}' AND status = '1'`);

    if (veh_list != "") {
        if (veh_list[0].whether_charge == "1") {
            if (parseFloat(general[0].weather_price) != "NaN" && typeof parseFloat(general[0].weather_price) == "number" && parseFloat(general[0].weather_price) != 0) {
                if (general[0].weather_type == "FIX") {
                    weather_price = parseFloat(general[0].weather_price);
                    final_price += parseFloat(general[0].weather_price);
                } else {
                    let wamount = final_price / parseFloat(general[0].weather_price);
                    weather_price = parseFloat((wamount).toFixed(2));
                    final_price += wamount;
                }
            }
        }
    }
    let fprice = parseFloat((parseFloat(final_price)).toFixed(2));

    if (status == "1") mapd.coupon_amount = coupon_amount; mapd.platform_fee = platform_fee; mapd.final_price = fprice; mapd.price = parseFloat(mapd.price);
    mapd.weather_price = parseFloat(weather_price);

    return { mapdata: mapd, coupon_amount, final_price: fprice, platform_fee, addi_time_price, addi_time, weather_price }
}



async function PriceCalculation(rd, hostname, protocol) {
    const general = await DataFind(`SELECT driver_wait_price, google_map_key FROM tbl_general_settings`);

    let price = parseFloat(rd[0].price), final_price = parseFloat(rd[0].price), coupon_amount = 0, addi_time_price = 0, addi_time = 0, platform_fee = 0, weather_price = 0;

    let cprice = await PaymentCalculation(rd, 1)
    final_price = cprice.final_price; coupon_amount = cprice.coupon_amount; addi_time_price = cprice.addi_time_price; addi_time = cprice.addi_time; platform_fee = cprice.platform_fee;
    weather_price = cprice.weather_price

    let picadd = [], pads = rd[0].pic_address.split("&!"), splsta = rd[0].status_time_location.split("&!!"), firsttime = "", pickkm = 0, picktime = 0, status_cal = [], cal = 0,
        savedata = "";
    let dradd = rd[0].drop_address.split("&!!"), totkm = 0, totmin = 0

    picadd.push({ title: pads[0], subtitle: pads[1] });

    for (let b = 0; b < dradd.length;) {
        let addspl = dradd[b].split("&!");
        picadd.push({ title: addspl[0], subtitle: addspl[1] });
        b++
    }

    for (let a = 0; a < splsta.length;) {
        let check = splsta[a].split("&");

        if (parseFloat(check[0]) < 4) {

            if (parseFloat(check[0]) == 1) {

                let checkn = splsta[a + 1].split("&");

                let pickup = `${parseFloat(check[2])},${parseFloat(check[3])}`, drop = `${parseFloat(checkn[2])},${parseFloat(checkn[3])}`;
                let ftime = await GetDistance(pickup, drop, general[0].google_map_key);

                if (parseFloat(check[0]) == 1) firsttime = await SetNewTimeFormate(check[1]);
                pickkm += parseFloat(ftime.dis);

                let spltime = ftime.dur.split(" ");
                if (spltime.length == "2") picktime += parseFloat(spltime[0]);
                else picktime += (parseFloat(spltime[0]) * parseFloat(60)) + parseFloat(spltime[2]);

                status_cal.push({ title: 'Order Accepted', subtitle: "", date: firsttime, tot_km: pickkm, tot_time: picktime });
                savedata += `Order Accepted&&${firsttime}&${pickkm}&${picktime}`;
                totmin += picktime;
                totkm += pickkm
            }


        } else if (parseFloat(check[0]) > 4 && parseFloat(check[0]) < 7) {
            let scheckn = splsta[a + 1].split("&");

            if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 6 || parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 7) {

                let spickup = `${parseFloat(check[2])},${parseFloat(check[3])}`, sdrop = `${parseFloat(scheckn[2])},${parseFloat(scheckn[3])}`;
                let time = await GetDistance(spickup, sdrop, general[0].google_map_key);
                let dtime = await SetNewTimeFormate(check[1]), droptime = 0;

                let spltime = time.dur.split(" ");
                if (spltime.length == "2") droptime += parseFloat(spltime[0]);
                else droptime += (parseFloat(spltime[0]) * parseFloat(60)) + parseFloat(spltime[2]);
                totmin += droptime;
                totkm += time.dis

                if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 6) {

                    status_cal.push({ title: picadd[cal].title, subtitle: picadd[cal].subtitle, date: dtime, tot_km: time.dis, tot_time: droptime })
                    savedata += `&!!${picadd[cal].title}&${picadd[cal].subtitle}&${dtime}&${time.dis}&${droptime}`
                }
                if (parseFloat(check[0]) == 5 && parseFloat(scheckn[0]) == 7) {

                    status_cal.push({ title: picadd[cal].title, subtitle: picadd[cal].subtitle, date: dtime, tot_km: time.dis, tot_time: droptime },
                        { title: picadd[cal + 1].title, subtitle: picadd[cal + 1].subtitle, date: 0, tot_km: 0, tot_time: 0 });

                    savedata += `&!!${picadd[cal].title}&${picadd[cal].subtitle}&${dtime}&${time.dis}&${droptime}`
                    savedata += `&!!${picadd[cal + 1].title}&${picadd[cal + 1].subtitle}&0&0&0`
                }
                cal++;
            }
        }
        a++;
    }

    if (await DataUpdate(`tbl_cart_vehicle`, `final_price = '${final_price}', coupon_amount = '${coupon_amount}', addi_time_price = '${addi_time_price}',
        platform_fee = '${platform_fee}', weather_price = '${weather_price}', tot_km = '${totkm}', tot_hour = '0', tot_minute = '${totmin}' ,status_calculation = '${savedata}'`,
        `id = '${rd[0].id}'`, hostname, protocol) == -1) return 4;

    return { price, final_price, coupon_amount, addi_time, addi_time_price, platform_fee, status_cal, weather_price }
}



async function VehiclePaymentCal(uid, c_id, request_id, role, hostname, protocol) {
    let price_list, pa, add_calcu = [];
    const review_list = await DataFind(`SELECT * FROM tbl_ride_review_reason WHERE status = '1'`);

    if (role == "1") {
        const rd = await DataFind(`SELECT veh.*, COALESCE(cus.name, '') AS cname, COALESCE(vdata.comission_rate, '') AS comission_rate, COALESCE(vdata.comission_type, '') AS comission_type
                            FROM tbl_cart_vehicle AS veh
                            JOIN tbl_customer AS cus ON veh.c_id = cus.id
                            JOIN tbl_vehicle AS vdata ON veh.vehicleid = vdata.id
                            WHERE veh.id = '${request_id}' AND veh.c_id = '${c_id}' AND veh.d_id = '${uid}'`);

        if (rd == "") return 1;
        if (parseFloat(rd[0].status) > 7) return 2;
        if (rd[0].final_price == "0" && rd[0].status_calculation == "") {
            pa = await PriceCalculation(rd, hostname, protocol);
            add_calcu = pa.status_cal;
        } else {
            pa = rd[0];
            let timespl = rd[0].status_calculation.split("&!!");

            for (let a = 0; a < timespl.length;) {
                let spl = timespl[a].split("&");
                add_calcu.push({ title: spl[0], subtitle: spl[1], date: spl[2], tot_km: spl[3], tot_time: spl[4] });
                a++;
            }
        }

        add_calcu.map(aval => {
            aval.date = (aval.date).toString(); aval.tot_km = (aval.tot_km).toString(); aval.tot_time = (aval.tot_time).toString();
            return aval;
        })

        if (pa == 3) return 3;
        if (pa == 4) return 4;

        const payment = await DataFind(`SELECT id, image, name FROM tbl_payment_detail WHERE id = '${rd[0].payment_id}' AND status = '1'`);

        price_list = {
            cus_name: rd[0].cname, tot_price: parseFloat(pa.price), final_price: pa.final_price, coupon_amount: pa.coupon_amount, addi_time_price: pa.addi_time_price,
            platform_fee: pa.platform_fee, weather_price: pa.weather_price, addi_time: pa.addi_time
        };
        return { price_list, payment, add_calcu, review_list };
    }

    if (role == "2") {
        const rd = await DataFind(`SELECT veh.*, COALESCE(dri.first_name, '') AS first_name, COALESCE(dri.last_name, '') AS last_name, COALESCE(vdata.comission_rate, '') AS comission_rate,
                            COALESCE(vdata.comission_type, '') AS comission_type
                            FROM tbl_cart_vehicle AS veh
                            JOIN tbl_driver AS dri ON veh.d_id = dri.id
                            JOIN tbl_vehicle AS vdata ON veh.vehicleid = vdata.id
                            WHERE veh.id = '${request_id}' AND veh.c_id = '${c_id}' AND veh.d_id = '${uid}'`);

        if (rd == "") return 1;
        if (parseFloat(rd[0].status) > 7) return 2;
        if (rd[0].final_price == "0") pa = await PriceCalculation(rd, hostname, protocol);
        else pa = rd[0];

        if (pa == 3) return 3;
        if (pa == 4) return 4;

        const payment = await DataFind(`SELECT id, image, name FROM tbl_payment_detail WHERE id = '${rd[0].payment_id}' AND status = '1'`);

        // Customer
        price_list = {
            first_name: rd[0].first_name, last_name: rd[0].last_name, tot_price: pa.price, final_price: pa.final_price, coupon_amount: pa.coupon_amount, addi_time_price: pa.addi_time_price,
            platform_fee: pa.platform_fee, weather_price: pa.weather_price, addi_time: pa.addi_time
        };
        return { price_list, payment, review_list };
    }

}



// ============= Convert Day  ================ //

async function DateConvertDay(walletd) {
    const all_data = [];
    walletd.forEach(item => {
        const dateString = new Date(item.date).toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

        let existingDateEntry = all_data.find(entry => entry.date === dateString);

        if (!existingDateEntry) {
            existingDateEntry = {
                date: dateString,
                detail: []
            };
            all_data.push(existingDateEntry);
        }
        item.date = new Date(item.date).toISOString().split("T")[0];
        existingDateEntry.detail.push(item);
    });
    return all_data
}



async function CustomerReview(tname) {
    let tot_review = `, COALESCE(COUNT(DISTINCT cr.id), 0) AS tot_review`
    let avgstar = `, CASE
                    WHEN COUNT(cr.customer_id) > 0 THEN
                        CASE
                            WHEN (SUM(cr.tot_star) / COUNT(cr.customer_id)) % 1 >= 0.25
                                AND (SUM(cr.tot_star) / COUNT(cr.customer_id)) % 1 < 0.75
                            THEN ROUND((SUM(cr.tot_star) / COUNT(cr.customer_id)) * 2) / 2
                            ELSE ROUND(SUM(cr.tot_star) / COUNT(cr.customer_id))
                        END
                    ELSE 0
                END AS avg_star`

    let table = `LEFT JOIN tbl_review_customer AS cr ON cr.customer_id = ${tname}.c_id`
    let outtable = `LEFT JOIN tbl_review_customer AS cr ON cr.customer_id = ${tname}.id`
    return { tot_review, avgstar, table, outtable }
}



async function DriverReview(tname) {
    let tot_review = `, COALESCE(COUNT(DISTINCT cr.id), 0) AS tot_review`
    let avgstar = `, CASE
                    WHEN COUNT(cr.driver_id) > 0 THEN
                        CASE
                            WHEN (SUM(cr.tot_star) / COUNT(cr.driver_id)) % 1 >= 0.25
                                AND (SUM(cr.tot_star) / COUNT(cr.driver_id)) % 1 < 0.75
                            THEN ROUND((SUM(cr.tot_star) / COUNT(cr.driver_id)) * 2) / 2
                            ELSE ROUND(SUM(cr.tot_star) / COUNT(cr.driver_id))
                        END
                    ELSE 0
                END AS avg_star`

    let table = `LEFT JOIN tbl_review_driver AS cr ON cr.driver_id = ${tname}.d_id`;
    let outtable = `LEFT JOIN tbl_review_driver AS cr ON cr.driver_id = ${tname}.id`;
    return { tot_review, avgstar, table, outtable };
}



async function CalculateMinuteToHour(minute) {
    let a = parseFloat(minute);
    let hour = Math.floor(a / 60);
    let min = a % 60;
    let totm = `${hour}.${min.toString().padStart(2, '0')}`;
    return parseFloat(totm);
}

async function MinuteToHour(minute) {
    let a = parseFloat(minute);
    let hour = Math.floor(a / 60);
    let min = a % 60;
    let totm = `${hour}.${min.toString().padStart(2, '0')}`;
    return { hour: parseFloat(hour), minute: parseFloat(min) };
}




async function TimeUpdate(homemessage, hostname, protocol) {
    const { uid, c_id, request_id, time } = homemessage;
    if (!uid || !c_id || !request_id || !time) return res.status(200).json({ ResponseCode: 401, Result: false, message: 'Something went wrong' });

    const check = await DataFind(`SELECT * FROM tbl_cart_vehicle WHERE id = '${request_id}' AND c_id = '${c_id}' AND d_id = '${uid}'`);
    if (check == "") return { ResponseCode: 401, Result: false, message: 'Request Not Found!' };

    let fulldate = await AllFunction.TodatDate();

    let ntime = check[0].status_time != "" ? `${check[0].status_time}&!!${check[0].status}&0&${time}` : `${check[0].status}&0&${time}`; // status_time
    let current_time = `${fulldate.date}T${fulldate.time}&0&${time}`; // current_run_time

    if (await DataUpdate(`tbl_cart_vehicle`, `tot_hour = '0', tot_minute = '${time}', status_time = '${ntime}', current_run_time = '${current_time}'`,
        `id = '${check[0].id}'`, hostname, protocol) == -1) {
        return { ResponseCode: 401, Result: false, message: process.env.dataerror };
    }
    return true;
}



async function DriverNewRequestData(uid, request_id, sttaus) {
    if (!uid || !request_id) 1

    let dr = await AllFunction.CustomerReview("rvd");
    let rdata = await DataFind(`SELECT rvd.*, COALESCE(cus.id, "") AS cus_id, COALESCE(cus.name, "") AS name, COALESCE(cus.country_code, "") AS country_code,
                                COALESCE(cus.phone, "") AS phone ${dr.tot_review} ${dr.avgstar}
                                FROM tbl_request_vehicle AS rvd
                                LEFT JOIN tbl_customer AS cus ON rvd.c_id = cus.id
                                ${dr.table}
                                WHERE rvd.id = '${request_id}' AND JSON_CONTAINS(rvd.d_id, '${uid}') GROUP BY rvd.id ORDER BY id DESC`);

    if (rdata == "") {
        rdata = await DataFind(`SELECT rvd.*, COALESCE(cus.id, "") AS cus_id, COALESCE(cus.name, "") AS name,
                                COALESCE(cus.country_code, "") AS country_code, COALESCE(cus.phone, "") AS phone
                                ${dr.tot_review} ${dr.avgstar}
                                FROM tbl_cart_vehicle AS rvd
                                LEFT JOIN tbl_customer AS cus ON rvd.c_id = cus.id
                                ${dr.table}
                                WHERE rvd.id = '${request_id}' AND rvd.d_id = '${uid}'
                                GROUP BY rvd.id ORDER BY rvd.id DESC;`);

        if (rdata == "") 2
    }

    let request_data = []
    if (sttaus == "0") request_data = await DriverRequestData(rdata);
    else return 0

    return { request_data: request_data[0] }
}


async function AcceptBidding(uid, d_id, price, request_id, hostname, protocol) {
    try {
        console.log('AcceptBidding called with:', { uid, d_id, price, request_id });

        // Find the request
        const request = await DataFind(`SELECT * FROM tbl_request_vehicle WHERE id = '${request_id}' AND c_id = '${uid}'`);

        if (!request || request.length === 0) {
            console.error('Request not found in AcceptBidding');
            return false;
        }

        // Check if driver is in the bidding list
        let driverList = request[0].d_id;
        if (typeof driverList === 'string') {
            driverList = JSON.parse(driverList);
        }

        if (!driverList.includes(parseInt(d_id))) {
            console.error('Driver not in bidding list');
            return false;
        }

        // Create cart record (accepted bid)
        let fulldate = await TodatDate();
        let otp = await otpGenerate(4);
        let dropcount = request[0].drop_lat_long.split("&!!").length;

        const cartInsert = await DataInsert(`tbl_cart_vehicle`,
            `c_id, d_id, vehicleid, bidding_status, bidd_auto_status, price, final_price, paid_amount, coupon_amount,
             addi_time_price, platform_fee, weather_price, wallet_price, tot_km, tot_hour, tot_minute, status, payment_id, m_role,
             coupon_id, start_time, otp, additional_time, ride_status, drop_tot, drop_complete, current_run_time, status_time,
             status_time_location, status_calculation, pic_lat_long, drop_lat_long, pic_address, drop_address, driver_id_list`,
            `'${request[0].c_id}', '${d_id}', '${request[0].vehicleid}', '${request[0].bidding_status}', '${request[0].bidd_auto_status}',
             '${price}', '${price}', '0', '0', '0', '0', '0', '0', '${request[0].tot_km}', '${request[0].tot_hour}',
             '${request[0].tot_minute}', '1', '${request[0].payment_id}', '${request[0].m_role}', '${request[0].coupon_id || 0}',
             '${fulldate.date}T${fulldate.time}', '${otp}', '0', '0', '${dropcount}', '0', '', '',
             '1&${fulldate.date}T${fulldate.time}&0&0', '', '${request[0].pic_lat_long}', '${request[0].drop_lat_long}',
             '${request[0].pic_address}', '${request[0].drop_address}', '[]'`,
            hostname, protocol);

        if (cartInsert === -1) {
            console.error('Failed to create cart record');
            return false;
        }

        // Update driver status
        await DataUpdate(`tbl_driver`, `rid_status = '1', check_status = '1'`, `id = '${d_id}'`, hostname, protocol);

        // Delete the original request
        await DataDelete(`tbl_request_vehicle`, `id = '${request_id}'`, hostname, protocol);

        console.log('AcceptBidding successful');
        return { success: true, cart_id: cartInsert.insertId };

    } catch (error) {
        console.error('AcceptBidding function error:', error);
        return false;
    }
}


const AllFunction = {
    otpGenerate, ZoneLatlon, CheckZone, GetDistance, DriverUpdate, ZoneData, AddDateMinute, TodatDate, RadiusCheck, DriverRequestData, CheckBodyData,
    CheckCurrentLocation, CheckSocketData, SendDriverLatLong, VehicleRideStartEndData, VehicleAllRide, DateFormate, AllVehicleFormate, VehiclePaymentCal,
    TwoTimeDifference, FirstTime, SecoundTime, SetNewTimeFormate, DateConvertDay, PaymentCalculation, RideAddress, ConvertDateFormat, ConvertFullDateFormat, TimeUpdate,
    CustomerReview, DriverReview, CalculateMinuteToHour, PriceCalculation, VehicleBidding, MinuteToHour, AcceptVehicleRide, DriverNewRequestData, CurrentDatetoOldDateS ,AcceptBidding
}

module.exports = AllFunction